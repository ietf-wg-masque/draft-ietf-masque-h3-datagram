{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-12-05T01:12:19.600822+00:00",
  "repo": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "B6AFD3"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU1MTI2NzI2NDI=",
      "title": "Discussion of use of flow identifiers should be improved",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/2",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From @martinthomson ([link to email](https://mailarchive.ietf.org/arch/msg/quic/lSqgErC2E_svoz_28VxohJ39gDg)):\r\n\r\n> I would frame this slightly differently, to the above point: This creates a system of \"flow identifiers\" to allow for concurrent use of DATAGRAM frames by multiple extensions without creating contention.  Except that it doesn't entirely...\r\n>\r\n> You should mention that signaling about flow identifiers is necessary, but that is the responsibility of the protocol that defines the usage.  If you don't signal, how does a receiver know that flow ID 1 maps to usage foo and flow ID 2 maps to usage bar?\r\n>\r\n> Also, you should explain that there is no general limit to the flow identifier space, though protocols might want to provide mechanisms to limit usage to prevent resource exhaustion.  This will depend on the protocol, of course.  Some protocols might not expend resources when creating flow IDs.",
      "createdAt": "2019-10-25T19:05:02Z",
      "updatedAt": "2019-10-30T22:37:30Z",
      "closedAt": "2019-10-30T22:37:30Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed via https://github.com/DavidSchinazi/draft-h3-datagram/commit/3f0ff5d264cf7acf51d764fe65e20361dcfc4ddd",
          "createdAt": "2019-10-30T22:37:30Z",
          "updatedAt": "2019-10-30T22:37:30Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU1MjQ3MzMxNzE=",
      "title": "Add examples",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/3",
      "state": "CLOSED",
      "author": "rmarx",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I feel the text could use some concrete examples of use cases where application-layer demultiplexing would be useful (or, perhaps more generally, how unreliable data over HTTP/3 would be useful).",
      "createdAt": "2019-11-19T02:26:46Z",
      "updatedAt": "2020-12-13T04:42:05Z",
      "closedAt": "2020-12-13T04:42:05Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:05Z",
          "updatedAt": "2020-12-13T04:42:05Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU1ODI3NjkwNTU=",
      "title": "Register a setting",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/5",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In order to use this, this will need to be signaled somehow.  It seems like the draft infers that the presence of the transport parameter for DATAGRAM is sufficient, but I don't believe that to be the case.\r\n\r\nTake the case where a client offers three protocols for use via ALPN.  One of those might always include DATAGRAM support and so the client is obligated to offer the transport parameter.  But that does not imply that all three offered protocols support this extension equally.  You need a way to unambiguously signal that the combination of DATAGRAM and h3 are supported.  That means a setting.",
      "createdAt": "2020-03-17T05:41:30Z",
      "updatedAt": "2020-04-17T00:45:47Z",
      "closedAt": "2020-04-17T00:45:47Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree. I'll add a SETTING.",
          "createdAt": "2020-03-17T23:26:25Z",
          "updatedAt": "2020-03-17T23:26:25Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed via fd6e79923ca5fc0c22730d29abd5bbde2948bed1",
          "createdAt": "2020-04-17T00:45:47Z",
          "updatedAt": "2020-04-17T00:45:47Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU3MTc0ODkxNTE=",
      "title": "\"0-length\" DATAGRAMS",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/8",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since DATAGRAMS can have a 0-length payload, and H3 DATAGRAM mandates a flow ID, then something should be said about how an endpoint treats this.\r\n\r\nMy first reaction is that this is a connection error of type H3_FRAME_ERROR.",
      "createdAt": "2020-10-08T16:23:26Z",
      "updatedAt": "2020-12-13T04:42:04Z",
      "closedAt": "2020-12-13T04:42:03Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should also be extended to the frame being too short to decode varint.",
          "createdAt": "2020-10-08T16:25:51Z",
          "updatedAt": "2020-10-08T16:25:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, failing to parse the varint flow ID due to the DATAGRAM payload being too short is indicative of a serious malfunction in the peer's h3-datagram implementation, so closing the connection sounds reasonable.",
          "createdAt": "2020-10-08T16:34:12Z",
          "updatedAt": "2020-10-08T16:34:12Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:03Z",
          "updatedAt": "2020-12-13T04:42:03Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU3NjU3MTYzNTI=",
      "title": "Field:Flow ID cardinality",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/9",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It's not really clear whether there are any expectations in relation to cardinality of flow identifiers and the field.  Can two fields refer to the same flow ID?  Can the same request reference multiple flow IDs?",
      "createdAt": "2020-12-14T00:13:31Z",
      "updatedAt": "2021-01-05T12:26:13Z",
      "closedAt": "2021-01-05T12:26:13Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the h3 datagram draft should allow both:\r\n- two requests can reuse the same flow ID if the definition of that HTTP features allows it (this feature is used by the [QUIC extension to CONNECT-UDP](https://tools.ietf.org/html/draft-pauly-masque-quic-proxy))\r\n- one request can reference two flow IDs - I think this is already stated though:\r\n> For example, an HTTP method that wishes to use two datagram flow identifiers for the lifetime of its request stream could encode the second flow identifier as a parameter",
          "createdAt": "2020-12-15T00:27:01Z",
          "updatedAt": "2020-12-15T00:27:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm sure that people operating intermediaries might have something to say here.  A gateway that routes flows might be unwilling to replicate datagram flows that are bound to requests that go to different origin servers.\r\n\r\nI agree that one request to many flows is worthwhile, but mention in examples doesn't really count as a specification.",
          "createdAt": "2020-12-15T01:44:03Z",
          "updatedAt": "2020-12-15T01:44:03Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Fair enough, I'll add text to make this clearer. And I'll add a note to the intermediaries section about how the intermediary needs to ensure that if a second request arrives that shares a flow ID with a previous one, the intermediary MUST either send the new request to the same backend or reject it.",
          "createdAt": "2020-12-15T02:42:55Z",
          "updatedAt": "2020-12-15T02:42:55Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU3NjU3MTcyMTA=",
      "title": "Returning flow identifiers",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/10",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is a certain advantage to being able to use small flow identifiers, but there are only 32 of the smallest available for any given usage.  Would it be possible for a particular usage to reuse a value?\r\n\r\nI ask because CONNECT-UDP has a distinct start and end and could possibly take advantage of this.  That would have some small, but likely meaningful, impact on efficiency.",
      "createdAt": "2020-12-14T00:15:18Z",
      "updatedAt": "2021-01-05T12:53:24Z",
      "closedAt": "2021-01-05T12:53:24Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, this feature might make a real performance difference. The only caveat is reordering, we'll have to be careful that if receiving a RESET_STREAM frame for the CONNECT-UDP stream makes a flow ID available and a datagram with that flow ID gets reordered to arrive after, we'll need to check the packet number to make sure that this datagram is dropped instead of routed to its new owner.",
          "createdAt": "2020-12-15T00:22:24Z",
          "updatedAt": "2020-12-15T00:22:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't like looking at packet numbers and would be opposed to that.  It's a pretty serious layering violation.\r\n\r\nA guard interval to minimize the potential for overlap might help, but I would prefer that we only allow reuse if the protocol that is carried has some sort of protection against receiving bad packets.  Tunneled QUIC should work fine for that (though Version Negotiation packets are still a little bit of a concern), as would tunneled STUN/TURN and WebRTC.\r\n\r\nMore analysis would be required if the protocol did not provide its own integrity protection, but as this is primarily a tunneling protocol, we might be safe in advising against that.",
          "createdAt": "2020-12-15T01:48:48Z",
          "updatedAt": "2020-12-15T01:48:48Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU3NjU3MjEwNTc=",
      "title": "SF example parameter is confusing",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/11",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The document currently uses the following example:\r\n\r\n```\r\n     Datagram-Flow-Id = 42; alternate=44\r\n```\r\nMotivating this with an example of how to express multiple flow identifiers.\r\n\r\nI think that this example is potentially harmful.  It implies a lot about a potential extension mechanism as part of an example, but does not commit to properly defining an extension.  For examples like this I would much prefer to see something that is very clearly bogus.  Otherwise, people might implement that to the point that they even achieve interoperability of a sort.\r\n\r\nFor instance, the following requires a lot more guessing about how to interpret it, to the point that I would guess that pseudo-interoperability would be hard to arrive at by accident:\r\n\r\n```\r\n     Datagram-Flow-Id = 42; camels-per-orthodoxy=17.4\r\n```\r\n\r\nSee also #9.",
      "createdAt": "2020-12-14T00:22:56Z",
      "updatedAt": "2021-01-05T12:26:13Z",
      "closedAt": "2021-01-05T12:26:13Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The goal of this example was to show a way to build an extension. A full example of this being used is [the ECN extension to CONNECT-UDP](https://tools.ietf.org/html/draft-schinazi-masque-connect-udp-ecn). I'm not really sure how to improve this, because making it clearly bogus defeats the purpose. Could you provide a PR?",
          "createdAt": "2020-12-15T00:29:13Z",
          "updatedAt": "2020-12-15T00:29:13Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe we should talk more about the spelling of the ECN extension, which I haven't reviewed.\r\n\r\nI don't think that you should hide flow identifiers in this fashion.  It prevents an intermediary from understanding which requests are actively using flow identifiers.  A gateway might need to know that in order to ensure that DATAGRAM frames are consistently forwarded to the right origin server.\r\n\r\nAn alternative spelling that doesn't have that property would be:\r\n\r\n```\r\nDatagram-Flow-Id: 42; no-ecn, 43; ect0, 44; ecn-ce, 45; ect1\r\n```",
          "createdAt": "2020-12-15T01:41:46Z",
          "updatedAt": "2020-12-15T01:41:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "To make sure I'm understand you correctly, are you suggesting a structured field list here? That would work, and actually in that case I'd suggest dropping the parameter on the first element to make this simpler.\r\n\r\n```\r\nDatagram-Flow-Id: 42, 44; ect0, 46; ecn-ce, 48; ect1\r\n```",
          "createdAt": "2020-12-15T02:39:43Z",
          "updatedAt": "2020-12-15T02:40:58Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, that's it.  And I considered the same.  No parameter works fine.",
          "createdAt": "2020-12-15T03:01:42Z",
          "updatedAt": "2020-12-15T03:01:42Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU3NjU3NDM0NTQ=",
      "title": "Many reasons why a message with Datagram-flow-Id could be delayed",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/12",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 6 makes the keen observation that:\r\n\r\n```\r\n   Since the QUIC STREAM frame that contains the \"Datagram-Flow-Id\"\r\n   header could be lost or reordered, it is possible that an endpoint\r\n   will receive an HTTP/3 datagram with a flow identifier that it does\r\n   not know as it has not yet received the corresponding \"Datagram-Flow-\r\n   Id\" header.  Endpoints MUST NOT treat that as an error; they MUST\r\n   either silently discard the datagram or buffer it until they receive\r\n   the \"Datagram-Flow-Id\" header.\r\n```\r\n\r\nThis is accurate but, when thinking about HTTP/3 APIs, does not cover all possible reasons that might cause a request message to be processed after the corresponding DATAGRAM frame is available. For instance, the message might be blocked by QPACK, or the implementation might present DATAGRAMS before stream headers. \r\n\r\nWe could boil the ocean with describing all possible reasons, so I think it might be better to shuffle the text to focus on describe the symptom (DATAGRAMS before HTTP messages) and the treatment. We can then give non-exhaustive example(s) as already done.",
      "createdAt": "2020-12-14T01:00:48Z",
      "updatedAt": "2021-01-05T12:26:13Z",
      "closedAt": "2021-01-05T12:26:13Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I would prefer to not boil the ocean :)\r\n\r\nI'll make an editorial change to make it clearer that this is just an example among others.",
          "createdAt": "2020-12-14T01:08:25Z",
          "updatedAt": "2020-12-14T01:08:25Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU3NjU3NTM0OTY=",
      "title": "Running out of Flow IDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/13",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://tools.ietf.org/html/draft-schinazi-masque-h3-datagram-01#section-6 states:\r\n\r\n```\r\n   Note that integer structured fields can only encode values up to\r\n   10^15-1, therefore the maximum possible value of the \"Datagram-Flow-\r\n   Id\" header is lower then the theoretical maximum value of a flow\r\n   identifier which is 2^62-1 due to the QUIC variable length integer\r\n   encoding.  If the flow identifier allocation service of an endpoint\r\n   runs out of values lower than 10^15-1, the endpoint MUST treat is as\r\n   a connection error of type H3_ID_ERROR.\r\n```\r\n\r\nThe text is a little ambiguous. I presume the intention is that the endpoint that is allocating flows should do what HTTP/3 defines as [Immediate Application Closure](https://tools.ietf.org/html/draft-ietf-quic-http-32#section-5.3)? The doesn't cover the case where an endpoint receives a Datagram Flow ID greater than 10^15-1 (either in a request or a DATAGRAM).\r\n\r\nI think it might help to separate these cases. Receiving a value of 10^15-1 is always a connection error of type H3_ID_ERROR. \r\nBut I'm not so sure about the sender case, if you really are flow ID exhausted, perhaps it is nicer to just spin up a new connection and leave the current one as is. We might recommend that endpoints initiate an HTTP/3 graceful close followed by an application close - but reusing H3_ID_ERROR for that case seems a bit overkill.",
      "createdAt": "2020-12-14T01:17:38Z",
      "updatedAt": "2021-01-05T12:26:13Z",
      "closedAt": "2021-01-05T12:26:13Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think receiving a DATAGRAM whose flow ID is >= 10^15 is an error, the receiver should just silently drop it as the flow ID is unknown. Either way we should add text to clarify the expected action of the receiver.\r\n\r\nIn the sender case, I agree with you when the sender is the client, because in that case the client should instead just spin up a separate connection. On the server sender however, there is no such escape hatch, so perhaps we should tell the server to fail the operation that requested the flow ID.",
          "createdAt": "2020-12-14T02:00:28Z",
          "updatedAt": "2020-12-14T02:00:28Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry I was not specific in my comment. I meant to speak about receiving the header field e.g.\r\n\r\n```\r\nDatagram-Flow-Id: 10000000000000000\r\n```\r\n\r\nThat would lead to an SF Integer parsing error, which [IIUC](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-19) would cause the field to be ignored - unless we define different behaviour.\r\n\r\nIgnoring the header has an interesting interplay with the optional guidance to `buffer it until they receive\r\n   the \"Datagram-Flow-Id\" header`.\r\n\r\nIgnoring things that are strictly above the known limits seems a little too generous. Is there a reason not to reject such requests and HTTP/3 DATAGRAMS?",
          "createdAt": "2020-12-14T03:01:57Z",
          "updatedAt": "2020-12-14T03:01:57Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, in that case I agree - receipt of a Datagram-Flow-Id header with value >= 10^15 should cause a connection error of type H3_ID_ERROR.\r\n\r\nI was just thinking that conceptually receiving DATAGRAM with strange flow IDs should not be an error because that might lead implementors to declare than any unknown flow ID is an error which would break valid scenarios in the presence of reordering.",
          "createdAt": "2020-12-14T03:07:44Z",
          "updatedAt": "2020-12-14T03:07:44Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah. However, I think it would be fine to reject such a request with an 4xx response rather than tear down the entire connection...",
          "createdAt": "2020-12-14T03:14:11Z",
          "updatedAt": "2020-12-14T03:14:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Fair enough, that works too. I'll just state that in that scenario the request is malformed",
          "createdAt": "2020-12-14T03:45:15Z",
          "updatedAt": "2020-12-14T03:45:15Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU3NjU4NDU4MTQ=",
      "title": "0-RTT text is a bit obtuse",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/14",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nWhen servers decide to accept 0-RTT data, they MUST send a\r\nH3_DATAGRAM SETTINGS parameter greater or equal to the value they sent to the\r\nclient in the connection where they sent them the NewSessionTicket\r\nmessage.\r\n```\r\n\r\nIn layspeak I think this is saying \"if a server sent the value 1 before, it MUST send 1 now. If a server sent 0 before, it MUST send 0 or 1 now\". \r\n\r\nCould we maybe editorialize this to make it less likely for someone to do `value++` and end up sending `2`?",
      "createdAt": "2020-12-14T03:46:02Z",
      "updatedAt": "2021-01-05T12:48:32Z",
      "closedAt": "2021-01-05T12:48:32Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "There is text in the doc stating that only 0 and 1 are valid. But I do agree that the current text is somewhat clunky. Can you send a PR?",
          "createdAt": "2020-12-14T03:48:33Z",
          "updatedAt": "2020-12-14T03:48:33Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, I'll make a PR.",
          "createdAt": "2020-12-14T15:03:53Z",
          "updatedAt": "2020-12-14T15:03:53Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU3NjU4NTk0OTU=",
      "title": "Consider a different error code when the flow ID doesn't fit in the frame",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/15",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There's some good guidance about parsing the Flow ID out of the HTTP/3 Datagram with respect to datagram payload length. But I'm not sure if the recommend error code of PROTOCOL_VIOLATION is the most appropriate. This implies that the error is a Transport Error but I'd argue that at this point (parsing of the frame payload) that its an HTTP/3 Application error. \r\n\r\nSince we're not actually parsing a true HTTP/3 frame, just a view over a transport frame, H3_FRAME_ERROR seems too specific. So I think H3_GENERAL_PROTOCOL_ERROR is the most straightforward.\r\n\r\nI wonder what others think.",
      "createdAt": "2020-12-14T04:07:15Z",
      "updatedAt": "2021-01-05T12:49:26Z",
      "closedAt": "2021-01-05T12:49:26Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I honestly am fine with any error for this, though I'd prefer to reuse an existing one to reduce complexity.",
          "createdAt": "2020-12-15T00:19:18Z",
          "updatedAt": "2020-12-15T00:19:18Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU3NzkwODcxNzE=",
      "title": "reusing flow identifiers is racy",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/22",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "#20 introduced the following text:\r\n\r\n> The flow identifier allocation service MAY reuse previously retired flow identifiers once they have ascertained that there are no packets with DATAGRAM frames using that flow identifier still in flight.\r\n\r\nThere are 2 problems with this, in each direction:\r\n1. In the send-direction, this can only be ascertained in the case of no packet loss, when all packets have been acknowledged. If any packet is not acknowledged, this could be due to this packet actually having been lost or just reordered delayed.\r\n2. While it's possible to ascertain that all *sent* packets have been acknowledged, this is not possible for packets sent by the peer.\r\n\r\nReusing a flow identifier opens up an attack vector: An attacker could delay the delivery of a packet containing the old flow identifier until it has been retired and reused. This would lead to a reinterpretation of the DATAGRAM contents in a new application context.",
      "createdAt": "2021-01-05T14:17:17Z",
      "updatedAt": "2021-05-03T22:57:45Z",
      "closedAt": "2021-05-03T22:57:45Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "If your HTTP/3 code is closely coupled with your QUIC code, this can be solved by looking at QUIC packet numbers. If we take the CONNECT-UDP example, receiving a RESET_STREAM frame for the CONNECT-UDP stream ensures that the peer will not send subsequent DATAGRAM frames with this flow ID. If you record the packet number of the packet that carried the RESET_STREAM frame, you can then drop any DATAGRAM frames with that flow ID whose packet number is lower. That solves both problems you've described.",
          "createdAt": "2021-01-05T14:32:30Z",
          "updatedAt": "2021-01-05T14:32:30Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "> If your HTTP/3 code is closely coupled with your QUIC code, this can be solved by looking at QUIC packet numbers.\r\n\r\nIt is not, my implementation separates the two layers.\r\nIn the design of QUIC transport, we went a long way to avoid looking at the packet number at all. If this design principle applied to the transport, it should even more so apply to applications built on top of QUIC. \r\n\r\n> If you record the packet number of the packet that carried the RESET_STREAM frame, you can then drop any DATAGRAM frames with that flow ID whose packet number is lower.\r\n\r\nThat only applies for the server side, doesn't it? The client still wouldn't know if a packet it receives was sent before or after the ID was reassigned.",
          "createdAt": "2021-01-05T16:10:12Z",
          "updatedAt": "2021-01-05T16:10:12Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> It is not, my implementation separates the two layers.\r\n\r\nThis feature is optional, so you could choose to not implement it. Or are you proposing a different mechanism that works?\r\n\r\n> In the design of QUIC transport, we went a long way to avoid looking at the packet number at all. If this design principle applied to the transport, it should even more so apply to applications built on top of QUIC.\r\n\r\nI agree that we shouldn't violate this design principle in the mandatory parts of the spec, but doing so in optional features seems acceptable to me.\r\n\r\n> That only applies for the server side, doesn't it? The client still wouldn't know if a packet it receives was sent before or after the ID was reassigned.\r\n\r\nThis isn't really about client or server, but more about who sent the RESET_STREAM frame. The receiver of RESET_STREAM can key on the packet number that carried that frame, whereas its peer can key on the packet number of the first acknowledgement for that RESET_STREAM.",
          "createdAt": "2021-01-05T17:00:28Z",
          "updatedAt": "2021-01-05T17:00:28Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "> This feature is optional, so you could choose to not implement it.\r\n\r\nHow so? How do I prevent the peer from reusing a flow identifier?\r\n\r\n> Or are you proposing a different mechanism that works?\r\n\r\nActually, I'm not quite sure I understand the issue that @martinthomson raised in #10. I see flow identifiers as analogues to stream IDs. For stream IDs, we never even considered reusing them, even though that wouldn't have required a layer violation in that case.\r\nWhy are the 3 additional bytes (I'm assuming you're using fewer than 1073741823/2 identifiers on a typical connection, otherwise it's 7) too expensive in one case, but not the other?",
          "createdAt": "2021-01-05T17:16:59Z",
          "updatedAt": "2021-01-05T17:16:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> How so? How do I prevent the peer from reusing a flow identifier?\r\n\r\nWhy would you want to prevent the peer from reusing a flow identifier? The peer ensures the security properties of reuse.\r\n\r\n> Actually, I'm not quite sure I understand the issue that @martinthomson raised in #10. I see flow identifiers as analogues to stream IDs. For stream IDs, we never even considered reusing them, even though that wouldn't have required a layer violation in that case.\r\n> Why are the 3 additional bytes (I'm assuming you're using fewer than 1073741823/2 identifiers on a typical connection, otherwise it's 7) too expensive in one case, but not the other?\r\n\r\nBecause the payload of DATAGRAM frames needs to fit in a single QUIC packet, whereas STREAM frames allows splitting the payload across packets. When you're tunneling, this means that the overhead impacts your MTU when using DATAGRAMs.\r\n\r\n",
          "createdAt": "2021-01-05T17:25:06Z",
          "updatedAt": "2021-01-05T17:25:06Z"
        },
        {
          "author": "oesh",
          "authorAssociation": "NONE",
          "body": "I'd like to raise the attention towards the idea that reliably supporting reuse of flow identifiers can become quite complicated when in large-scale installations. \r\n\r\nConsider a large scale point of presence, where a large number of servers are sharing the same public IPs:\r\n\r\n\r\n```\r\n                                                   ^            \r\n                                                   |            \r\n                                                   |    Higher  \r\n                                                   |  protocols \r\n+--------------------------------------------+     |            \r\n|            Application cluster             |     |            \r\n+--------------------------------------------+     |            \r\n                                                   |            \r\n+-----------+                    +-----------+     |            \r\n|+---------+|                    |+---------+|     |            \r\n||   H3    ||                    ||   H3    ||     |            \r\n|+---------+|                    |+---------+|     |            \r\n|+---------+|  x 100             |+---------+|     |            \r\n||  QUIC   ||                    ||  QUIC   ||     |            \r\n|+---------+|                    |+---------+|     |            \r\n|+---------+|      GRE-style     |+---------+|     |            \r\n||   LB    |<------forwarding---->|   LB    ||     |            \r\n|+---------+|                    |+---------+|     |            \r\n+-----------+                    +-----------+     |            \r\n                                                   |            \r\n+--------------------------------------------+     |    Lower   \r\n|          Advertised IP addresses           |     |  protocols \r\n+--------------------------------------------+     |            \r\n                                                   v \r\n                                                   \r\n```\r\n\r\nIn such scenario, multiple datagrams that share the same flow identifier may be served by several distinct physical servers. In order for these servers to be able to route the datagrams in a consistent way, the flow id allocation service must be able to provide some sort of consistency guarantees: when the flow identifier expires, any server that may serve the flow needs to agree that the flow has indeed expired. In other words, there is a consensus problem lurking behind the scenes.\r\n\r\nWhile there are several ways to achieve such consensus, all share some propagation delay. Clients don't have a good way to estimating such delay (except for the observation that it's unlikely to be significantly shorter than the retransmit timeout). \r\n\r\nIt may be worth at least mentioning that reusing the flow identifiers rapidly is not recommended. \r\n\r\n(edit: changed the wording that has mistakenly projected an argument as a known fact).",
          "createdAt": "2021-02-01T22:32:11Z",
          "updatedAt": "2021-02-01T22:36:00Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @oesh , this is an interesting scenario but I'm not sure I understand it: are you saying that multiple servers can send the same datagram flow ID on the same connection? How does that work? Given that QUIC uses incremental packet numbers as the encryption nonce, you're going to need a synchronization point in the server-to-client datapath anyway, or am I misunderstanding something?",
          "createdAt": "2021-02-01T23:35:50Z",
          "updatedAt": "2021-02-01T23:35:50Z"
        },
        {
          "author": "oesh",
          "authorAssociation": "NONE",
          "body": "Hi @DavidSchinazi, I was probably unclear. It is also possible that I am missing something. Let me try to clarify my comment.\r\n\r\nEDIT: I have reformatted / rephrased and clarified the comment. Again, I may be missing something, and will be glad to learn more in this case.\r\n\r\n```\r\nThe flow allocation service SHOULD also provide a mechanism for applications to indicate \r\nthey have completed their usage of a flow identifier and will no longer be using that flow identifier,\r\nthis process is called \"retiring\" a flow identifier. \r\n```\r\n\r\nI think the main point of my comment - if the flow id is known to the applications, then it would be hard to communicate the retirement of the flow ID. In particular, in some situations it would be impossible for an endpoint to infer that a particular flow id has been successfully \"retired\" by the peer endpoint, because the application can retain the state associated with that flow id.",
          "createdAt": "2021-02-02T06:46:41Z",
          "updatedAt": "2021-02-02T17:00:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe the draft isn't clear: the idea is that the application is responsible for knowing that the flow ID is no longer in use, and ensuring that the application on the peer also knows that it is no longer in use, before retiring it - the application tells the flow allocation service to retire, the flow allocation service doesn't do it on its own.",
          "createdAt": "2021-02-02T18:57:41Z",
          "updatedAt": "2021-02-02T18:57:41Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU3ODQ2NDU5ODk=",
      "title": "Datagram Flow Id parameters should be not be names",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/24",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Rather than having names like `44; ecn-ect0`, the parameters should follow the usual parameter format, which would be like:\r\n\r\n44; ecn=ect0",
      "createdAt": "2021-01-12T22:38:44Z",
      "updatedAt": "2021-05-13T22:23:08Z",
      "closedAt": "2021-05-13T22:23:08Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "My understanding of the ask that lead to the \"name parameter\" being defined in draft-schinazi-masque-h3-datagram-04 was that we want to be able to assign unique handles to flow IDs in a generic way that is part of the this document. That would allow a general purpose implementation to be able to disambiguate lows without having to understand any specific extension.\r\n\r\nDuring the MASQUE interim, there was a suggestion for a different design that would define a `name` parameter eg. `44; name=ecn-ect0`. ",
          "createdAt": "2021-01-12T23:10:55Z",
          "updatedAt": "2021-01-12T23:10:55Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "Specific extensions may also want to add more parameters.\r\n\r\nWhat's the direct benefit of having a name, if I don't know what it means? Is it just to tell that flows are different?",
          "createdAt": "2021-01-14T00:29:35Z",
          "updatedAt": "2021-01-14T00:29:35Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "> Specific extensions may also want to add more parameters.\r\n\r\nRight. The intention wasn't to *only* permit names. Other parameters can be sent since sf-list allows that. The spec and/or interim meeting meeting slides might not have made that clear. In other words the goal was to allowing naming while avoiding an endpoint ignoring an unknown parameter and mishandling it as a name or some other extension. As the interim discussion evolved, it became clear there are other ways to specify the header that could achieve the goal.\r\n\r\nI'm also realising my understanding of the extensibility requirements might not be fully representative - so don't take my replies as absolutionist.",
          "createdAt": "2021-01-14T01:01:40Z",
          "updatedAt": "2021-01-14T01:01:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As we discussed, if you want the names to imply some sort of semantic, then that is what parameters are for.  The example @tfpauly gave is perfect: if you want this flow to be for ECT0-marked packets, then `ecn=ect0` is perfectly good.  The name thing was ambiguous and relied on ordering.\r\n\r\nThe ECN case might be bad for the purposes of extension handling.  You can process these flows without needing to know the meaning of the ECN markings.  However, there might be other cases where the parameter indicates a change in the datagram contents.  I think that there is an important distinction here between what endpoints do with this (that is, User Agent and Origin Server in HTTP parlance) and what an intermediary might do.\r\n\r\nAn intermediary forwards all flows and only remaps flow identifiers.  It doesn't need to understand the content of datagrams. Therefore, it can do that without knowing what the semantics are.\r\n\r\nEndpoints will need to understand the semantics in order to make use of the data.  This is tricky, because it means that you might need to negotiate understanding.  If we are doing MASQUE and a client adds a flow that is marked `48; ip`, with the intention that the flow contains whole IP packets (let's say of any version), the thing that consumes this flow needs to understand that.  That means that some extensions require *end-to-end* negotiation before the marking can be used.  A server that handles this in a request can reject the request and thereby avoid getting datagrams it can't handle (or being required to generate datagrams it can't produce).  However, the same is not true for responses, so maybe there is a need for clients to indicate what they are able to support.\r\n\r\nWorth a separate issue?",
          "createdAt": "2021-01-14T23:30:00Z",
          "updatedAt": "2021-01-14T23:30:00Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is no longer relevant now that we have merged #52, closing.",
          "createdAt": "2021-05-13T22:23:08Z",
          "updatedAt": "2021-05-13T22:23:08Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU3ODQ2NDg4ODk=",
      "title": "Please do not reuse flow-ids",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/25",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We have 2^62. We don't need to reclaim them,",
      "createdAt": "2021-01-12T22:44:36Z",
      "updatedAt": "2021-03-05T17:55:16Z",
      "closedAt": "2021-03-05T17:55:16Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "related to #22",
          "createdAt": "2021-01-12T23:02:49Z",
          "updatedAt": "2021-01-12T23:02:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as duplicate of #22.",
          "createdAt": "2021-03-05T17:55:16Z",
          "updatedAt": "2021-03-05T17:55:16Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU3OTcwMjEyODc=",
      "title": "packing DATAGRAMs with the same flow-id in a single QUIC packet",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/26",
      "state": "CLOSED",
      "author": "lnicco",
      "authorAssociation": "NONE",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "in Section 2 \"Flow Identifiers\" it reads \r\n\r\n> If multiple DATAGRAM frames can be packed into a single QUIC packet, the sender SHOULD group them by flow identifier to promote fate-sharing within a specific flow and improve the ability to process batches of datagram messages efficiently on the receiver.\r\n\r\nthis to me seems to be in conflict with the opening statement \r\n> QUIC DATAGRAM frames do not provide a means to demultiplex application contexts\r\n\r\nif the flow-id is in the DATAGRAM payload, the transport is not supposed to be peeking at it. While it could be a nice (but a bit hacky) optimization in a real-world implementation, I feel like the RFC having it as a SHOULD is not ideal. ",
      "createdAt": "2021-01-29T16:35:13Z",
      "updatedAt": "2021-05-03T23:00:58Z",
      "closedAt": "2021-05-03T23:00:58Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "In my experience, in order to build a high performance implementation of QUIC, you have to leverage the fact that layers can share information to improve performance. Are you saying that you'd prefer not using SHOULD for this kind of optimization?",
          "createdAt": "2021-01-30T00:12:54Z",
          "updatedAt": "2021-01-30T00:12:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I think Luca might have a point. If we consider this as a feature that a transport provides as a service, I don't really know what the service provides. There isn't another transport mechanism that relies on the ordering, or an interoperable aspect (would the other side be able to detect this?). It seems this is an aspect more about the API that QUIC provides, which is going to be a rich field of opportunity. There could be benefits but I don't know if we need to use the SHOULD. We could probably relax the language and try to articulate the benefits or tradeoffs of packetization and frame bundling. For instance, batching might interfere with timeliness, and controlling that might start creeping into prioritisation territory.\r\n\r\nThe more I think about it, the described behaviour about batch processing might assume the receiver behaves a certain way, which might not be true. Therefore this might not be a good default to recommend.  ",
          "createdAt": "2021-01-30T00:34:59Z",
          "updatedAt": "2021-01-30T00:34:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Fair enough. Perhaps we remove this for now, and add guidance once we have more implementation/deployment experience?",
          "createdAt": "2021-01-30T00:40:05Z",
          "updatedAt": "2021-01-30T00:40:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I can live with a less drastic edit, leaving the text in draws the reader attention to the idea that packing could be important. I'd be happy to put together an editorial replacement for review, and if we hate it, then drop the concrete recommendation?",
          "createdAt": "2021-01-30T00:46:59Z",
          "updatedAt": "2021-01-30T00:46:59Z"
        },
        {
          "author": "lnicco",
          "authorAssociation": "NONE",
          "body": "Thanks Lucas, you framed it way better than I could. \r\nAlso I believe that whether shared-fate within a flow is desirable or not may depend on the application.",
          "createdAt": "2021-02-02T02:57:04Z",
          "updatedAt": "2021-02-02T02:57:04Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "> whether shared-fate within a flow is desirable or not may depend on the application.\r\n\r\nI came here looking for the same information:  Why is fate-sharing desired?  Is there some background to this?",
          "createdAt": "2021-03-09T21:59:16Z",
          "updatedAt": "2021-03-09T21:59:16Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I think more implementation and deployment experience would help here.\r\n\r\nI can see cases like tunneling IP flows containing TCP where fate sharing is preferable, since it's better to lose two adjacent packets in one flow than one packet each in two flows.  But it seems a bit use-case specific?  Also, you would expect most TCP segments to be large enough you couldn't put two into a single QUIC packet.",
          "createdAt": "2021-03-10T21:13:28Z",
          "updatedAt": "2021-03-10T21:13:28Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU4MTI5ODAyNTc=",
      "title": "Make it explicit that Flow IDs are non-negative",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/27",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The draft doesn't do this. It relies on the QUIC varint encoding for non-negativity in DATAGRAM frames but `sf-integer` could contain a negative value. Let's be clear in the spec.",
      "createdAt": "2021-02-21T23:27:59Z",
      "updatedAt": "2021-03-08T15:27:30Z",
      "closedAt": "2021-03-08T15:27:30Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Definitely agree, could you write a PR please?",
          "createdAt": "2021-02-22T18:46:31Z",
          "updatedAt": "2021-02-22T18:46:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I will.",
          "createdAt": "2021-02-22T18:49:00Z",
          "updatedAt": "2021-02-22T18:49:00Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "fixed in https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/29",
          "createdAt": "2021-03-08T15:27:29Z",
          "updatedAt": "2021-03-08T15:27:29Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU4MTY5MzM4NDQ=",
      "title": "Datagram flows should have their individual max datagram size",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/28",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Consider a situation where a single HTTP/3 connection is terminated at a CDN and it carries two different WebTransport sessions to different backends.  Those backends may have different max datagram size, thus the protocol needs to be able to specify max datagram size limit per-flow.",
      "createdAt": "2021-02-26T01:05:14Z",
      "updatedAt": "2021-05-24T22:14:11Z",
      "closedAt": "2021-05-24T22:14:11Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you mean DATAGRAM frame? Theres still an open question about whether we will continue with the max size Transport Parameter as a integer, or whether plain enable / disable would work ",
          "createdAt": "2021-02-26T01:10:58Z",
          "updatedAt": "2021-02-26T01:10:58Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure whether this feature would be useful. Since datagram-based applications already need to perform PMTUD because the MTU might vary on each hop, I don't think there's much value in propagating the value of the transport parameter.",
          "createdAt": "2021-05-19T20:37:04Z",
          "updatedAt": "2021-05-19T20:37:04Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed this offline with @vasilvv. Given that the MTU can change mid-flow for each hop, propagating this information to both endpoints is non-trivial. This means there are two solutions:\r\n1. applications that use datagrams perform their own end-to-end PMTUD\r\n2. a future extension to HTTP/3 datagrams could define a way to communicate this\r\n\r\nIn both cases, we don't need to address this now in the HTTP/3 datagrams draft, so I'm closing this issue.",
          "createdAt": "2021-05-24T22:14:11Z",
          "updatedAt": "2021-05-24T22:14:11Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU4MjQ2NTUyMTk=",
      "title": "Flow ID allocation failures",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/30",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "draft 00 section 6 says:\r\n\r\n```\r\n   If the flow identifier allocation service\r\n   of an endpoint runs out of values lower than 10^15-1, the endpoint\r\n   MUST fail the flow identifier allocation.\r\n```\r\n\r\nFirst, Section 3, which talks about the service, seems like a better place to more-generally talk about errors. Specific error conditions probably depend on the encoding - in this case, the maximum depends on Datagram-Flow-Id header but we might imagine other uses of H3 DGRAM might have other limits.\r\n\r\nSecond, what does failure look like? Is it a \"won't vend flow ID\" or is this a connection-critical error etc. ",
      "createdAt": "2021-03-08T15:10:42Z",
      "updatedAt": "2021-05-13T22:23:22Z",
      "closedAt": "2021-05-13T22:23:22Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "From the flow allocation service's perspective, it just reports the failure to the requesting application context. Applications need to handle this and decide how. For example, a CONNECT-UDP client should handle failure by opening a second connection, but keeping the current one open until all its streams are done.",
          "createdAt": "2021-03-08T15:14:04Z",
          "updatedAt": "2021-03-08T15:14:04Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "that make sense. But there is also an implication that the flow ID allocation service needs to be primed with some knowledge of the bounds for which it can allocate, which might be application-specific. So it makes me wonder what the benefit of putting it in the allocation service itself is. An alternative is that the allocation service provides any legal wire-format value, and the application could enforce the 10^15-1 limit. ",
          "createdAt": "2021-03-08T15:33:45Z",
          "updatedAt": "2021-03-08T15:33:45Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a fair point. In practice I don't expect this to ever happen (a given QUIC connection can only send 2^62 packets after all, and that number goes down to 2^23 if using AES), so it might be best to go for the simpler option and just declare 10^15 (which is roughly 2^50) as the max in the allocation service...",
          "createdAt": "2021-03-08T15:38:48Z",
          "updatedAt": "2021-03-08T15:40:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Introducing a hard 10^15  limit would also go some way to addressing https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/31",
          "createdAt": "2021-03-08T18:39:36Z",
          "updatedAt": "2021-03-08T18:39:36Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is no longer relevant now that we have merged #52, closing.",
          "createdAt": "2021-05-13T22:23:22Z",
          "updatedAt": "2021-05-13T22:23:22Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU4MjQ2NjAzNjM=",
      "title": "Is it an error to receive a flow ID greater than 10^15-1?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/31",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There's a disparity between the largest flow ID that can be carried in the DATAGRAM frame and the largest that we can express in Datagram-Flow-Id.\r\n\r\nDraft 00 prevents a flow ID allocation of >= 10^15-1 but doesn't seem to address the case where a DATAGRAM frame contains that value. This is clearly an error, and I'd suggest that it is a connection error; probably `H3_ID_ERROR` or some new codepoint if we really wanted.",
      "createdAt": "2021-03-08T15:16:37Z",
      "updatedAt": "2021-05-13T22:23:31Z",
      "closedAt": "2021-05-13T22:23:30Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think that needs to be an error, we can simply treat this like any other unknown flow ID?",
          "createdAt": "2021-03-08T15:23:32Z",
          "updatedAt": "2021-03-08T15:23:32Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "IMO this is clearly a situation that shouldn't happen and indicates the sending endpoint probably has some bug. I'm not sure on what being silent on the matter helps.",
          "createdAt": "2021-03-08T16:03:18Z",
          "updatedAt": "2021-03-08T16:03:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is no longer relevant now that we have merged #52, closing.",
          "createdAt": "2021-05-13T22:23:30Z",
          "updatedAt": "2021-05-13T22:23:30Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU4MjYzNzY2MzU=",
      "title": "What guarantees are there against re-using flow IDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/32",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "QUIC has strong guarantees on not re-using Stream IDs.\r\n\r\nThere was strong consensus against allowing re-use of Flow IDs(#22).  The WG today was also leaning towards creating flow IDs that are not related to the Stream ID, which means preventing Flow ID re-use may be a challenge, since we can't rely on Stream ID non-reuse.\r\n\r\nOptions for enforcement include best effort ie: \"MUST close the connection if reuse is detected\" or try to ensure datagram flow IDs are used in order, which could allow enforcement be mandated.\r\n",
      "createdAt": "2021-03-09T17:56:55Z",
      "updatedAt": "2021-05-13T22:23:35Z",
      "closedAt": "2021-05-13T22:23:35Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that we don't currently have text about enforcing the prohibition on reuse. But I'm not sure this is a feature we need? QUIC stream creation is flow controlled (via MAX_STREAMS) so there is infrastructure for this. QUIC Datagram Flow creation is not flow controlled, so I don't see this as a direct mapping. Do you have a use case that would require or benefit from this enforcement?",
          "createdAt": "2021-03-09T22:12:50Z",
          "updatedAt": "2021-03-09T22:12:50Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I do not.\r\n\r\nGiven that, I think a \"MUST close the connection if reuse is detected\" approach seems fine, but it's worth documenting.",
          "createdAt": "2021-03-10T03:39:11Z",
          "updatedAt": "2021-03-10T03:39:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "To clarify, reusing a flow ID for _different_ uses will be disallowed by the PR that resolves #22. However, two requests can refer to the same flow ID for the _same_ usage, that will stay legal. Because of this, I wouldn't know how to implement the MUST you describe.",
          "createdAt": "2021-03-10T12:13:03Z",
          "updatedAt": "2021-03-10T12:13:03Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I filed #33 for two requests referring to a single flow ID.",
          "createdAt": "2021-03-10T21:14:36Z",
          "updatedAt": "2021-03-10T21:14:36Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is no longer relevant now that we have merged #52, closing.",
          "createdAt": "2021-05-13T22:23:35Z",
          "updatedAt": "2021-05-13T22:23:35Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU4MjgzMzY3OTA=",
      "title": "Allowing a single flow ID to be associated with multiple requests is brittle",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/33",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The only note in the draft I see about this is:\r\n\"If an intermediary processes distinct HTTP requests that refer to the same flow ID in their respective \"Datagram-Flow-Id\" header fields, it MUST ensure that those requests are routed to the same backend.\"\r\n\r\nThis is not a requirement our load balancer would be able to enforce,\u00a0since requests are routed to backends individually.\u00a0 Is there a use case that really needs this, because it feels very odd to me as well as not working for our deployment.",
      "createdAt": "2021-03-10T21:08:14Z",
      "updatedAt": "2021-05-13T22:23:44Z",
      "closedAt": "2021-05-13T22:23:43Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett we're going to have to change our load balancer to handle datagrams, so the fact that it only deals in requests today doesn't mean it'll behave a given way once it supports MASQUE and/or WebTransport. In particular we're going to need a map from datagram flow ID to backend no matter what we do, so checking that map on incoming requests isn't unreasonable.\r\n\r\nThe current example use-case for this feature is [draft-pauly-masque-quic-proxy-00](https://tools.ietf.org/html/draft-pauly-masque-quic-proxy-00).",
          "createdAt": "2021-03-10T21:16:27Z",
          "updatedAt": "2021-03-10T21:16:27Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "In order to meet the requirement, I think you cannot have a 1:N mapping between flow ID and request stream.  If there were more than one stream that used the same flow ID, and those streams were routed to different backends, there would be no way to choose which to deliver an incoming datagram to (or are you supposed to replicate it?)",
          "createdAt": "2021-03-10T22:50:46Z",
          "updatedAt": "2021-03-10T22:50:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is no longer relevant now that we have merged #52, closing.",
          "createdAt": "2021-05-13T22:23:43Z",
          "updatedAt": "2021-05-13T22:23:43Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU4MjgzNzE3MjI=",
      "title": "Why are flow IDs named?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/34",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I spent a while trying to understand this and it's not clear to me from the spec.  Lucas posted this on Issue #24, but it's not quite enough for me(and it's not in the document).\r\n\r\n\r\n> My understanding of the ask that lead to the \"name parameter\" being defined in draft-schinazi-masque-h3-datagram-04 was that we want to be able to assign unique handles to flow IDs in a generic way that is part of the this document. That would allow a general purpose implementation to be able to disambiguate lows without having to understand any specific extension.\r\n\r\n_Originally posted by @LPardue in https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/24#issuecomment-759095560_",
      "createdAt": "2021-03-10T21:42:46Z",
      "updatedAt": "2021-05-13T22:23:51Z",
      "closedAt": "2021-05-13T22:23:51Z",
      "comments": [
        {
          "author": "achernya",
          "authorAssociation": "NONE",
          "body": "I think we should remove the flow ID names. The document appears to try to create a semantic meaning for them, but it has no effect on the wire image, so we can (and IMO should) do the semantic meanings in application level code.",
          "createdAt": "2021-03-10T22:28:11Z",
          "updatedAt": "2021-03-10T22:28:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is no longer relevant now that we have merged #52, closing.",
          "createdAt": "2021-05-13T22:23:51Z",
          "updatedAt": "2021-05-13T22:23:51Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU4Mjg0MTMyOTE=",
      "title": "Remove the ECN example in Datagram-Flow-Id Header Field Definition",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/35",
      "state": "CLOSED",
      "author": "achernya",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, the Datagram-Flow-Id Header Field Definition section contains examples of the Datagram-Flow-Id header, which includes a 4-flow mechanism for conveying ECN information:\r\n\r\n> Datagram-Flow-Id = 42, 44; ecn-ect0, 46; ecn-ect1, 48; ecn-ce\r\n\r\nThis example seems to be tripping people up, myself included, by attempting to solve a problem of in-band signaling of non-UDP-payload bits by providing these streams, and drawing attention to that problem rather than the capability being described.\r\n\r\nI propose we remove this example until we have a better one to replace it. If we cannot find a good example, that also lends some evidence that perhaps we don't need the feature of creating multiple Datagram-Flow-Id associations in the same request.",
      "createdAt": "2021-03-10T22:25:28Z",
      "updatedAt": "2021-05-03T23:06:43Z",
      "closedAt": "2021-05-03T23:06:43Z",
      "comments": []
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU4MzUzMDk2NDM=",
      "title": "Add a note about sticking out to security considerations",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/36",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed at IETF 110, some MASQUE servers may prefer to avoid sticking out (i.e. they may wish to be indistinguishable from a non-MASQUE-capable HTTP/3 server). The H3_DATAGRAM SETTINGS parameter may stick out. Therefore, we should add a note about this to the Security Considerations section. A simple solution could be to encourage widespread HTTP/3 servers to always send this.",
      "createdAt": "2021-03-18T22:07:54Z",
      "updatedAt": "2021-05-03T23:14:12Z",
      "closedAt": "2021-05-03T23:14:12Z",
      "comments": []
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU4NTkzNDc4MTc=",
      "title": "DATAGRAM and STREAM+FIN reordering",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/40",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "H3 datagrams are associated with a stream, so it makes sense that it is only valid to send DATAGRAMs before sending the stream FIN.  These packets may be received out of order however.  What should receivers do with these packets?\r\n\r\nThe simplest action for the receiver is to drop any datagrams received after FIN, but I can imagine applications where the receiver would prefer to allow them to be processed for some time.  Should the draft offer guidance for this?\r\n\r\nThe answer might be different if we use Flow IDs as connection scoped identifiers or the 2-layer approach (Stream ID+Flow ID) discussed at the interim.",
      "createdAt": "2021-04-16T00:16:07Z",
      "updatedAt": "2021-05-27T01:21:55Z",
      "closedAt": "2021-05-27T01:21:55Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this might be a case for \"MUST NOT send datagram after the stream is closed for sending, MAY ignore datagrams if detected they are received after the stream is closed.\"\r\n\r\nThe challenge I've seen for implementations is that the stream read and datagram read functions operate independently. Its hard to correlate any state or actions between the two. In my case, ACK'ing a packet containing a FIN doesn't mean anything about how the receiver application will read the stream data.",
          "createdAt": "2021-04-16T11:35:43Z",
          "updatedAt": "2021-04-16T11:37:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for filing this. I'll add text to address this after we switch to the two-layer approach (assuming that becomes official WG consensus)",
          "createdAt": "2021-04-16T19:08:29Z",
          "updatedAt": "2021-04-16T19:08:29Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "The proposal here was receiver MAY drop a datagram after receiving FIN, but the merged PR has receiver MUST drop.  I prefer MAY, since I can envision a use case where the receiver would rather wait for a period to allow wayward datagrams to arrive, rather than declaring everything lost because of minor reordering.\r\n\r\nIs there a strong objection to changing this MUST to a MAY?",
          "createdAt": "2021-05-26T15:50:50Z",
          "updatedAt": "2021-05-26T15:50:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind Can you provide an example of a use-case for not dropping a datagram which arrived after the stream was closed? I'm failing to imagine an application that would benefit from this.",
          "createdAt": "2021-05-26T18:28:23Z",
          "updatedAt": "2021-05-26T18:28:23Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "\"Naive Partial Reliability\" or NPR:\r\n\r\nClient sends a request to the server indicating it is willing to accept the response body of an HTTP message over DATAGRAM rather than in the stream.\r\nServer sends the headers on the stream, and a marker indicating the response will come via DATAGRAMs (registering a context for this perhaps)\r\nServer sends DATAGRAMs containing the response body (and offsets)\r\nServer sends stream FIN\r\n\r\nThe client receives the stream FIN before the DATAGRAMs because of reordering, and assumes all response body was lost.\r\nDatagrams arrive at client shortly thereafter and per #57 are dropped.",
          "createdAt": "2021-05-26T18:34:26Z",
          "updatedAt": "2021-05-26T18:34:26Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "HTTP/2 kind of has some similar issues. It makes statements like\r\n\r\n> WINDOW_UPDATE or RST_STREAM frames can be received in this state\r\n      for a short period after a DATA or HEADERS frame containing an\r\n      END_STREAM flag is sent.  Until the remote peer receives and\r\n      processes RST_STREAM or the frame bearing the END_STREAM flag, it\r\n      might send frames of these types.  Endpoints MUST ignore\r\n      WINDOW_UPDATE or RST_STREAM frames received in this state, though\r\n      endpoints MAY choose to treat frames that arrive a significant\r\n      time after sending END_STREAM as a connection error\r\n      (Section 5.4.1) of type PROTOCOL_ERROR.\r\n\r\n and elsewhere     \r\n\r\n >    To avoid these problems, an endpoint SHOULD retain stream\r\n   prioritization state for a period after streams become closed.  The\r\n   longer state is retained, the lower the chance that streams are\r\n   assigned incorrect or default priority values.",
          "createdAt": "2021-05-26T18:49:14Z",
          "updatedAt": "2021-05-26T18:49:30Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "OK this makes sense to me, I can tweak the text to allow keeping stream state around for slightly longer.",
          "createdAt": "2021-05-26T18:51:25Z",
          "updatedAt": "2021-05-26T18:51:25Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU4NjAxODI5MjU=",
      "title": "2-layer design",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/41",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "During the 2021-04 MASQUE Interim, we discussed a design proposal from @bemasc to replace the one-layer flow ID design with a two-layer design. This design replaces the flow ID with two numbers: a stream ID and a context ID. The contents of the QUIC DATAGRAM frame would now look like:\r\n```\r\nHTTP/3 DATAGRAM Frame {\r\n  Stream ID (i),\r\n  Context ID (i),\r\n  HTTP/3 Datagram Payload (..),\r\n}\r\n```\r\n\r\nWhile the flow ID in the draft was per-hop, the proposal has better separation:\r\n* the stream ID is per-hop, it maps to an HTTP request\r\n* the context ID is end-to-end, it maps to context information inside that request\r\n\r\nIntermediaries now only look at stream IDs and can be blissfully ignorant of context IDs.\r\n\r\nIn the room at the 2021-04 MASQUE Interim, multiple participants spoke in support of this design and no one raised objections. This issue exists to ensure that we have consensus on this change - please speak up if you disagree.",
      "createdAt": "2021-04-16T21:28:06Z",
      "updatedAt": "2021-05-13T22:16:59Z",
      "closedAt": "2021-05-13T22:16:59Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I am fine with the 2-layer design for CONNECT-UDP, but I am not sure if the second identifier should be in H3 DATAGRAM or should be specific to CONNECT-UDP. As I indicated to the list, webtrans and httpbis might weigh in on this with broader consideration of other use cases.",
          "createdAt": "2021-04-22T21:59:41Z",
          "updatedAt": "2021-04-22T21:59:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @martinduke the topic of the optionality of context IDs is discussed in issue #45.",
          "createdAt": "2021-04-23T01:13:08Z",
          "updatedAt": "2021-04-23T01:13:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I think this is a good design, because it minimizes the core functionality of the draft, but avoids every application that needs multiple dynamically created sub-flows from re-inventing a different mechanism.\r\n\r\nNit: I would not call this a 'Frame', since it's not an HTTP(TLV) frame.",
          "createdAt": "2021-04-23T19:39:33Z",
          "updatedAt": "2021-04-23T19:39:33Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU4NjAxOTA0ODc=",
      "title": "Directionality of flow/context IDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/42",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In draft-ietf-masque-h3-datagram-00, flow IDs are bidirectional. During the 2021-04 MASQUE Interim, we discussed the possibility of making them unidirectional. Here are the differences:\r\n\r\n* Bidirectional\r\n  * single shared namespace for both endpoints (even for client, odd for server)\r\n  * it's easier to refer to peer's IDs, which makes negotiation easier\r\n\r\n* Unidirectional\r\n  * one namespace per direction\r\n  * every bidirectional use needs to associate both directions somehow\r\n\r\nI'm personally leaning towards keeping them bidirectional. Unlike QUIC streams, these do not have a state machine or flow control credits, so there is no cost to only using a single direction of a bidirectional flow for unidirectional use-cases.",
      "createdAt": "2021-04-16T21:44:34Z",
      "updatedAt": "2021-05-13T22:16:59Z",
      "closedAt": "2021-05-13T22:16:59Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "There's another option where flows are unidirectional but they share a namespace (cleint even/server odd).\r\n\r\nI'm undecided. And I also don't know how important it is to choose. The 2 layer design means that DATAGRAMs always have a bidirectional tie via the stream ID.\r\n\r\nOn balance, I think bidirectional would be good enough today but I would be receptive to extension use cases that make a strong point of unidirectional.",
          "createdAt": "2021-04-16T22:19:34Z",
          "updatedAt": "2021-04-16T22:19:34Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "\ud83e\udd37 Bidirectional is my personal preference, but either way could work ultimately. It seems to me that any extension that wants unidirectional can just only use this context/flow/etc ID for one direction if it wants.",
          "createdAt": "2021-04-17T02:32:44Z",
          "updatedAt": "2021-04-17T02:32:44Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "I think bidirectional flows are likely overcomplicated and unnecessary.  For example, if either peer can \"close\" a flow, this requires a much more complex state machine.  In my experience, half-closed states are hard to get right.  Closing unidirectional flows seems much easier to reason about.\r\n\r\nMany, perhaps most, of our use cases for flows are really unidirectional.  For example, DSCP marking likely only makes sense from client to server, while timestamps for congestion control tuning likely only make sense from server to client.  QUIC connection IDs are different in each direction, so QUIC header compression may be easiest to understand with unidirectional flows.",
          "createdAt": "2021-04-19T16:57:49Z",
          "updatedAt": "2021-04-19T16:57:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> In my experience, half-closed states are hard to get right.\r\n\r\nBidirectional doesn't imply half-close states. I'm thinking of a bidirectional flow that can only be closed atomically as a whole.\r\n\r\n> Many, perhaps most, of our use cases for flows are really unidirectional.\r\n\r\nI don't think that's true. The default extension-less CONNECT-UDP is bidirectional. So is ECN, and so would a timestamp extension.",
          "createdAt": "2021-04-19T18:06:25Z",
          "updatedAt": "2021-04-19T18:06:25Z"
        },
        {
          "author": "achernya",
          "authorAssociation": "NONE",
          "body": "I would prefer bidirectional without support for half-close. I feel that having unidirectional flow/context IDs adds overhead we don't need; peers now need to track those associations and it's unclear what the benefits of having them separated out are.",
          "createdAt": "2021-04-19T18:10:46Z",
          "updatedAt": "2021-04-19T18:10:46Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "This issue is conflating consent (unilateral/bilateral) with scope (unidirectional/bidirectional). IIUC there are two questions here:\r\n1) Can I send a flow-id forever once declared, or can the endpoint tell me to stop without killing the whole stream (consent)?\r\n2) Can the receiver of a flow-id assignment use that same flow-id when sending datagrams, or could this mean something completely different?\r\n\r\nI think the answer to (1) is \"yes, it can tell me to stop\" (i.e. it is negotiated while allowing speculative sending). For (2), I lean toward bidirectional, but not strongly. There are plenty of codepoints, so it seems wasteful for each endpoint to define the same semantic explicitly.",
          "createdAt": "2021-04-22T21:32:10Z",
          "updatedAt": "2021-04-22T21:32:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinduke the intent of this issue wan't to conflate those two things. This issue is about scope. For consent, see issue #43.",
          "createdAt": "2021-04-23T01:21:44Z",
          "updatedAt": "2021-04-23T01:21:44Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Conceptually, I like unidirectional better.  I tell the peer that when I send with context-ID=X, it has a given semantic.  For bidirectional the sender is saying both that and that if the peer sends on that ID the original sender will interpret with the same semantic.  That might not even make sense.\r\n\r\nIs it possible to associate datagrams with a unidirectional stream (push?).  If so, does allowing for bidirectional context imply that even though the receiver cannot send frames on the stream, it can send datagrams?\r\n\r\nEvery negotiation does run the risk of loss/reordering resulting in a drop or buffering event at the receiver.  The appeal of bidirectional is that it removes half of this risk in the cases where the bidirectionality is used.",
          "createdAt": "2021-04-27T16:41:00Z",
          "updatedAt": "2021-04-27T16:41:00Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "To second @achernya I would also prefer bidirectional without support for half-close.  Given you can always not send something in one direction, and there's none of the overhead of streams(ie: flow control, etc) I can't see any benefits of unidirectional over bidirectional in this case.\r\n\r\nAssociating h3-datagrams with a server push seems like unnecessary complexity to me, but you're right that it should be clarified.  #47\r\n\r\n",
          "createdAt": "2021-05-02T16:53:34Z",
          "updatedAt": "2021-05-02T16:53:34Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU4NjAyMDE4Nzk=",
      "title": "Ability to accept or reject registration of context IDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/43",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "During the 2021-04 MASQUE Interim, we discussed having the ability to accept or reject registration of context IDs. An important motivation for this is the fact that context ID registrations take up memory (for example it could be a compression context which contains the data that is elided) and therefore we need to prevent endpoints from arbitrarily making their peer allocate memory. While we could flow control context ID registration, a much simpler solution would be to have a way for endpoints to close/shutdown a registration.",
      "createdAt": "2021-04-16T21:59:00Z",
      "updatedAt": "2021-05-13T22:16:59Z",
      "closedAt": "2021-05-13T22:16:59Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC there's an opposing view that the constraints can be negotiated apiori. Either statically (such as defining an extension which states that there can only be N contenxts of a given type) or dynamically using something like a HTTP header. Failure to meet these constraints could lead to an HTTP/3 stream or connection error rather than a flow rejection.",
          "createdAt": "2021-04-16T22:30:48Z",
          "updatedAt": "2021-04-16T22:30:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue I've filed #44 to discuss whether to register/negotiate at request start or mid-stream.",
          "createdAt": "2021-04-16T23:19:30Z",
          "updatedAt": "2021-04-16T23:19:30Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "I think that if there is the ability to register mid-stream (#44), we need the ability to close/de-register/reject mid-stream as well. If we don't have mid-stream changes, then no need to negotiate.\r\n\r\nHowever, someone trying to register something needs to be able to know whether or not the thing they registered will be accepted.",
          "createdAt": "2021-04-17T02:31:26Z",
          "updatedAt": "2021-04-17T02:31:26Z"
        },
        {
          "author": "achernya",
          "authorAssociation": "NONE",
          "body": "I agree that notification of the registration status is particularly important if we allow mid-stream registration.",
          "createdAt": "2021-04-19T18:11:45Z",
          "updatedAt": "2021-04-19T18:11:45Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU4NjAyNDI4MzQ=",
      "title": "Pick mechanism to register context IDs (header vs message)",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/44",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "During the 2021-04 MASQUE Interim, we discussed multiple options for registering context IDs. Without going into the specific of the encoding, there are two broad classes of solutions:\r\n\r\n* \"Header\" design\r\n  * Once-at-setup registration\r\n  * This happens during the HTTP request/response\r\n  * Simplest solution is to use an HTTP header such as `Datagram-Flow-Id` (encoding TBD)\r\n  * Example use-case: CONNECT-UDP without extensions\r\n* \"Message\" design\r\n  * Mid-stream registration\r\n  * This can happen at any point during the lifetime of the request stream\r\n  * This would involve some sort of \"register\" message (encoding TBD, see separate issue)\r\n  * Example use-case: CONNECT-IP on-the-fly compression (this can't be done at tunnel setup time because the bits top be compressed aren't always known at that time)\r\n \r\nIt's possible to implement once-at-setup registration using the Message design, but it isn't possible to implement mid-stream registration. Therefore I think we should go with the Message design. It would also be possible to implement both but I don't think that provides much value.",
      "createdAt": "2021-04-16T23:00:50Z",
      "updatedAt": "2021-05-13T22:16:59Z",
      "closedAt": "2021-05-13T22:16:59Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to here some more from the WebTransport use case on the issue. \r\n\r\nMy understanding is that the Requests are used to create WebTransport sessions and that creation of datagram flows(contexts) could be a lot more ad-hoc / server generated after the request phase, when compared to the CONNECT-UDP case.\r\n\r\nCc @vvasiliev",
          "createdAt": "2021-04-17T00:06:05Z",
          "updatedAt": "2021-04-17T00:06:59Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "Personally, I'd vote for either \"message\" or \"message + header\" (a la priorities), but not just \"header\". Mid-stream annotation of context/flow/etc is quite useful.",
          "createdAt": "2021-04-17T02:29:51Z",
          "updatedAt": "2021-04-17T02:29:51Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I prefer \"Message\" only, since the dynamic use case seems like a fairly compelling use of sub-flows(contexts?).\r\n\r\nI'm not sure there are many cases when one allocates all sub-flows up front AND needs to use a header to do that in a flexible way.  If an application needs multiple sub-flows, but they're fixed in number/format(ie: data and control), I don't think there's a need for a header or a \"Message\", since the application can consider that part of its internal format.",
          "createdAt": "2021-04-23T19:47:30Z",
          "updatedAt": "2021-04-23T19:47:30Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU4NjAyNDY1MzI=",
      "title": "Is the context ID optional?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/45",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This issue assumes that decide to go with the two-layer design described in #41. Given that design, some applications might not need the multiplexing provided by context IDs. We have multiple options here:\r\n\r\n* Make context ID mandatory\r\n  * Applications that don't need it waste a byte per datagram\r\n* Negotiate the presence of context IDs using an HTTP header\r\n  * Context IDs would still be mandatory to implement on servers because the client might send that header\r\n* Have the method determine whether context IDs are present or not\r\n  * This would prevent extensibility on those methods\r\n* Create a REGISTER_NO_CONTEXT message\r\n  * This assumes we use the Message design from #44\r\n  * We add a register message that means that this stream does not use context IDs\r\n  * This allows avoiding the byte overhead without sacrificing extensibility",
      "createdAt": "2021-04-16T23:07:41Z",
      "updatedAt": "2021-05-24T16:16:13Z",
      "closedAt": "2021-05-24T16:16:13Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "Making the context ID mandatory is simple, although slightly wasteful.\r\n\r\nFor the variations where it is optional, I prefer the one that uses a header. It could work with a variant of #44 where we do Header + Message, and the Header determines whether or not you have contexts, and whether or not they can be dynamic.",
          "createdAt": "2021-04-17T02:35:25Z",
          "updatedAt": "2021-04-17T02:35:25Z"
        },
        {
          "author": "achernya",
          "authorAssociation": "NONE",
          "body": "What are the benefits of message over header to make it optional? To me it seems like header is sufficient, because the context IDs are end-to-end, and should not affect intermediaries, making the header a natural place to put it. I think having the context ID be the default behavior and the header is to opt-out is the right decision if we were to allow removing it.",
          "createdAt": "2021-04-19T18:13:58Z",
          "updatedAt": "2021-04-19T18:13:58Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": ">  I think having the context ID be the default behavior and the header is to opt-out is the right decision if we were to allow removing it.\r\n\r\nThis is a bit of a bike-shed, but why would it default to having context-IDs instead of not having them? ",
          "createdAt": "2021-04-19T20:02:57Z",
          "updatedAt": "2021-04-19T20:02:57Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I think the second option \"Negotiate the presence of context IDs using an HTTP header\" is the best personally.\r\n\r\nIn terms of: \"Context IDs would still be mandatory to implement on servers because the client might send that header\", I assume server in this context is the final application server, not a proxy?  Even so, I'd argue it's applications which decide if they need this functionality, so if a server only implemented one application and it didn't use Context-IDs, then I don't see why it would need to implement it.",
          "createdAt": "2021-04-23T14:43:01Z",
          "updatedAt": "2021-04-23T14:43:01Z"
        },
        {
          "author": "achernya",
          "authorAssociation": "NONE",
          "body": "Ian, in your comment, are you talking about an intermediary when you say \"proxy\"? If so, then an intermediary need not implement anything based on the payload of than H3 DATAGRAM, it only has to pass the data along. That may be worth a clarification.",
          "createdAt": "2021-04-23T14:51:01Z",
          "updatedAt": "2021-04-23T14:51:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Having context ID optional has a nice future-proof property - other uses of datagrams in HTTP/3 can decide if they want the second layer or not. \r\n\r\nI wouldn't even state it as application needing multiplexing or not. Other applications might find it very useful to include a second ((third, fourth, fifth) layer of frame header. I think its fine for us to state as much in this in the spec, while also defining an explicit second layer for multiplexing.",
          "createdAt": "2021-04-23T14:58:42Z",
          "updatedAt": "2021-04-23T14:58:42Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "Yes, by proxy I meant intermediary.  And I agree about what intermediaries need to do, I just wanted to ensure I understood what server meant when David used it above.\r\n\r\nYup, whenever all this gets written up, we can make it clear that intermediaries can ignore much of this.",
          "createdAt": "2021-04-23T14:58:55Z",
          "updatedAt": "2021-04-23T14:58:55Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "The method defines the semantics of datagrams for a particular request, thus I think the third option makes most sense. I don't see a point in using explicit negotiation, since in the two cases I can think of the top of the head, the answer is always clear from the method (CONNECT-IP seems to always want context IDs, WebTransport does not ever want context IDs).  If some method starts out without context, but wants to add context later, it can add its own negotiation.",
          "createdAt": "2021-05-12T20:46:19Z",
          "updatedAt": "2021-05-12T20:46:19Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "One set of use cases for which the method approach(3) is best are those where there are multiple context IDs but they're predefined by the method and don't need negotiation.  My strawman is WebRTC.",
          "createdAt": "2021-05-12T21:36:30Z",
          "updatedAt": "2021-05-12T21:36:30Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU4NzAzMTgxMjE=",
      "title": "The spec should discuss how h3-datagram works(or does not) with priority",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/46",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I think it's be valuable for h3-datagram to be able to use the new HTTP priority draft.\r\n\r\nI think it'd be ok to say that the datagram flow has the same prioritization as the request that initiated it.  I don't think anything more complex is necessary, but I could be wrong.",
      "createdAt": "2021-04-28T20:09:30Z",
      "updatedAt": "2021-05-24T21:42:33Z",
      "closedAt": "2021-05-24T21:42:33Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems reasonable to me, assuming that we can get some implementations of this first. I suspect that we'll want this text to live in whichever gets published last between draft-ietf-masque-h3-datagram and [draft-ietf-httpbis-priority](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-priority).",
          "createdAt": "2021-04-28T20:13:35Z",
          "updatedAt": "2021-04-28T20:13:35Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "The extensible priorities draft doesn't prioritise streams, it prioritizes responses. Is it sufficient that only a client can control the relative priority of datagrams coming back to it?\r\n",
          "createdAt": "2021-04-28T20:28:33Z",
          "updatedAt": "2021-04-28T20:28:33Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "oh and FWIW as an editor on priorities, we are pretty close to a WGLC. If there's merit in saying something about datagrams and priorities, putting it here feels like the right thing.",
          "createdAt": "2021-04-28T20:31:21Z",
          "updatedAt": "2021-04-28T20:31:21Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "> The extensible priorities draft doesn't prioritise streams, it prioritizes responses. Is it sufficient that only a client can control the relative priority of datagrams coming back to it?\r\n\r\nGiven the client already has the ability to control the relative priority of datagrams its sending, I think that's ok?\r\n\r\nPossibly there are use cases where the server wants to indicate a priority to the client as well?\r\n\r\nMy strawman use case is tunneling multiple HTTP/3 connections: One goes to the origin, one goes to a static content server, ads, etc, and the client wants to receive data from the origin at a higher priority than the other data.",
          "createdAt": "2021-04-28T21:01:18Z",
          "updatedAt": "2021-04-28T21:01:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that is a good use case! I don't know if someone will turn around and say they really want to support that server control use case, I'm keen to hear strong proponents to really understand why.\r\n\r\nMaking DATAGRAM priority based on streams aids parity between CONNECT and CONNECT-UDP cases. \r\n\r\nTo your mind, would datagrams be prioritized against other datagrams and other streams? There's probably something to say here, especially the edge case where there is data to be sent non-incrementally on the stream AND the datagram flow.\r\n\r\nSomething to consider is also that if we go ahead with a 2-layer approach, whether we want to expose per-flow priorities. Maybe that can be done by carrying the extensible priority value as an extension field in the flow creation message. Although it does sound a bit too much complexity.\r\n",
          "createdAt": "2021-04-28T21:26:32Z",
          "updatedAt": "2021-04-28T21:26:32Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "\r\n> To your mind, would datagrams be prioritized against other datagrams and other streams? There's probably something to say here, especially the edge case where there is data to be sent non-incrementally on the stream AND the datagram flow.\r\n>\r\n\r\nYes, I would expect all datagrams and streams to be prioritized together.  If there's a response and it has associated datagrams, I'm not sure which would get precedence over one another, but if the assumption is that the response will be small, it probably makes sense to prioritize that?\r\n\r\n> Something to consider is also that if we go ahead with a 2-layer approach, whether we want to expose per-flow priorities. Maybe that can be done by carrying the extensible priority value as an extension field in the flow creation message. Although it does sound a bit too much complexity.\r\n\r\nI really hope we can avoid that, since it means the proxy/intermediary would have to deal with subflows, whereas currently it doesn't have to.  Also, for most of the subflow use cases I've heard, I don't think that would be valuable or necessary.",
          "createdAt": "2021-04-28T22:46:49Z",
          "updatedAt": "2021-04-28T22:46:49Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree about the context/subflows things. Lets avoid that.\r\n\r\nFor the bigger picture stuff I'd need to think on this some more. Perhaps a mildly flexible solution is to define an extensible priorities extension that would \r\n\r\n1) explain some of the considerations into scheduling relative priorities between streams and datagrams\r\n\r\n2) define a `dgram` parameter to allow explicit setting of datagram flow priority.  For example, to have an incremental stream at urgency 1 and incremental datagram at urgency 3\r\n\r\n```\r\npriority: u=1, i, dgram;u=3;i\r\n```\r\n\r\nWe could then state that omitting the `drgram` parameter means the stream's priority is used.\r\n\r\n3) by adding more params to `dgram` we could even support explicit signalling of the wish for shared priority space, or segregated.",
          "createdAt": "2021-04-28T23:08:23Z",
          "updatedAt": "2021-04-28T23:08:23Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd say that defining a new `dgram` prioritization parameter should be left to its own document, I'd prefer not to have this in h3-datagram itself",
          "createdAt": "2021-04-28T23:14:56Z",
          "updatedAt": "2021-04-28T23:14:56Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree its scope creep. I would be ok with this document saying very little and punting the problem to a `draft-ietf-httpbis-dgram-priorities` (which I would entertain co-writing)",
          "createdAt": "2021-04-28T23:26:37Z",
          "updatedAt": "2021-04-28T23:26:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I think defining priorities of sub-flows would be useful in Ian's use case if you wanted to merge the priorities of streams within the tunneled QUIC connections at the entry proxy, rather that strictly prioritize one tunnel over another.\r\n\r\nOne could do this by registering a context-ID for each priority level.  This context-ID could be used by the intermediary (did I break the rules again?) to determine the priority of the datagram back towards the client.",
          "createdAt": "2021-05-07T18:46:54Z",
          "updatedAt": "2021-05-07T18:46:54Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to propose closing this issue with no action, with the intent to leave this functionality to extensions. ",
          "createdAt": "2021-05-19T20:39:35Z",
          "updatedAt": "2021-05-19T20:39:35Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Adding text that says by default datagrams inherit the priority of the stream they are associated with seems likely to capture the most common cases.  If we can't agree on that and want to punt, it would be good to indicate in the draft that priority of datagrams is undefined/implementation specific.",
          "createdAt": "2021-05-19T20:51:31Z",
          "updatedAt": "2021-05-19T20:51:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll would be happy with Alan's suggestion. I will prepare a PR unless someone beats me too it.\r\n\r\nEdit: suggestion to state that it is undefined ",
          "createdAt": "2021-05-19T21:03:39Z",
          "updatedAt": "2021-05-19T21:04:21Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue stating that it is undefined sounds great to me.",
          "createdAt": "2021-05-19T21:12:40Z",
          "updatedAt": "2021-05-19T21:12:40Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I prefer it inherit the priority of the associated stream as @afrind suggested.",
          "createdAt": "2021-05-20T13:20:30Z",
          "updatedAt": "2021-05-20T13:20:30Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that sounds like an easy suggestion but in practice doesn't help implementers. Inheriting the same signal doesn't really help the multiplexing scheduling conundrum - IMO trying to make any reasonable suggestion will tie up time in this document development that could be answered elsewhere. ",
          "createdAt": "2021-05-20T13:25:42Z",
          "updatedAt": "2021-05-20T13:25:42Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "If I'm an intermediary l7 load balancer, and support h3-datagram but am not looking deeper into the payload, I'm going to have to make scheduling decisions, so leaving it undefined could cause large differences in how h3-datagram based applications work on different intermediaries.",
          "createdAt": "2021-05-20T13:54:16Z",
          "updatedAt": "2021-05-20T13:54:16Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Right but that's the situation the base HTTP/3 specification has right now too. \r\n\r\nAnd even if the L7 balancer applies scheduling logic based on the extensible priorities draft, \r\n\r\n1) it would need to decide how to schedule ingress data (request content) itself, since that is not defined \r\n2) we have little experience about how to schedule datagram and stream data concurrently. I would expect implementers to turn around immediately and ask us how to do that if we say explicitly here that there is a datagram priority signal.\r\n\r\nI am not saying we punt the question indefinately. But in the interest of making progress here (especially to limit feature creep) I am suggesting we write a standalone `draft-pardue-masque-h3-dgram-priorities` document that can capture all the concerns as completely as is useful. If that draft makes rapid progress it might be a candidate for getting incorporated back into the H3 datagram specification. I would be happy to bootstrap that document in a new repo and work with Alan, Ian or other folks that can give some opinions.",
          "createdAt": "2021-05-20T14:09:34Z",
          "updatedAt": "2021-05-20T14:09:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to @LPardue. The more I think about this the more I believe that H3DGRAM has to match what H3 does - in a vacuum as an implementor I don't know how to implement \"datagram should inherit priority of the corresponding stream\" when no one has actually defined what a priority is. There are important questions like \"should higher priority completely starve lower priority or not?\" that are not answered by H3. H3DGRAM itself cannot depend on a given priorities extension, because we might define a different priorities scheme later. Having a separate draft that explains how to combine draft-ietf-masque-h3-datagram and draft-ietf-httpbis-priority sounds like the best option.",
          "createdAt": "2021-05-20T15:31:46Z",
          "updatedAt": "2021-05-20T15:31:46Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU4NzM5ODk1OTI=",
      "title": "Can HTTP server push use h3-datagram?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/47",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I would prefer that h3-datagram cannot use server push, because I believe it adds extra complexity and there are no clear use cases.\r\n\r\nAdditionally, server push is an optimization which allows a server to push a resource up to 1RTT prior to the client's (expected) requests for the resource.  h3-datagram is much more analogous to a CONNECT, which is neither idempotent or cacheable, so I'd assume a client would drop any received datagrams, rendering the optimization useless.\r\n\r\nWhatever we decide, we should definitely clarify this.  This issue was motivated by https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/42#issuecomment-827750984\r\n",
      "createdAt": "2021-05-02T16:52:08Z",
      "updatedAt": "2021-11-09T17:53:57Z",
      "closedAt": "2021-05-19T20:41:24Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "+1\r\n\r\nI think it would be OK to restrict this H3 DGRAM extension to only permit top-level flow creation by the client. This gels well with HTTP semantics - today there isn't a way for a server to spontaneously start sending things not associated with an HTTP request. Even server push needs the \"parent request\" (unless you try to do something like my unbound server push extension, which no one seemed interested in).\r\n\r\nIn a two layer model, there might be use cases that benefit from sever-initated second-level flows. But they can hang off the client request stream, not try to tack on to server push.\r\n\r\nFinally, descoping server push means that support over multiple proxies becomes much easier to reason about.\r\n\r\n",
          "createdAt": "2021-05-02T17:44:44Z",
          "updatedAt": "2021-05-02T17:44:44Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "Thanks @LPardue I forgot to mention that server push via multiple layers of proxies(ie: CDNs) has proven fairly impossible in practice, and h3-datagram is intended as an end-to-end protocol I believe.",
          "createdAt": "2021-05-02T17:54:25Z",
          "updatedAt": "2021-05-02T17:54:25Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "The use-case I could see for push leveraging datagram is if the server wanted a mechanism to deliver the body of the pushed resource in an unreliable way, but the same could most likely be accomplished by hanging the datagrams off the associated stream of the push.  \r\n\r\n> server push via multiple layers of proxies(ie: CDNs) has proven fairly impossible in practice\r\n\r\nReally?  We've delivered pushes through multiple layers of proxies.  It's not going to be that different for WebTransport streams to traverse proxies.",
          "createdAt": "2021-05-03T15:24:58Z",
          "updatedAt": "2021-05-03T15:24:58Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I think there are better ways to send unreliable bodies than unreliable datagrams.\r\n\r\nI agree that in some homogeneous environments, multi-layer pushes are practical, but in the general case I don't think they are.  Apple's low latency HLS abandoned push fairly early on for that reason.",
          "createdAt": "2021-05-03T15:37:52Z",
          "updatedAt": "2021-05-03T15:37:52Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that #52 has been merged, datagrams are now associated with request streams. That doesn't preclude push from using datagrams, because push is also associated with a request stream, but it does mean that datagrams are not directly linked to push streams.",
          "createdAt": "2021-05-19T20:41:24Z",
          "updatedAt": "2021-05-19T20:41:24Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi maybe I am missing aspects of push, but I thought for push to work, you would have the push_promise frame from the server, which is not associated with a client HTTP request yet, and thus can't have HTTP Datagram. First when the client request the data that might be pushed will there be an actual HTTP request which could enable HTTP Datagram. \r\n\r\nThus, from my perspective HTTP Push is not compatible with HTTP Datagram as currently defined. That is likely fine, but maybe these limitations should be clearly be noted. ",
          "createdAt": "2021-11-09T17:37:24Z",
          "updatedAt": "2021-11-09T17:37:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "PUSH_PROMISE are always sent on request streams, they can only be issued by a server after a client has sent a request. The machinery across H2 and H3 is different for actually pushing but the promise aspect is similar. \r\n\r\nServer push is just weird and support for it is really poor across implementations. I am not in favour of spending effort on talking about server push when we don't support it by our design.",
          "createdAt": "2021-11-09T17:43:45Z",
          "updatedAt": "2021-11-09T17:43:59Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I have no interest in supporting Push. I think it comes down if one should note significant limitations in the specification?",
          "createdAt": "2021-11-09T17:51:16Z",
          "updatedAt": "2021-11-09T17:51:16Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Since Server Push is the odd thing in HTTP land, I don't believe we need to give it any special mention. That's a pattern we follow in the HTTP WG.",
          "createdAt": "2021-11-09T17:53:57Z",
          "updatedAt": "2021-11-09T17:53:57Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU4NzY4MzExNzk=",
      "title": "Do context ID closures need more details?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/53",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #52, we introduce the CLOSE_DATAGRAM_CONTEXT capsule which allows endpoints to close a context. That message currently only contains the context ID to close. @bemasc suggests that we may want to add more information there.\r\n* Should we differentiate between \"context close\" and \"context registration rejected\"?\r\n* Should we add an error code?\r\n\r\nIn particular, do folks have use cases for these features?",
      "createdAt": "2021-05-05T21:01:30Z",
      "updatedAt": "2021-05-26T20:32:50Z",
      "closedAt": "2021-05-26T20:32:50Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "My first concern is with infinite loops.  If the context was \"garbage collected\" by the recipient, the sender can simply re-create it if they still want it.  However, if it was closed due to incompatibility (i.e. rejected) or hitting a resource limit (e.g. max # of contexts), reopening it in response will produce a tight infinite loop.\r\n\r\nThis could be maybe be avoided by some kind of heuristic, but an explicit indication of what's going on seems better.",
          "createdAt": "2021-05-05T21:14:07Z",
          "updatedAt": "2021-05-05T21:14:07Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU4Nzc2OTY3OTQ=",
      "title": "Can intermediaries interact with capsules, contexts and context IDs?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/54",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #52, capsules, contexts and context IDs are explicitly defined as end-to-end and there are requirements for intermediaries to not modify them, and to not even parse them. The motivation for this was to ensure that we retain the ability to deploy extensions end-to-end without having to modify intermediaries. @afrind mentioned that these requirements might be too strict, as he would like to have his intermediary be able to parse the context ID, for logging purposes.",
      "createdAt": "2021-05-06T16:24:48Z",
      "updatedAt": "2021-05-24T22:08:28Z",
      "closedAt": "2021-05-24T22:08:28Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Part of the comment from the PR is also about consistency of interface for generic HTTP libraries that can be used to build either endpoints or intermediaries.  If the context ID is always present, it's overly prescriptive to say that an intermediary can't parse it, and such a requirement couldn't be enforced anyways.\r\n\r\nIf context IDs are negotiated on/off, whether this is possible depends on the negotiation mechanism.",
          "createdAt": "2021-05-06T20:09:08Z",
          "updatedAt": "2021-05-06T20:09:08Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I think its fine for a component that has bytes passing through it to look at those bytes. The import thing to do is set expectations on what that means for the protocol behaviour we are defining. We don't expect intermediaries to do anything with a context ID; they should not enforce the protocol semantic rules (odd, even, reuse etc).\r\n\r\nH2 and H3 somewhat solve this problem by decoupling frame parsing from frame payload interpretation. E.g. if the form of a request or response is invalid, an intermediary shouldn't pass it on. \r\n\r\nDATAGRAM is different because it isn't defined as an actual HTTP/3 frame with frame headers and frame payload. Something that might work is to formalise that quarter stream ID is part of the envelope that intermediaries have to be able to handle the syntax of, but context ID is part of content and separate. ",
          "createdAt": "2021-05-06T20:31:21Z",
          "updatedAt": "2021-05-06T20:31:21Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "Unless you encrypt capsules end-to-end, I don't think any text in the spec can in practice prevent intermediaries from inspecting and modifying capsules.  You can send something like GREASE capsules, though.",
          "createdAt": "2021-05-13T14:02:45Z",
          "updatedAt": "2021-05-13T14:02:45Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU5NDMzMDk1NzE=",
      "title": "MTU handling",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/65",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This has been sent to the MASQUE WG mailing list in hopes to get some discussion there. However, I want an issue that tracks this: \r\n\r\nIn the work of writing up our Connect-IP proposal (https://datatracker.ietf.org/doc/draft-kuehlewind-masque-connect-ip/) we looked into how to deal with MTU issues effectively. Our conclusion was that this is going to be a general problem for any user of HTTP Datagrams. Thus, we like to propose that MTU handling is done within HTTP datagram. \r\n\r\nThis email will start explaining what we see as requirements for a MTU signaling solution for HTTP datagram, then propose a potential solution. \r\n\r\n\r\nLets start with a figure that provides us with a framework to discuss the requirements:\r\n\r\n```\r\n+--------+ Path#1A +--------+        +-------+        +--------+\r\n|Client A|<------->| HTTP   | Path#2 | MASQUE| Path#3 |        |\r\n+--------+         | Inter- |<------>| Server|<------>| Target |\r\n+--------+ Path#1B | mediary|        |(proxy)|        |        |\r\n|Client B|<------->|        |        |       |        |        |\r\n+--------+         +--------+        +-------+        +--------+\r\n```\r\n\r\n\r\nI think what makes this a bit more complex is the fact that we need to consider HTTP intermediaries, such as a front end load balancer that terminates a first QUIC and HTTP/3 connection between the client and that intermediary. From that intermediary another HTTP connection is used towards the HTTP server that consumes and produces the HTTP datagrams, and in the case of CONNECT-UDP and CONNECT-IP it also have a third path towards the target to consider. This figure includes two clients to remind us to consider that the HTTP intermediary may actually aggregate the HTTP request and response and HTTP datagram over one HTTP/2 or HTTP/3 connection over Path #2. In the case of MTU this complicates things more as the proxy cant assume that all HTTP requests have the same MTU for its datagrams on a HTTP/3 connection. And the Intermediary will be the entity that have direct knowledge of the client facing as well as the next hop MTU over the HTTP connections that may all differ in MTU. \r\n\r\nWe also have to consider the fact that the underlying transport connection may at any time be subject to a IP MTU change due to route change for the path between the nodes. In addition if one have enabled PMTUD in TCP or QUIC a larger MTU on the individual path could be made available and in some case desirable to use. Thus, we need to consider dynamic changes during the HTTP connections life time and each HTTP request response pairs usage of HTTP datagram. \r\n\r\nSo when using HTTP/3 datagram there are a strict MTU limit on the individual datagrams for it to be possible to be sent as QUIC datagrams, and not being forced to be encapsulated as CAPSULES over the reliable stream. This is clearly a possibility but results in that the datagrams are sent reliable and in order for each HTTP request, i.e. Connect-UDP or CONNECT-IP request. Also in case some end-to-end payloads fit in HTTP datagrams and others don\u2019t there is potential for reordering among the payloads. Thus, to avoid this the client and the proxy needs to determine what the lowest currently supported HTTP datagram size on the path. \r\n\r\nFor each QUIC connection the end point will know what the initial MTU value is for this path when the HTTP/3 connection has been successful completed. However, that knowledge will not be available if one attempt to construct and send the HTTP request prior to connection establishment has concluded.\r\n\r\nSo the requirements we see for an MTU handling solution for HTTP Datagrams are the following.\r\n\r\n1)\tHop-by-hop signaling across the HTTP entities of the lowest MTU of any sub-path\r\n2)\tNeeds to be associated to a particular HTTP request or end-to-end path to support aggregation by HTTP intermediaries\r\n3)\tEndpoints needs to be able to initiate update of the MTU value upon detection of any changes during HTTP Datagram streams lifetime.\r\n4)\tHTTP Intermediaries needs to be able to initiate updates of the MTU value upon detecting MTU changes from the individual HTTP connections.\r\n\r\nSolution proposal\r\n==============\r\n\r\nA new HTTP Datagram Capsule is defined for MTU value exchange. This one is intended for the HTTP intermediary that needs to interpret, update or initiate sending of it. Thus, it needs to be a fixed registered type so it can be easily processed. It can also be exchanged in parallel to the Register_Datagram_* capsules as at that point the underlying HTTP connection is established and initial HTTP Datagram values will be known. A capsule will also travel all the way to the end. And an intermediary can initiate one in each direction for request paths. The only downside I see of this is that one is required per open stream when MTU changes occurs. Maybe someone have an idea of how to handle signaling when aggregating multiple endpoints streams onto one HTTP/3 connection. \r\n\r\nTo make it more efficient, rather than sending one MTU capsule per stream, an MTU capsule could list all streams it is applicable to. That way the number of MTU capsules would be no more than the number of end-to-end paths actually used. \r\n\r\n",
      "createdAt": "2021-07-13T12:38:22Z",
      "updatedAt": "2021-10-05T23:51:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @gloinul thanks for proposing this work item. From reading your problem statement and proposal, this will require non-trivial amounts of complexity. Resolving that will take time. I don't see a reason to delay the HTTP Datagrams draft because of this, so I'd suggest building this as an extension to HTTP Datagrams. I think this would even be a great way to test out our new extensibility mechanism! Can you write this up as a separate draft please?",
          "createdAt": "2021-07-13T16:24:24Z",
          "updatedAt": "2021-07-13T16:24:24Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "Yes, it is non-trivial. However, I think we need to settle if we have a day one need for this mechanism to ensure that CONNECT-UDP actually can work properly and handle QUIC in QUIC when the outer tunnel uses minimal QUIC packets. Similarly we have a need for CONNECT-IP to handle IPv6 minimal packet size. So I think we need to discuss if this needs to be solved.\r\n\r\nBut, yes I am willing to write this up in spec form, but I was more thinking of a PR to the HTTP-DATAGRAM draft.",
          "createdAt": "2021-07-14T07:54:10Z",
          "updatedAt": "2021-07-14T07:54:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see a day one need here that isn't addressed by [Ben's proposal](https://mailarchive.ietf.org/arch/msg/masque/7KJiS6bznHSlCqz1q8HTXoAk0to/). Given the current text, CONNECT-UDP (and -IP) endpoints can detect datagram blackholing and switch to capsules.",
          "createdAt": "2021-07-14T15:25:02Z",
          "updatedAt": "2021-07-14T15:25:02Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "I don't understand the following statement \"CONNECT-UDP (and -IP) endpoints can detect datagram blackholing and switch to capsules.\" I don't believe that is true in scenarios with HTTP Intermediaries as the MASQUE endpoint in those case lacks visibility of the dropping of the HTTP Datagram, unless additional signals are added. But, I would also prefer that we discuss this on the mailing list. I just think closing the issue was premature. ",
          "createdAt": "2021-07-16T07:57:20Z",
          "updatedAt": "2021-07-16T07:57:20Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "You don't need an explicit signal to know that a packet was dropped, you can infer that through lack of acknowledgements. Since there aren't acknowledgements at the datagram layer itself, you'd need to partner with the transport protocol running over CONNECT-UDP or CONNECT-IP to get that signal. That isn't trivial, but if we transparently solve this at the datagram layer (let's say we add a \"datagram too big\" capsule and then have the datagram layer use it to switch to reliable capsules for example) then you'd end up with terrible performance because in most scenarios you'd be much better off with the higher level transport protocol using a smaller MSS that fits in datagrams. So all this to say: this isn't an easy problem to solve, and having an explicit signal isn't a silver bullet that solves it easily. Since we need to involve the higher layers, then we have many options to pick from, and not all of them require an explicit signal.",
          "createdAt": "2021-07-16T16:43:54Z",
          "updatedAt": "2021-07-16T16:43:54Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "Agree that for sufficiently large MTU you want the end-to-end PMTUD to work and dropping will be necessary. However, we are going to have requirements on minimal packet sizes, that is where we end up in needing a signal. In addition if the tunnel HTTP Datagram ingress knows the MTU, then for the MASQUE use cases it can send back the appropriate signal towards an remote IP point or through the API to the application using MASQUE. If an HTTP intermediary simply drop packets that are to large and send no signal back. Then the HTTP datagram ingress has no knowledge and no type of signal intended to speed up PMTUD is also sent. Which, makes results us from potentially breaking the IPv6 specification requirements in two ways when using it for CONNECT-IP. \r\n\r\nFirst we may not support the required datagram size of 1280 bytes.\r\nSecondly, we are not supporting the IPv6 PMTUD model of actually sending ICMPv6 PTBs. Yes, this may not work as well as it should, but it is still required functionality. \r\n",
          "createdAt": "2021-07-19T07:09:26Z",
          "updatedAt": "2021-07-19T07:09:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds like a good use case for [draft-schwartz-masque-h3-datagram-ping](https://datatracker.ietf.org/doc/draft-schwartz-masque-h3-datagram-ping/). It's a great example of a context ID extensions that can benefit multiple methods. As long as draft-ietf-masque-h3-datagram is extensible enough to allow this kind of extension, I don't think we need to solve this in draft-ietf-masque-h3-datagram.",
          "createdAt": "2021-10-05T23:51:13Z",
          "updatedAt": "2021-10-05T23:51:13Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU5NDM1Mjc1OTc=",
      "title": "How to actually use the Context ID registrations mechanism",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/66",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Sent to the WG mailing list. \r\n\r\nI and my co-authors on https://datatracker.ietf.org/doc/draft-kuehlewind-masque-connect-ip/ have had some discussion around how one actually can and should be using the context-ID registration mechanism. This as we are actually need it to realize some of the functionality in our CONNECT-IP solution. \r\n\r\nWe have found several ways that appear to practically work from an CONNECT-IP application perspective. \r\n\r\nA)\tStatically define that in the context of CONNECT-IP the application will map certain formats to certain ContextID, and simply send registrations without any extension headers. \r\nB)\tDefine a Context Extension that is intended to provide format identifiers for the CONNECT-IP method different formats. \r\nC)\tUse values or parameters in HTTP headers related to the format to carry the identifiers.\r\nD)\tCombine A and B, so that we have a set of initially statically defined mappings, and then use Context Extension for any future extensions. \r\n\r\nIn our discussion we see that C appears to have some potential for failure modes if an HTTP intermediary does things with the headers. \r\n\r\nA) is very straight forward for an application initially but can run into trouble when needing to be extended but HTTP level negotiation of the general functionality should resolve those. \r\n\r\nB) appears to have some overhead from an application perspective as each application needs to define its own Context Extension to carry identifiers. Is it really intended that each HTTP application that needs to convey some identifier for its Context ID format to carry across the HTTP Datagram capsule. Would there be a point in defining a Context Extension that carries format identifier for what one like to use this context ID. \r\n\r\nD) appears to be simple initially, but leads to the extension mechanism having code paths that would not be exercised by default\r\n\r\nSo this was basically to start a discussion to see if we can get a bit more clearer guidance towards the HTTP application writers that will attempt to use HTTP Datagram on how to actually use Context IDs. I noted that the Connect-UDP method was no help as example yet.\r\n\r\n",
      "createdAt": "2021-07-13T15:08:52Z",
      "updatedAt": "2021-09-21T00:30:34Z",
      "closedAt": "2021-09-21T00:30:34Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for writing this up @gloinul. Using your nomenclature, the draft is currently written with the intent of using (B). That allows maximal extensibility while ensuring that the extension codepath is well used. The overhead of registering a 62bit integer seems negligible to me - since each application needs to define its payload format somewhere, defining its negotiation format and registering an integer alongside seems easy. Can you think of any use cases that are not well served by (B)?",
          "createdAt": "2021-07-13T16:12:02Z",
          "updatedAt": "2021-07-13T16:12:02Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "Thanks for clarifying your thoughts on what you had intended. And I don't think there are any question if will serve the application. However, as there where no actually defined usage yet we where a bit uncertain of the intention here. \r\n\r\nI would note that each standardized application registering its own extension, will cause another IANA registry for the format values. But it clearly have a benefit from being a forensic perspective, as each application will be ID by its extension type, and then its value. \r\n",
          "createdAt": "2021-07-14T08:00:24Z",
          "updatedAt": "2021-07-14T08:00:24Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you clarify your note? The document currently sets up the \"HTTP Context Extension Types\" IANA registry. What other IANA registry did you have in mind? Formats don't need a registry. To make an analogy, we have an IANA registry for UDP port numbers but no IANA registry for the format of UDP payloads, as those are defined by specifications not registries.",
          "createdAt": "2021-07-14T15:57:14Z",
          "updatedAt": "2021-07-14T15:57:14Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "So, lets take CONNECT-IP as an example. It will define and register a Context Extension Type for Connect-IP context IDs. \r\n\r\nIn our current draft for Connect-IP we currently have 4 different formats that will need to be expressed by context ID registrations. We also have the ideas of at least one more to carry ECN. So the current specification will define what the first 4 values do. Then if we define the ECN one as a separate specification as additional extensions of CONNECT-IP formats. Thus we are in a situation where we need additional context-IDs identifiers, then the right thing to ensure that the format to value mapping is well managed is to create a new IANA registry for CONNECT-IP Context Extension Format to value mapping. ",
          "createdAt": "2021-07-15T08:24:28Z",
          "updatedAt": "2021-07-15T08:24:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I follow. You can have solve this by registering two Context Extension Types:\r\n- one for the draft-kuehlewind-masque-connect-ip format which has the four values from that draft\r\n- one for ECN which has four values Not-ECT/ECT(0)/ECT(1)/CE\r\n\r\nand then you compose the results (by which I mean you can send multiple extensions in one REGISTER_DATAGRAM_CONTEXT capsule). I don't see how a separate registry helps?",
          "createdAt": "2021-07-15T16:26:50Z",
          "updatedAt": "2021-07-15T16:26:50Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU5NDM1Mjk4Mjk=",
      "title": "Should there be a way to mass-register multiple context IDs?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/67",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It appears that the current defined registration method is great when one have three formats and need three different context ID for the three different formats. It is not suitable if one end up in any combinatorial cases, like formats that combine different modules where one may suddenly have 128 potential different context IDs. Pre-registering all of them appears to create a significant overhead. We had some thoughts of actually carrying the DSCP + ECN values for an IP packet payload in the Context ID. That could require up to 256 Context IDs. And registering each value individually could be done, but ends up in a large number of registrations, likely with a Context Extension TLV that consumes additionally overhead. \r\n\r\nSo is there a need for mass registration of context IDs?",
      "createdAt": "2021-07-13T15:10:29Z",
      "updatedAt": "2021-10-05T16:31:52Z",
      "closedAt": "2021-10-05T16:31:52Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "If you need to carry 8 bits, then I think the simplest solution is to register a single context whose format contains those 8 bits at the start of the`HTTP Datagram Payload`? Since the context ID is encoded as a variable-length integer, these two encodings have the same amount of wire overhead. Can you think of any use cases that would be better solved by \"mass registration\"?",
          "createdAt": "2021-07-13T16:01:07Z",
          "updatedAt": "2021-07-13T16:01:07Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "The issue I saw was that if you need lets say the equivalent of 4 bits, then you can either register 16 contexts for a Datagram overhead of 1 bytes if you had no prior need for context IDs. If you want to go from one format to two and also are adding a front byte then you consume 2 bytes, one for the context ID you didn't need before, and one byte to carry the actual value. With the context ID's variable encoding and only half of the values can be initiated by the endpoint the limit for keeping the context ID within one byte is anyway no more than 5 bits worth of values anyway. \r\n\r\nHowever, I think the later is the cleaner solution and likely the one we should go with. For our Connect-IP proposal it looks like we will have context IDs anyway for our flow forwarding mode. \r\n\r\nBut this was a question to ask openly as we had this thoughts and maybe others have even stronger aversion for overhead to carry a couple of bits and thus may want to encoded it in the context ID. But if not anyone else has strong need, then I don't think we really need any mass registration mechanism.",
          "createdAt": "2021-07-14T07:48:43Z",
          "updatedAt": "2021-07-14T07:48:43Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, that makes sense. Let's leave this open for some time to see if anyone has use cases or other thoughts.",
          "createdAt": "2021-07-14T15:52:33Z",
          "updatedAt": "2021-07-14T15:52:33Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From a parsing standpoint, the first thing you need to know is whether datagrams contain a context ID or not, so there's obviously value in context/no-context.\r\n\r\nNext, you need to be able to map a particular context to a purpose.  That _might_ be done with Context Extensions, in which case there's value in declaring them.  But it might also be done in HTTP headers, in which case the registration of a particular context before use might be unnecessary.  (Obviously you'll still need to register locally with your HTTP implementation which contexts you should receive the datagrams for once you read the headers.)\r\n\r\nContext Extensions feel more useful in declaring parameters for a particular purpose -- but if that's how they're used, I don't see the point of the global registry.  Each purpose is essentially defining a custom datagram protocol at that point and can define what the parameters in the Extensions mean for that purpose.",
          "createdAt": "2021-07-21T20:26:32Z",
          "updatedAt": "2021-07-21T20:26:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "We haven't seen more use-cases for a context mass registration system, so I'm closing this issue for now. We can reopen it if use-cases arise.",
          "createdAt": "2021-10-05T16:31:52Z",
          "updatedAt": "2021-10-05T16:31:52Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU5NDM5NzQxNDM=",
      "title": "Merge REGISTER_DATAGRAM_CONTEXT and REGISTER_DATAGRAM_NO_CONTEXT capsules",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/68",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There are two possible ways to encode REGISTER_DATAGRAM capsule: using two different capsules (current variant), or using a single capsule with a field indicating whether the context is present.  While those two are largely isomorphic, I feel like the latter would help us avoid situations where libraries or intermediaries only support one but not the other.",
      "createdAt": "2021-07-14T02:26:19Z",
      "updatedAt": "2021-10-05T16:32:48Z",
      "closedAt": "2021-10-05T16:32:48Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "To address one point, I had the expectation that the capsule types in this document would be base level and all implementations would support them. Maybe we have different expectations. \r\n\r\nTo address the more technical point, what would a merged capsule look like? In H3, we don't have a flags section for frames to signals similar but unique variants. The HTTP/3 PRIORITY_UPDATE frame in Extensible Priorities started by encoding optionality as a 1 byte field in the frame. Due to feed back we switched to using different frame code points, a bit like how QUIC DATAGRAMS also work. Since we already have two frame code points for context registration, it doesn't seem like we are too far off how other parts of the stack already do things.",
          "createdAt": "2021-07-14T02:55:14Z",
          "updatedAt": "2021-07-14T02:56:34Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, it's entirely equivalent to say there's a one-bit flag in the capsule type indicating whether (0x0) the Context ID is absent and the stream will not use Context IDs, or (0x01) the Context ID field is present.  I don't feel like there needs to be a wire format difference here, and how we spell it in the draft is purely editorial.",
          "createdAt": "2021-07-22T21:16:32Z",
          "updatedAt": "2021-07-22T21:16:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Since this is purely editorial, I'm going to close with no action for now. We can reopen if we have more information.",
          "createdAt": "2021-10-05T16:32:48Z",
          "updatedAt": "2021-10-05T16:32:48Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "MDU6SXNzdWU5NDgxNzE0ODI=",
      "title": "Make Capsule Frame before Headers an H3_FRAME_UNEXPECTED connection error",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/73",
      "state": "CLOSED",
      "author": "lnicco",
      "authorAssociation": "NONE",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "The HTTP/3 RFC states \r\n> Receipt of an invalid sequence of frames MUST be treated \r\n> as a connection error of type H3_FRAME_UNEXPECTED;\r\n\r\nThe current draft instead recommends closing the stream rather than the connection and with the generic H3_GENERAL_PROTOCOL_ERROR\r\n\r\nAccording to https://datatracker.ietf.org/doc/html/draft-ietf-quic-http-34#section-8.1 H3_GENERAL_PROTOCOL_ERROR is to be used when a more specific error code isn't available, but here we have clearly a more specific error available.\r\n\r\nAlso, what is the rationale for closing just the stream and not the whole connection?\r\n\r\nFurthermore, a more general question:\r\nright now the above recommendation only exists for REGISTER_DATAGRAM_NO_CONTEXT and REGISTER_DATAGRAM_CONTEXT capsule types. Would it be fair to say that no Capsule frame is allowed before headers instead?",
      "createdAt": "2021-07-20T01:55:33Z",
      "updatedAt": "2021-07-22T14:52:58Z",
      "closedAt": "2021-07-22T14:52:58Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks.\r\n\r\nI think it would be for us to clarify\r\n\r\na) strict ordering rules of capsule amongst HTTP message frames.\r\nb) strict ordering rules of capsule types.\r\n\r\nFor (a), I'm inclined to state a top-level requirement that CAPSULE frames MUST NOT arrive before the first HEADERS on a request stream. Violation of that is connection error of type H3_FRAME_UNEXPECTED. \r\n\r\nFor (b), I'm slightly less sure. We clearly have some ordering requirements. The H3 base spec treats misordering as a critical failure. We treat it here as a stream error. I think we could make things more similar to H3. For instance, I can't think of a good reason right now why we are so loose with handling of datagram capsules; if they arrive on a stream before a register capsule, that smells broken. ",
          "createdAt": "2021-07-20T05:32:54Z",
          "updatedAt": "2021-07-20T05:32:54Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Banning all capsules before headers sounds reasonable to me.\r\n\r\nStrict ordering of capsules is required on the sender, but enforcing that on the receiver isn't always easy so I don't think we can mandate it.\r\n\r\nI honestly don't care if it's a stream or connection error, either works for me.",
          "createdAt": "2021-07-20T18:39:07Z",
          "updatedAt": "2021-07-20T18:39:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Happy to write the PR for this. Right now I'm thinking we cam make (b) a more specific error code too. I think H3_FRAME_UNEXPECTED is good enough for capsule types but we could always define a H3_CAPSULE _UNEXPECTED is people felt strongly.",
          "createdAt": "2021-07-20T18:42:49Z",
          "updatedAt": "2021-07-20T18:42:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you have an example of where (b) is useful? In other words, what's a sequence of events that leads a receiver to detect a capsule illegal ordering?",
          "createdAt": "2021-07-20T18:46:49Z",
          "updatedAt": "2021-07-20T18:46:49Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "The following sequence is legal by (a) but illegal by (b)\r\n\r\n1. Client HEADERS\r\n1. Server HEADERS, \r\n1. Server CAPSULE (register_datagram_context)\r\n\r\nSo is this sequence\r\n\r\n1. Client HEADERS\r\n1. Client CAPSULE (register_datagram_no_context)\r\n1. Client CAPSULE (register_datagram_no_context)\r\n\r\nFrom what the spec says, I'm less clear on if this sequence is illegal\r\n\r\n1. Client HEADERS\r\n1. Client CAPSULE (datagram)\r\n1. Client CAPSULE (register_datagram_no_context)\r\n\r\nThere's a lot of text about DATAGRAM frames and ordering. But when sending Datagram capsules on streams, they can be strictly ordered on sender and receiver. H3 treats such ordering as specific problem because it is avoidable.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-07-20T19:02:31Z",
          "updatedAt": "2021-07-20T19:02:31Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "That last sequence probably can't be illegal, since it is possible when forwarding through an intermediary with and without datagram support.  Eg: Client <-> Intermediary supports native datagram and Intermediary <-> Server only supports datagram CAPSULE.  Since the intermediary only needs to forward and not inspect, the datagram CAPSULE can arrive before the register_datagram_no_context CAPSULE.",
          "createdAt": "2021-07-20T19:56:19Z",
          "updatedAt": "2021-07-20T19:56:19Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "That's what I thought initially, but the spec presently says\r\n\r\n> due to reordering, an endpoint that receives a DATAGRAM frame before receiving either a REGISTER_DATAGRAM_CONTEXT capsule or a REGISTER_DATAGRAM_NO_CONTEXT capsule MUST NOT treat it as an error, it SHALL instead drop the DATAGRAM frame silently, or buffer it temporarily while awaiting a REGISTER_DATAGRAM_NO_CONTEXT capsule or the corresponding REGISTER_DATAGRAM_CONTEXT capsule\r\n\r\nBy my read, an intermediary that receives a DATAGRAM frame and wants to convert it to a capsule needs to wait for the register capsule. ",
          "createdAt": "2021-07-20T21:37:37Z",
          "updatedAt": "2021-07-20T21:37:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "The spec doesn't define endpoint.  Is an intermediary an endpoint?",
          "createdAt": "2021-07-20T21:57:39Z",
          "updatedAt": "2021-07-20T21:57:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Need to nail that down. Having different sending rules for clients and \"intermediary doing client behaviour\" is a recipe for illness, the server can't know what the sender thinks it is.",
          "createdAt": "2021-07-20T22:22:09Z",
          "updatedAt": "2021-07-20T22:22:09Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "An endpoint is the opposite of an intermediary. If that's not obvious then we should spell it out in the draft. Intermediaries do not parse register capsules.",
          "createdAt": "2021-07-20T22:25:07Z",
          "updatedAt": "2021-07-20T22:25:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the parsing stuff is clear. What's a bit unclear is the message forwarding requirements. The HTTP definition [1] of intermediary allows some variance. In the gateway case, it's stated that\r\n\r\n>  an HTTP-to-HTTP gateway that wishes to interoperate with\r\n   third-party HTTP servers needs to conform to user agent requirements\r\n   on the gateway's inbound connection.\r\n\r\nAllowing deviation is permitted but might cause interop problems.\r\n\r\n[1] - https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-semantics-16#section-3.7",
          "createdAt": "2021-07-20T22:43:22Z",
          "updatedAt": "2021-07-20T22:43:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure what you're suggesting in terms of changes to the draft @LPardue, could you elaborate?",
          "createdAt": "2021-07-20T23:07:41Z",
          "updatedAt": "2021-07-20T23:07:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "The specific suggestion in this case is, disallow intermediaries from sending datagram capsules before register capsules. This might make Alan sad because an intermediary would need to buffer DATAGRAM frames and only forward them as capsules once a register is seen. Note that it would not require the intermediary to act on the register capsule, just enforce sequencing rules between datagrams and streams ",
          "createdAt": "2021-07-20T23:19:38Z",
          "updatedAt": "2021-07-20T23:20:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd rather we didn't add that suggestion. It increases complexity for intermediaries and I'm not sure what problem it solves?",
          "createdAt": "2021-07-20T23:55:41Z",
          "updatedAt": "2021-07-20T23:55:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "That's fine. I'd be happy with not adding that. However, to make it clear what the spec is allowing, we should make a note in Section 4.4 that the ordering/buffering requirements of DATGRAM frames and register capsules (from sec 3) do not apply to intermediaries when forwarding. That's tangential to Luca's OP so we can spin it off separately. ",
          "createdAt": "2021-07-21T00:22:43Z",
          "updatedAt": "2021-07-21T00:22:43Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, that sounds like a good resolution. Can you file an issue please?",
          "createdAt": "2021-07-21T00:54:37Z",
          "updatedAt": "2021-07-21T00:54:37Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU5NDkwMDE0MDk=",
      "title": "Datagrams with Unidirectional Streams",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/74",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In #47, the conclusion was that server push didn't have a need to use datagrams, and I'm fine with that decision.  However, it's a subset of a larger question.\r\n\r\nI'm slightly concerned that using the \"quarter stream ID\" as the namespace forecloses the use of datagrams associated to anything except a request.  For example, we discussed during HTTP/3 development that it might be reasonable to shift certain control frames to datagrams if that had been an option in the protocol.\r\n\r\nI don't see that the quarter ID buys us anything beyond saving a byte or four in certain ranges of stream IDs, and it introduces an element in the protocol where we're presenting the Stream ID in a different format than every other instance.  It forecloses options that we might find a use for in the future, even if it's not required for CONNECT-UDP.\r\n\r\nWhy not simply use the stream ID, like everywhere else, and keep the same rules about the stream needing to be open for sending?  Where currently we say client, we could equally refer to stream initiators.",
      "createdAt": "2021-07-20T19:30:11Z",
      "updatedAt": "2021-10-05T23:44:10Z",
      "closedAt": "2021-10-05T23:44:09Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you have an example of a use case that would benefit from associating a datagram with a non-client-initiated-bidirectional-stream?\r\n\r\nI'll note that the quarter stream ID doesn't foreclose much because since these new use cases will require their own setting so we'll have the option of adjusting the encoding based on the presence of that setting",
          "createdAt": "2021-07-20T21:21:39Z",
          "updatedAt": "2021-07-20T21:21:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing due to lack of activity. Datagrams are end-to-end and unidirectional streams are hop-by-hop. Let's reopen if we find a use case for this.",
          "createdAt": "2021-10-05T23:44:09Z",
          "updatedAt": "2021-10-05T23:44:09Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWU5NDk1ODg0NDA=",
      "title": "Note that the buffering requirements of DATGRAM frames do not apply to intermediaries",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/75",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "...make it clear what the spec is allowing, we should make a note in Section 4.4 that the ordering/buffering requirements of DATGRAM frames and register capsules (from sec 3) do not apply to intermediaries when forwarding. That's tangential to Luca's OP so we can spin it off separately.\r\n\r\n_Originally posted by @LPardue in https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/73#issuecomment-883791179_",
      "createdAt": "2021-07-21T11:01:40Z",
      "updatedAt": "2021-07-22T14:52:15Z",
      "closedAt": "2021-07-22T14:52:15Z",
      "comments": []
    },
    {
      "number": 78,
      "id": "MDU6SXNzdWU5NTAwNzMyOTA=",
      "title": "Are context IDs \"negotiated\"?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/78",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It doesn't appear that the peer has any say in the allocation of context IDs.  If not, they're not really \"negotiated.\"  Perhaps better to say that they are \"declared\" or merge with \"allocated.\"",
      "createdAt": "2021-07-21T20:12:13Z",
      "updatedAt": "2021-09-10T19:01:13Z",
      "closedAt": "2021-09-10T19:01:13Z",
      "comments": []
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU5NTAwODU3NDA=",
      "title": "Walkthrough of intended use",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/79",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The document currently has a lot of tools, but there are different ways of thinking about how you could use them and why they're in the protocol.  I feel like readability would improve dramatically if the document started with an overview that described one or two hypothetical flows.\r\n\r\nNot fully fleshed out protocols -- just an example of declaring a context associated to a request, request headers that inform the context, context extensions that inform it, exchanging datagrams, and closing the context.  The document makes reference to a few possible applications; maybe one of these could be drawn a little bit larger?",
      "createdAt": "2021-07-21T20:30:07Z",
      "updatedAt": "2021-09-21T00:30:34Z",
      "closedAt": "2021-09-21T00:30:34Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "For this request, what do you feel is missing from the examples in appendix A?\r\n\r\nThe reason I ask is that including those specific examples isn't great for the final version of this draft, the CONNECT-UDP spec is the canoncical source of the sequence and it depends on this document.\r\n\r\nIf there was a way to describe an example workflow in a more abstract sense, that addresses the gaps you're suggesting, then that would be a great candidate to keep in the document all the way through.",
          "createdAt": "2021-07-21T21:14:08Z",
          "updatedAt": "2021-07-21T21:14:08Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Those are somewhat helpful, except that they're not referenced from the text.  Besides the cross-reference, the thing that's missing is a little bit of prose explaining why each element is sent at that point.  Are they identifying the protocol being used in that context?  Are they carrying configuration for that protocol?\r\n\r\nThe examples could perhaps be generalized by describing \"an extension that carries supplemental metadata about the request,\" \"an application carrying data referenced by the request,\" etc.",
          "createdAt": "2021-07-22T20:54:45Z",
          "updatedAt": "2021-07-22T20:54:45Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWU5NTE4MTI5ODI=",
      "title": "Consider splitting DATAGRAM Capsule into two types",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/81",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The DATAGRAM capsule has an optional Context ID field. The presence of this field is based on state held in stream objects, not signalled on the wire itself. \r\n\r\nIME it's rare that the parsing of an HTTP/3 frame (in this case, the CAPSULE frame that holds the capsule) is dependent on state in this way.\r\n\r\nSo the suggestion is to define DATAGRAM/DATAGRAM_NO_CONTEXT capsule types which would allow stateless parsing of frames. After a whole frame is read, receivers can then validate ordering rules such REGISTER_CONTEXT followed by DATAGRAM capsule, REGISTER_NO_CONTEXT followed by DATAGRAM_NO_CONTEXT.\r\n\r\nThis would also allow an early shortcut exit where the CAPSULE frame length can be used to validate that the DATAGRAM capsule is suitable large.",
      "createdAt": "2021-07-23T18:35:37Z",
      "updatedAt": "2021-10-05T23:42:16Z",
      "closedAt": "2021-10-05T23:42:16Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Having now written the PR, I think the split also helps in the suggested drop / buffer case. Leaving the data in a stream isn't an option because it would block the later arriving register capsules, statelessly parsing the whole thing off the wire has a lot of attraction to me.",
          "createdAt": "2021-07-23T20:10:13Z",
          "updatedAt": "2021-07-23T20:10:13Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "aaand I completely overlooked that this also applies to the HTTP/3 datagram frame. I have similar concerns there.",
          "createdAt": "2021-07-23T20:27:59Z",
          "updatedAt": "2021-07-23T20:27:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I find it pretty attractive to make parsing stateful, because it makes it harder for intermediaries to casually parse things they should not be parsing. When I implemented this last week, it required adding a bool to our HTTP/3 frames parser, which wasn't insurmountable. Since this stateful logic is required to parse QUIC DATAGRAM frames, I'd prefer the format of DATAGRAM capsules to closely match that of QUIC DATAGRAM frames.",
          "createdAt": "2021-07-24T16:58:41Z",
          "updatedAt": "2021-07-24T16:58:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, the current design made it harder for me to parse the DATAGRAM capsule, which is explicitly defined as being transparent and malleable for intermediaries. \r\n\r\nOn reflection though, this is about parsing frame payload not frame structure. I fell into the trap of putting this into my H3 frame parse code (sounds like maybe you did too?) when really this is equivalent trying to parse constructed header lists or content after extraction from DATA frames.\r\n\r\nMuch of where to write the code, and how to expose it to applications, is an implementation-specific choice. ",
          "createdAt": "2021-07-24T17:23:07Z",
          "updatedAt": "2021-07-24T17:23:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "To add, I not convinced the proposed PR is required either but I'd appreciate some time to mull on this a bit more and play with implementation to understand if there is some other way to come a net improvement.",
          "createdAt": "2021-07-24T17:31:27Z",
          "updatedAt": "2021-07-24T17:31:27Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Intermediaries do need to parse the datagram capsule type, but they don't need to parse the context ID nor payload, they just need to forward the \"optional context ID followed by payload\" opaque blob.\r\n\r\nMy implementation doesn't currently support acting as intermediary, so I have full parsing together for now. I plan on supporting this in Envoy as both intermediary and endpoint so I'll have to ponder how best to do that. I suspect I'll just split parsing in two: first half parses capsule type and opaque capsule data, second half parses capsule data according to the type.\r\n\r\nBut regardless, I totally agree that this is worth thinking about some more.",
          "createdAt": "2021-07-24T18:21:37Z",
          "updatedAt": "2021-07-24T18:21:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Daivd said:\r\n> Since this stateful logic is required to parse QUIC DATAGRAM frames, I'd prefer the format of DATAGRAM capsules to closely match that of QUIC DATAGRAM frames.\r\n\r\nI'd overlooked this point earlier. There's not a cheap way to incorporate a CONTEXT/NO_CONTEXT discriminator into the HTTP/3 DATAGRAM frame. Spending a varint on that seems like a waste.",
          "createdAt": "2021-09-26T14:24:43Z",
          "updatedAt": "2021-09-26T14:24:43Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue do you have further thoughts, or should we close this issue with no action?",
          "createdAt": "2021-10-05T22:34:05Z",
          "updatedAt": "2021-10-05T22:34:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "With the recent changes to the Capsule protocol definition I believe this\nissue is mooted. Let's close it. But on grounds that I reserve the right to\nreopen the issue should I find the same problem when implementing the new\ndesign :-)\n",
          "createdAt": "2021-10-05T23:38:34Z",
          "updatedAt": "2021-10-05T23:38:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "You have the right to reopen any and all issues :-P\r\nClosing based on discussion above.",
          "createdAt": "2021-10-05T23:42:16Z",
          "updatedAt": "2021-10-05T23:42:16Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU5NTI0MjUxNTg=",
      "title": "Tables are rendering as ASCII art not tables",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/83",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Real tables are relatively easy to get.  It probably just involves deleting a few `~~~` lines and tweaking the separator in the artworks you already have.",
      "createdAt": "2021-07-26T01:59:17Z",
      "updatedAt": "2021-09-09T22:31:06Z",
      "closedAt": "2021-09-09T22:31:06Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for catching that, I'll fix it during the next editorial pass.",
          "createdAt": "2021-07-26T02:06:42Z",
          "updatedAt": "2021-07-26T02:06:42Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU5NTg2MTYyNDY=",
      "title": "Remove context identifiers",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/84",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The capsules that signal use of different datagram contexts (or the absence thereof) assume that there is a generic need for this form of identification.  That has not been established.  WebTransport certainly doesn't need it.  \r\n\r\nAs this is an *end-to-end* signal anyway, it is also a *protocol-specific* signal.  All uses of this framework are perfectly capable of doing their own signaling and negotiation.  A one-size-fits-all mechanism is more likely a one-size-fits-few mechanism, but it still comes with costs that every user has to bear (see ietf-wg-webtrans/draft-ietf-webtrans-http3#54 for instance).\r\n\r\nFor instance, if CONNECT-UDP wanted to signal ECN and DSCP, that might be more efficiently achieved with a single byte (2 + 6) rather than a varint.  If CONNECT-IP wanted different compression contexts, that might be suited to a varint, but why would this draft be in a position to decide that?\r\n\r\nAs there is no value in an intermediary looking at these context identifiers - I would argue negative utility in the RFC 8558 sense - these should be removed from the protocol.\r\n\r\nThe only potential value I see in having some sort of signaling here is to explicitly signal the use of DATAGRAM frames associated with a stream.  However, as we have agreed to send DATAGRAM frames without negotiation, that too seems like it won't be needed.",
      "createdAt": "2021-08-03T00:49:31Z",
      "updatedAt": "2021-09-26T14:50:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Deciding where to draw the line between having a feature live in the shared domain or an application-specific domain is always tricky. On one hand if you share every feature, each application has to do useless work. On the other if you don't share you end up reinventing many similar yet different wheels. In this case it isn't obvious because we have two applications that need it and one that doesn't. So we can't make a decision based on architectural fundamentals.\r\n\r\nThe question here is therefore a pragmatic one: how do we trade off between WebTransport's ease of implementation and CONNECT-IP's extensibility? For me, it comes down to negotiation. I proposed the design that's currently in the drafts because it has one property I really like: zero-round-trip negotiation. In other words, the client is free to choose between using or not using contexts, and can immediately start sending using its preferred choice without waiting to see the server's headers. I see it as the best of both worlds: WebTransport gets efficient wire encoding at a very small added implementation cost, and CONNECT-IP gets an efficient compression mechanism.",
          "createdAt": "2021-08-09T21:50:24Z",
          "updatedAt": "2021-08-09T21:50:24Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "I'm not sure why this is presented as a dichotomy.  The draft can provide a mechanism for contexts layered on top of a common capsule framing, and then CONNECT-IP can use both, while WebTransport can use datagrams+capsules directly (the exact semantics depending on the specific method or `:protocol` value used).",
          "createdAt": "2021-08-10T07:12:49Z",
          "updatedAt": "2021-08-10T07:12:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv my concern there is that if WebTransport decides to only use a subset of HTTP Datagrams, then when someone implements a WebTransport-compatible intermediary, they're going to skip implementing contexts. If we decide that all applications can use contexts, it will ensure we have a healthy ecosystem of intermediaries that support any HTTP Datagram application.",
          "createdAt": "2021-08-10T16:58:16Z",
          "updatedAt": "2021-08-10T16:58:16Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "Sure, just like they can decide to drop any request that has method `CONNECT-UDP`, or whatever `:protocol` value you come up with.  There will be inevitable friction to introducing any specific new use of datagrams, and I don't think you can pay the entirety of that cost upfront.  The intermediaries that are used by people who want to pass MASQUE traffic will implement contexts, and for the rest, this doesn't really matter.",
          "createdAt": "2021-08-10T17:53:41Z",
          "updatedAt": "2021-08-10T17:53:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "There's a very big difference here: if we decide that all HTTP Datagram applications are the same to intermediaries, it takes less work for them to support all of them than it does to support only one. That's what ensures that they all get supported. The risk is someone implementing half the protocol to save time, not someone going out of their way to disallow some options.",
          "createdAt": "2021-08-10T18:46:24Z",
          "updatedAt": "2021-08-10T18:46:24Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "I'm confused.  How do you make them same to the intermediaries while making them different to the endpoints?",
          "createdAt": "2021-08-10T19:01:05Z",
          "updatedAt": "2021-08-10T19:01:05Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "By ensuring that intermediaries treat all opaque capsules the same, but having endpoints parse and react to each capsule according to its semantics.",
          "createdAt": "2021-08-12T16:39:29Z",
          "updatedAt": "2021-08-12T16:39:29Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "But if the intermediaries treat all of the capsules the same, it doesn't matter if datagram contexts are optional or not, since it would require parsing capsules to know that.",
          "createdAt": "2021-08-12T18:24:34Z",
          "updatedAt": "2021-08-12T18:24:34Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to this, we have\r\n\r\n> Implementations of HTTP Datagrams MUST provide a context ID allocation service. That service will allow applications co-located with HTTP to request a unique context ID that they can subsequently use for their own purposes.\r\n\r\nThis seems to be a bit of a backdoor requirement. An implementation that only cared to support no-context datagrams would not need the context ID allocation service.",
          "createdAt": "2021-09-26T14:50:01Z",
          "updatedAt": "2021-09-26T14:50:01Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU5ODE3MjEwOTg=",
      "title": "Clarify meaning of SETTINGS parameter",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/85",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In section 6, it says \"A value of 0 indicates that this mechanism is not supported.\" The draft actually has two mechanisms: the DATAGRAM frame and the CAPSULE frame. It would be useful to clarify that the parameter only refers to support for the DATAGRAM frame.",
      "createdAt": "2021-08-28T04:08:07Z",
      "updatedAt": "2021-09-09T23:32:42Z",
      "closedAt": "2021-09-09T23:32:42Z",
      "comments": []
    },
    {
      "number": 92,
      "id": "I_kwDODOpKfc48C9oB",
      "title": "Describe document structure and/or terms in intro section",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/92",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "There's now several different concepts to wrangle in this document. Reading from the top, we first tackle multiplexing (the major motivation for the document), then the frame, then capsules. Capsules underpin the mechanics of multiplexing. I don't think we can fix this chicken and egg problem but adding a brief overview of the concepts and terms before they are tackled in the prose could help readability.",
      "createdAt": "2021-09-26T14:37:43Z",
      "updatedAt": "2021-10-05T11:26:06Z",
      "closedAt": "2021-10-05T11:26:06Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that sounds like a great idea!",
          "createdAt": "2021-09-27T16:15:48Z",
          "updatedAt": "2021-09-27T16:15:48Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "I_kwDODOpKfc48C_I6",
      "title": "Quarter Stream ID range is smaller than Stream ID range",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/93",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stating the obvious here. But we're using value with a legal range larger than semantically legal. RFC 9000 has some similar caveats with MAX_STREAMS https://www.rfc-editor.org/rfc/rfc9000.html#section-19.11\r\n\r\nTo address this, the suggestion is to add something like\r\n\r\n>  The largest legal stream ID is 2^62 - 1, so this value cannot exceed (2^62-1) / 4. Receipt of a frame that includes a larger value MUST be treated as a connection error of type FRAME_ENCODING_ERROR",
      "createdAt": "2021-09-26T15:02:46Z",
      "updatedAt": "2021-10-05T11:25:52Z",
      "closedAt": "2021-10-05T11:25:52Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That suggestion sounds good to me.",
          "createdAt": "2021-09-27T16:16:50Z",
          "updatedAt": "2021-09-27T16:16:57Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "I_kwDODOpKfc48DAEt",
      "title": "Expand all capsule figures to include their Type and Length fields",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/94",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "QUIC and HTTP/3 style is to define the general format and then in each instance define the object including all of its fields. This would look like\r\n\r\n```\r\nREGISTER_DATAGRAM_CONTEXT Capsule {\r\n  Type (i) = see Section 8.2,\r\n  Length (i)\r\n  Context ID (i),\r\n  Datagram Format Type (i),\r\n  Datagram Format Additional Data (..),\r\n}\r\n```\r\n\r\nThis can later be updated with the actual type value once things settle down",
      "createdAt": "2021-09-26T15:15:38Z",
      "updatedAt": "2021-09-27T23:24:11Z",
      "closedAt": "2021-09-27T23:24:11Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Fine by me.",
          "createdAt": "2021-09-27T16:17:26Z",
          "updatedAt": "2021-09-27T16:17:26Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "I_kwDODOpKfc48DA9R",
      "title": "Consider a GENERAL_ERROR close code",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/95",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There may be cases (imagine new capsule types) where somthing went wrong but none of the existing codes are appropriate. Signalling NO_ERROR is not appropriate and may be misleading.",
      "createdAt": "2021-09-26T15:29:59Z",
      "updatedAt": "2021-10-06T23:52:22Z",
      "closedAt": "2021-10-06T23:52:22Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Close context capsules carry two items of information about the reason for closing: close codes and close details. In my mind, the close code is meant for software (if you receive this close code instead of that one, the implementation will behave differently) whereas the close details are for humans trying to debug things. So when we're thinking of adding a new close code (as opposed to sending more prose in close details), it begs the question: how would software treat GENERAL_ERROR differently from NO_ERROR?",
          "createdAt": "2021-09-27T16:21:27Z",
          "updatedAt": "2021-09-27T16:21:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "good question!\r\n\r\nWe should probably try to capture the ethos of these error codes so everyone has the same expectation. For instance HTTP/3 says\r\n\r\n> Stream errors are distinct\r\n   from HTTP status codes which indicate error conditions.  Stream\r\n   errors indicate that the sender did not transfer or consume the full\r\n   request or response, while HTTP status codes indicate the result of a\r\n   request that was successfully received.\r\n\r\nIs a close code more like a HTTP status code or a stream error code? It feels like the latter, so to use your examples, when thinking about retry registration, it sounds like we have categories where it is safe to retry registration (NO_ERROR), most definitely not allowed to retry (UNKNOWN_FORMAT, DENIED), maybe retry (RESOURCE_LIMIT). So I guess a GENERAL_ERROR type would fit into a maybe retry bucket. And if some new use of capsules requires \"don't retry\" where the existing codes aren't suited, they really should define a new code.\r\n\r\nAlternatively, we seem to just be reinventing HTTP status codes - so we could, y'know, just use that value range here :laughing: ",
          "createdAt": "2021-09-27T16:45:13Z",
          "updatedAt": "2021-09-27T16:45:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree writing some text about the ethos and intended use of closes codes is a good idea. Perhaps something like:\r\n* Close codes are intended to allow implementations to react differently when they receive them - for example, some close codes require the receiver to not open another context under certain conditions. Extensions to this mechanism MAY define new close codes if they wish to have receivers react differently.\r\n\r\nI don't think NO_ERROR is in the \"safe to retry\" category, because unknown codes are meant to be treated as NO_ERROR. Perhaps we merge NO_ERROR and GENERAL_ERROR and rename the result UNKNOWN_ERROR?",
          "createdAt": "2021-09-27T17:46:21Z",
          "updatedAt": "2021-09-27T17:46:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "How about we spin off \"ethos and intention\" to a new ticket?\r\n\r\n> I don't think NO_ERROR is in the \"safe to retry\" category, because unknown codes are meant to be treated as NO_ERROR. \r\n\r\nAh good point. \r\n\r\nI'm all for bikeshedding a name - how about MAYBE_ERROR?\r\n\r\nI realise that the current definition\r\n\r\n> NO_ERROR: This indicates that the registration was closed without any additional information.\r\n\r\nis slightly ambiguous as to whether the `Close Details\" field would be populated or not.\r\n",
          "createdAt": "2021-09-27T19:06:33Z",
          "updatedAt": "2021-09-27T19:06:33Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> How about we spin off \"ethos and intention\" to a new ticket?\r\n\r\nSure!\r\n\r\n> I'm all for bikeshedding a name - how about MAYBE_ERROR?\r\n\r\nI prefer UNKNOWN_ERROR to MAYBE_ERROR, but I don't care too much.\r\n\r\n> I realise that the current definition\r\n> \r\n> > NO_ERROR: This indicates that the registration was closed without any additional information.\r\n> \r\n> is slightly ambiguous as to whether the `Close Details\" field would be populated or not.\r\n\r\nAgreed. Perhaps something like:\r\n* NO_ERROR: This indicates that the registration was closed without any action specified for the receiver.\r\n\r\nI'm not loving that sentence, but my intent was to convey that close codes exist to carry some action or requirement of the receiver, and NO_ERROR carries no such action or requirement.",
          "createdAt": "2021-09-27T19:16:27Z",
          "updatedAt": "2021-09-27T19:16:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I think #100 can handle the ethos stuff, I don't think we need to bother with an open and shut issue but if you do that's ok.\r\n\r\nThat leaves the remaining question about name. I think with the new text it becomes clearer that the \"NO_ERROR\" is really just \"CLOSED_WITH_NO_ACTION\" ",
          "createdAt": "2021-10-06T22:18:59Z",
          "updatedAt": "2021-10-06T22:18:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I like #100. Beyond that, I don't much care about the name. Slight preference for NO_ERROR but I'm OK with CLOSED_WITH_NO_ACTION",
          "createdAt": "2021-10-06T22:28:18Z",
          "updatedAt": "2021-10-06T22:28:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm happy without _another_ error code right now. So how about we close this ticket and spin off just a naming bikeshed issue?\r\n",
          "createdAt": "2021-10-06T22:29:59Z",
          "updatedAt": "2021-10-06T22:29:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good, closing this one. I'll let you open the naming issue :)",
          "createdAt": "2021-10-06T23:52:22Z",
          "updatedAt": "2021-10-06T23:52:22Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "I_kwDODOpKfc48DBKY",
      "title": "Capsules on data streams means we need some consideration about prioritization",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/96",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Most likely just need a sentence saying that the data stream is treated the same regardless if capsules are used or not.",
      "createdAt": "2021-09-26T15:33:12Z",
      "updatedAt": "2021-10-06T23:51:46Z",
      "closedAt": "2021-10-06T23:51:46Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding that sentence sounds fine by me.",
          "createdAt": "2021-09-27T16:21:52Z",
          "updatedAt": "2021-09-27T16:21:52Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "I_kwDODOpKfc48xVNb",
      "title": "Update CONNECT-UDP examples to align with latest draft",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/102",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'd be good to update the CONNECT-UDP examples to use the extended CONNECT protocol in the latest version of CONNECT-UDP.",
      "createdAt": "2021-10-07T03:20:16Z",
      "updatedAt": "2021-10-07T23:38:57Z",
      "closedAt": "2021-10-07T23:38:57Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah good find, I forgot those.",
          "createdAt": "2021-10-07T22:13:18Z",
          "updatedAt": "2021-10-07T22:13:18Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "I_kwDODOpKfc49B8LI",
      "title": "Who owns the registries created by this document?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/104",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The HTTP/3 spec was \"contracted out to the QUIC WG\", but the registries it establishes are given back to the the HTTP WG\r\n\r\n> The initial allocations in these registries created in this document\r\n   are all assigned permanent status and list a change controller of the\r\n   IETF and a contact of the HTTP working group (ietf-http-wg@w3.org).\r\n\r\nThis spec defines some new registries, it isn't clear to me which WG would \"own\" the registry after we are done with this spec.",
      "createdAt": "2021-10-12T14:52:23Z",
      "updatedAt": "2021-10-12T16:14:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Technically, IANA registries aren't owned by Working Groups. But adding the HTTP working group as a contact for the initial entries sounds fine by me. But I'd prefer to put this on hold until we're closer to publication.",
          "createdAt": "2021-10-12T16:08:51Z",
          "updatedAt": "2021-10-12T16:08:51Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "WFM!",
          "createdAt": "2021-10-12T16:14:48Z",
          "updatedAt": "2021-10-12T16:14:48Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "I_kwDODOpKfc49gc_J",
      "title": "Consider stream limits when parsing HTTP/3 datagrams",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/106",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [],
      "body": "We say:\r\n\r\n> If an HTTP/3 datagram is received and its Quarter Stream ID maps to a stream that has not yet been created, the receiver SHALL either drop that datagram silently or buffer it temporarily while awaiting the creation of the corresponding stream.\r\n\r\nThis has some parallels to Extensible Priorities where we are expected to handling an H3 frame that might reference a stream that has not yet been created (most likely due to reordering). We can't avoid reordering but we can be more conservative on the frames that do get buffered. \r\n\r\nhttps://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#section-7.2-6 says:\r\n\r\n> If a server receives a PRIORITY_UPDATE (type=0xF0700) with a Stream ID that is beyond the stream limits, this SHOULD be treated as a connection error of type H3_ID_ERROR. Generating an error is not mandatory because HTTP/3 implementations might have practical barriers to determining the active stream concurrency limit that is applied by the QUIC layer.\r\n\r\nWe can probably recommend something similar here.",
      "createdAt": "2021-10-20T23:43:38Z",
      "updatedAt": "2021-10-21T00:44:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This makes sense, sending an HTTP Datagram for a stream that you're not yet allowed to create violates a MUST in a detectable way so we can recommend punishment. Though I doubt that we'd implement this check.",
          "createdAt": "2021-10-21T00:44:07Z",
          "updatedAt": "2021-10-21T00:44:07Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "I_kwDODOpKfc49ge_x",
      "title": "Capsule lengths",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/107",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The generic definition of Capsule includes the `Capsule Length` field that is the length of all remaining fields, which depends on the type. We state that the length can be zero.\r\n\r\nHowever, many of the capsule types we define cannot be zero-length:\r\n\r\n* REGISTER_DATAGRAM - at least 1 byte\r\n* REGISTER_DATAGRAM_CONTEXT - at least 2 bytes\r\n* Datagram Close - at least 2 bytes\r\n\r\nWe could be more prescriptive of these capsules. Such as explicitly marking the minimal length in the figures, or noting it in the prose. We might also recommend that receivers of these capsules reject capsules that are clearly too short",
      "createdAt": "2021-10-21T00:04:12Z",
      "updatedAt": "2021-11-01T18:34:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "How about we do something similar to [this generic text about h3 frames](https://datatracker.ietf.org/doc/html/draft-ietf-quic-http#section-7.1):\r\n\r\n> Each frame's payload MUST contain exactly the fields identified in its description. A frame payload that contains additional bytes after the identified fields or a frame payload that terminates before the end of the identified fields MUST be treated as a connection error of type H3_FRAME_ERROR; see Section 8. In particular, redundant length encodings MUST be verified to be self-consistent; see Section 10.8.",
          "createdAt": "2021-10-21T00:46:31Z",
          "updatedAt": "2021-10-21T00:46:31Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Is it also a connection error / FRAME_ERROR if the stream containing capsules ends in the middle of a capsule?",
          "createdAt": "2021-10-30T15:59:49Z",
          "updatedAt": "2021-10-30T15:59:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Capsules are end-to-end so if the stream is aborted mid-capsule by an endpoint, there's not much an intermediary can do, and it shouldn't impact other streams on the same connection. Our implementation will reset a stream if it receives a FIN mid-capsule.",
          "createdAt": "2021-11-01T17:30:33Z",
          "updatedAt": "2021-11-01T17:30:33Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Since capsules are above the layer of H2 and H3, closing a connection seems quite extreme.\r\n\r\nI would treat these a bit like truncated HTTP content. Terminating the data stream seems like a decent recommendation, ",
          "createdAt": "2021-11-01T17:47:20Z",
          "updatedAt": "2021-11-01T17:47:20Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> Capsules are end-to-end so if the stream is aborted mid-capsule by an endpoint, there's not much an intermediary can do, and it shouldn't impact other streams on the same connection. \r\n\r\nIf an endpoint aborts a stream mid-capsule, it should do so with a RST and not a FIN, right? The text in H3 (right below your linked text) talks about truncation on graceful completion.\r\n\r\nAlso, is the recommendation from the original issue (malformed frames) also be a stream or a connection error?  It seems like we should be applying the same logic to the two cases, right?",
          "createdAt": "2021-11-01T18:18:43Z",
          "updatedAt": "2021-11-01T18:18:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Capsules aren't frames. We should expect some implementations to allow applications to inject their own capsules, just like application can insert HTTP content today. There might be valid reasons to terminate a stream, such as the user losing interest in a tunnelled connection, an implementation that is taking opaque application data and sending it has no way to ensure it doesn't send a truncated capsule.\r\n\r\nFor these reasons, I think recommending a connection closure is too extreme (endpoints can always do that if they really want to). Recommending a stream closure, with possibly a new error code, seems right.",
          "createdAt": "2021-11-01T18:34:27Z",
          "updatedAt": "2021-11-01T18:34:27Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "I_kwDODOpKfc49ggIR",
      "title": "Section 6.1 should be 5.1",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/108",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Editorial whoops when the Sec-Use-Datagram-Contexts header was added",
      "createdAt": "2021-10-21T00:14:22Z",
      "updatedAt": "2021-10-21T00:48:29Z",
      "closedAt": "2021-10-21T00:48:29Z",
      "comments": []
    },
    {
      "number": 109,
      "id": "I_kwDODOpKfc49ghxu",
      "title": "Commentary on \"sticking out\" is stale and possibly mislocated",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/109",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The doc has evolved from just HTTP/3 Datagram, to define Capsule protocol and HTTP datagrams over capsule.\r\n\r\nIn Security Considerations, we say\r\n\r\n> Since this feature requires sending an HTTP/3 Settings parameter, it \"sticks out\".\r\n\r\nIt's a little ambiguous what \"this feature\" on face value. Arguably, the recommendation to always send the setting could be done in the section that defines the setting. Some editorial work would address these concerns.",
      "createdAt": "2021-10-21T00:28:54Z",
      "updatedAt": "2021-10-21T00:49:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed",
          "createdAt": "2021-10-21T00:49:34Z",
          "updatedAt": "2021-10-21T00:49:34Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "I_kwDODOpKfc493HUZ",
      "title": "RELIABLE_DATAGRAM",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/111",
      "state": "OPEN",
      "author": "bemasc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We should revisit [the RELIABLE_DATAGRAM question](https://mailarchive.ietf.org/arch/msg/masque/JImas3YR45txq60pZR2Ab-_LxzQ/).",
      "createdAt": "2021-10-27T21:00:34Z",
      "updatedAt": "2021-11-23T00:42:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A discussion of this has broken out [here](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124#discussion_r751879354).\r\n\r\nMy understanding is that there are two major motivating reasons for this:\r\n\r\n1. The desire for end-to-end finite-sized message.  I think we resolved that capsules *of any type* provide this capability, so any attempt to add the capability to this draft is largely based on the desire to have a singular form.\r\n\r\n2. Something about [zero-latency extensibility](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124#discussion_r753423751).\r\n\r\nThe latter is the interesting one. I admit that I don't understand it well, especially the part that uses a RELIABLE_DATAGRAM capsule.\r\n\r\nThe desire to be able to negotiate different uses for QUIC DATAGRAM frames *and* for clients to be able to exercise those options prior to seeing any response from a server is very much context-specific.  Lowering latency is interesting, but I don't have a clear path from that requirement to this proposed mechanism.\r\n\r\nLow-latency extensibility for DATAGRAM frames is something that can be enabled for each protocol by defining a \"usage\" field in the DATAGRAM payload for that protocol. The goal here seems to be to be able to impose the use of this \"usage\" field on any protocol, even if that protocol didn't originally choose to allow that.\r\n\r\nThat's quite a narrow applicability:\r\n\r\n* uses DATAGRAM frames (unreliable, finite sized messages)\r\n* has multiple uses for those DATAGRAM frames\r\n* has some potential uses that are unknown at the time the protocol is defined (that naturally flows from the multiple uses scenario)\r\n* wants clients to be able to send DATAGRAM frames immediately (which might well be a generic capability)\r\n* didn't want the overhead of an additional field in DATAGRAM frames in the original design\r\n\r\nIt seems like this imposes a constraint on a client that wants to exercise this extensibility. Such a client can't send DATAGRAM frames immediately.  It has to use RELIABLE_DATAGRAM until the negotiation is complete.  That seems like an undesirable property to me, but I can see some advantages to it.  It's also unclear whether a server is similarly constrained.  It might answer a request without knowing that the client wants to support this extension, so it might also need to refrain from sending DATAGRAM frames until can perform the same negotiation.\r\n\r\nThe simpler design alternative is to add a \"usage\" tag to every DATAGRAM for all protocols.  That's easy: unknown (or unnegotiated) usage labels are ignored.  But that's overhead and I'm opposed to that.  It says that someone defining a protocol can't know what they are doing (which shows a great lack of faith, even if experience suggests that we often get this sort of thing wrong).\r\n\r\nNo matter what path I plot, I can't see a path in which RELIABLE_DATAGRAM is useful.\r\n\r\n@DavidSchinazi, perhaps you can help us understand your vision better.  That said, co-opting this issue might not be the right way to do that; what you are talking about might be solved using other mechanisms.  Perhaps we should discuss the low-latency extensibility requirement in its own issue.",
          "createdAt": "2021-11-22T01:24:40Z",
          "updatedAt": "2021-11-22T01:24:40Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> Low-latency extensibility for DATAGRAM frames is something that can be enabled for each protocol by defining a \"usage\" field in the DATAGRAM payload for that protocol.\r\n\r\nSo much this.  I don't know if I'd call it usage, but I think any protocol that wants DATAGRAM extensibility should be using a varint at the beginning of the payload to facilitate it.\r\n\r\n> The simpler design alternative is to add a \"usage\" tag to every DATAGRAM for all protocols. ... But that's overhead and I'm opposed to that. \r\n\r\nNot all protocols need it.  WebTransport doesn't (yet anyways).  I don't think we should require it in H3 Datagram.  To refine the point about overhead though, I am OK with this overhead in CONNECT-UDP/CONNECT-IP if those protocols want extensibility.  The < 0.1% overhead there seems like a reasonable tradeoff.\r\n\r\n> No matter what path I plot, I can't see a path in which RELIABLE_DATAGRAM is useful.\r\n\r\nGiven that I think there are better patterns for extensibility at higher layers, I don't think RELIABLE_DATAGRAM is useful at this layer.",
          "createdAt": "2021-11-22T01:55:18Z",
          "updatedAt": "2021-11-22T01:55:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I've filed #125 to discuss zero-latency extensibility, since RELIABLE_DATAGRAM is one potential solution but not the only possible one.",
          "createdAt": "2021-11-23T00:42:56Z",
          "updatedAt": "2021-11-23T00:42:56Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "I_kwDODOpKfc4-Zc48",
      "title": "Emit in order",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/116",
      "state": "OPEN",
      "author": "ekr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "S 4.3 says:\r\n\r\n>    Intermediaries respect the order of opaque CAPSULE frames: if an\r\n   intermediary receives two opaque CAPSULE frames in a given order, it\r\n   MUST forward them in the same order.\r\n\r\nHow does this practically work when the frames are sent over unreliable transport.",
      "createdAt": "2021-11-07T21:55:17Z",
      "updatedAt": "2021-11-08T02:51:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "The text is intended to avoid needless reordering.\r\nCapsule reception on a stream is ordered. Sending on the next stream can be ordered too. That applies across all HTTP version.\r\n\r\nIn the one case where a Datagram Capsules are specifically being converted to QUIC datagram frames, I would still expect an implementation to be able to send them in order locally. After this, reordering might occur but at least the proxy tried to do the right thing",
          "createdAt": "2021-11-07T22:00:53Z",
          "updatedAt": "2021-11-07T22:00:53Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "This does not seem like an appropriate use of a MUST.",
          "createdAt": "2021-11-07T22:03:29Z",
          "updatedAt": "2021-11-07T22:03:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Why not?\r\n\r\nAn intermediary that reorders the HTTP bytestream is going to cause problems for people, independent of whether that stream is actual HTTP content or capsules like here. ",
          "createdAt": "2021-11-07T22:06:26Z",
          "updatedAt": "2021-11-07T22:06:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "I'm talking about the case where they are in datagram frames, in which case this is not an interop requirement.\r\n",
          "createdAt": "2021-11-07T22:09:54Z",
          "updatedAt": "2021-11-07T22:09:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that the requirement is for opaque capsules and the datagram capsule is defined as transparent, so it has different requirements.\r\n\r\nAside: the terms transparent and opaque capsules are a topic of discussion, but the special case for datagram capsule likely will hold",
          "createdAt": "2021-11-07T22:21:10Z",
          "updatedAt": "2021-11-07T22:21:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr I think you're misunderstanding. This MUST is about capsules, not HTTP Datagrams. Capsules are sent over streams, capsules cannot be sent over datagram frames.",
          "createdAt": "2021-11-08T02:51:49Z",
          "updatedAt": "2021-11-08T02:51:49Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "I_kwDODOpKfc4-bNHr",
      "title": "Acknowledge that Context ID is optional",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/117",
      "state": "OPEN",
      "author": "ddragana",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> Endpoints parse both the Quarter Stream ID field and the Context ID\r\n   field in order to associate the QUIC DATAGRAM frame with a stream and\r\n   context within that stream.  If an endpoint receives a QUIC DATAGRAM\r\n   frame whose payload is too short to allow parsing the Quarter Stream\r\n   ID field, the endpoint MUST treat it as an HTTP/3 connection error of\r\n   type H3_GENERAL_PROTOCOL_ERROR.  If an endpoint receives a QUIC\r\n   DATAGRAM frame whose payload is long enough to allow parsing the\r\n   Quarter Stream ID field but too short to allow parsing the Context ID\r\n   field, the endpoint MUST abruptly terminate the corresponding stream\r\n   with a stream error of type H3_GENERAL_PROTOCOL_ERROR.\r\n\r\n\r\nThis tests talks about paring of Context ID on an endpoint, but Context ID is optional. The text should acknowledge that better.",
      "createdAt": "2021-11-08T11:12:57Z",
      "updatedAt": "2021-11-08T11:12:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 118,
      "id": "I_kwDODOpKfc4-bOOe",
      "title": "Improve text about multiple CLOSE_DATAGRAM_CONTEXTs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/118",
      "state": "OPEN",
      "author": "ddragana",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> Endpoints MUST NOT close a Context ID that was not previously\r\n   registered.  Endpoints MUST NOT close a Context ID that has already\r\n   been closed.  If an endpoint receives a CLOSE_DATAGRAM_CONTEXT\r\n   capsule that violates one or more of these requirements, the endpoint\r\n   MUST abruptly terminate the corresponding stream with a stream error\r\n   of type H3_GENERAL_PROTOCOL_ERROR.\r\n\r\n\r\nI think this text should acknowledge that both sides may close a context at the same time and that a CLOSE_DATAGRAM_CONTEXT may be received for a already closed context. This is just a nit, but I think worth mentioning.\r\n\r\n",
      "createdAt": "2021-11-08T11:17:05Z",
      "updatedAt": "2021-11-08T11:17:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 120,
      "id": "I_kwDODOpKfc4-g-h7",
      "title": "Serialization over HTTP/1.x of multiple HTTP requests with Datagram",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/120",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Section 2:\r\n\r\nWhen running over HTTP/1, requests are strictly serialized in the connection, therefore the first layer of demultiplexing is not needed.\r\n\r\nIs there any actual possibility to run more than a single request with HTTP datagram support over an transport connection? When one runs an HTTP request that enables datagram I don't see how it would be possible to close that request in any other way than closing the underlying transport connection. Or are there a way that I am missing that would enable one to close this request, and then issue another pipelined HTTP request that also uses HTTP datagrams? \r\n\r\nIs there a need to clarify this, or make it clear that only a single HTTP request with datagram can be sent? ",
      "createdAt": "2021-11-09T16:38:12Z",
      "updatedAt": "2021-11-09T19:03:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "In section 2, we've yet to mention anything about how the rest of the spec operates. So the comment in isolation is correct when talking about the general concept of multiplexin.\r\n\r\nI see your point but I'm not sure saying anything more here will help. Section 4.1 provides the details that implementers need to do the right thing.",
          "createdAt": "2021-11-09T17:13:41Z",
          "updatedAt": "2021-11-09T17:13:41Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, but lets include Section 4.1 also into this. I assume you are referring to this sentence:\r\n\r\nIn HTTP/1.x, the data stream consists of all bytes on the connection that follow the blank line that concludes either the request header section, or the 2xx (Successful) response header section.\r\n\r\nBut, per https://www.ietf.org/archive/id/draft-ietf-httpbis-messaging-19.html#name-message-body-length this body length length rules will be those that could govern a closure of a HTTP request enabling datagram. Would it be realistic to actually make it clear that if one enable HTTP Datagram transport close is the only, way or is that just creating additional rules making implementation even more? Otherwise do we need additional analysis if there are possibility that any of these rules could actually result in a closing a HTTP request? ",
          "createdAt": "2021-11-09T17:23:43Z",
          "updatedAt": "2021-11-09T17:23:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "There is no HTTP content on upgrade requests, we should link to the definition of Upgrade  https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.7.8 and make things slightly more clear in Section 4.1.",
          "createdAt": "2021-11-09T17:31:59Z",
          "updatedAt": "2021-11-09T17:31:59Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, I guess it becomes a question of which method for enabling datagram one uses, if this is an upgrade or a new method. And I would note that Connect method appears to have some interesting exceptions compared to other methods. Which I think makes this into a requirement on the using method/upgrade that uses HTTP datagrams to actually specify this aspect.  ",
          "createdAt": "2021-11-09T17:47:27Z",
          "updatedAt": "2021-11-09T17:47:27Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I've written up #122 to clarify that pipelining is not supported.",
          "createdAt": "2021-11-09T19:03:26Z",
          "updatedAt": "2021-11-09T19:03:26Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "I_kwDODOpKfc4-hBux",
      "title": "HTTP Datagram and HTTP Push",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/121",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is more a request for clarification of protocol properties than an actual issue.\r\n\r\nDue to the quarter stream construction, the enabling of HTTP datagram can only be done by client initiated streams in HTTP/3. Thus, in the future one would never create an HTTP datagram functionality directly associated with for example the HTTP push mechanism. I currently don't see any need for such functionality as after HTTP Datagram has been enabled datagram push could be done in relation to a client HTTP request. \r\n\r\n",
      "createdAt": "2021-11-09T16:51:20Z",
      "updatedAt": "2021-11-09T17:02:05Z",
      "closedAt": "2021-11-09T17:02:05Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This was already discussed in #47. In HTTP/3, push streams are always associated with a request stream. There is no need to have datagrams associated with push streams.",
          "createdAt": "2021-11-09T17:02:05Z",
          "updatedAt": "2021-11-09T17:02:05Z"
        }
      ]
    },
    {
      "number": 123,
      "id": "I_kwDODOpKfc4-lTFv",
      "title": "Proposal: WebTransport-oriented HTTP Datagram architecture",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/123",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I think we can address many of the complexity concerns with the H3 Datagrams draft by adjusting the architecture to focus more on WebTransport.  Here's a sketch of the required changes:\r\n\r\n1. In WebTransport, Datagrams are associated with Streams, not Sessions.  This requires simplifying H3 Datagram's \"Quarter Stream ID\" to just \"Stream ID\".\r\n2. Get rid of \"Datagram Contexts\".  The context for a Datagram is its associated Stream.\r\n3. Run the MASQUE services over WebTransport.  The URL must distinguish the service in use (e.g. UDP vs. IP proxying). The `:protocol` value is `webtransport`.\r\n4. UDP and IP proxy services only use Datagrams and Bidirectional Streams.  The stream contains messages in a simple TLV format (\"capsules\").  There are three basic capsule types:\r\n\r\n* `INIT`\r\n  - No payload\r\n* `ACK`\r\n  - Contains an integer success/error code\r\n* `DATAGRAM`\r\n  - Arbitrary payload\r\n  - Equivalent to an associated Datagram, but reliable and in-order\r\n\r\n\"False Start\" is supported by sending a `DATAGRAM` capsule (or a Datagram) immediately after `INIT`.  Non-default datagram formats can be enabled later by defining an `INIT_EXTENDED` capsule type, which would elicit an error `ACK` from basic implementations.\r\n\r\nIntermediaries that relay between H2 and H3 need to understand WebTransport, but do not need to know anything about MASQUE or the Stream contents.\r\n\r\nMore aggressive variations:\r\n* Use the \"CONNECT stream\" for the default format.\r\n  - Avoids the need for `INIT`, but may not be compatible with the expected WebTransport APIs and use patterns.\r\n* Move target host and port specification from the URL to an `INIT_EXTENDED` capsule.\r\n  - Perhaps clearer, but would deviate from the current CONNECT-IP and CONNECT-UDP consensus plans.\r\n* Reuse HTTP/3 frames instead of capsules (`INIT`/`ACK` -> `HEADERS`, `DATAGRAM` -> `DATA`).\r\n  - Simpler and more flexible, but possibly confusing.",
      "createdAt": "2021-11-10T15:25:52Z",
      "updatedAt": "2021-11-30T17:18:32Z",
      "closedAt": "2021-11-30T17:16:50Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds more complicated than the current design, and much more complicated than the [proposed simplified design](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/115). In what way does this simplify things?",
          "createdAt": "2021-11-10T15:45:42Z",
          "updatedAt": "2021-11-10T15:45:42Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "Using that PR as a baseline, this change would eliminate most of the text in the H3 Datagrams document.  All mention of contexts, Sec-Use-Datagram-Contexts, etc. (Sections 2.1, 2.2, 6, and 9.2) would be deleted.  All discussion of Capsules (Sections 4 and 9.3) would be extracted to a separate document, as Capsules are now a framing layer used only by MASQUE, _inside_ WebTransport.  All discussion of intermediary processing (Section 4.3, much of Section 4.4) would be deleted.\r\n\r\nWe could also consider eliminating the H3_DATAGRAM setting (Sections 5 and 9.1), as there would no longer be any active use case for it independent of WebTransport.\r\n\r\nIt would also be dramatically simpler to implement for any parties that already carry a WebTransport implementation.",
          "createdAt": "2021-11-10T15:59:46Z",
          "updatedAt": "2021-11-10T16:00:42Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Remember that the complexity that we care about is the aggregate complexity of what needs to be implemented, not the complexity of this one draft in isolation. This proposal removes some complexity from this draft but introduces a large dependency; this increases overall complexity.",
          "createdAt": "2021-11-10T16:03:44Z",
          "updatedAt": "2021-11-10T16:03:44Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "I disagree.  The total amount of specification text is greatly reduced.  The total amount of code in a typical participating intermediary, client, or server is reduced in each case.  The complexity of reasoning about the system is greatly reduced, as the behavior of each component is simpler and can be analyzed independently (e.g. intermediaries don't interact with capsules and don't need to know anything about MASQUE).\r\n\r\nPerhaps a relevant question here is: do you believe a typical MASQUE implementation will live in a codebase that also carries a WebTransport implementation?  I do, so we can simplify the MASQUE design by using it.\r\n\r\nI also think there are positive ecosystem effects to consider.  If we can agree on a single thing that intermediaries have to do (\"implement WebTransport relaying\"), we are likely to get to much broader compatibility than if intermediaries have to take distinct actions for compatibility with WebTransport and MASQUE.",
          "createdAt": "2021-11-10T16:15:44Z",
          "updatedAt": "2021-11-10T16:15:44Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "On first inspection of this proposal, I do not like the idea of coupling MASQUE to WebTransport. ",
          "createdAt": "2021-11-10T16:16:28Z",
          "updatedAt": "2021-11-10T16:16:28Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I think this is intriguing and should be explored further.  \r\n\r\nI've often found it confusing that both WebTransport and masque are defining similar concepts like the CONNECT stream and how to associate datagrams with it.  Deferring those concepts to WebTransport means there's only one way to do this.\r\n\r\nFor example, I think connect-udp implemented with this proposal would result in almost identical bits being sent on the wire, so it's hard to argue that it's more complex.  It also establishes clear boundaries about where the contexts, etc, belong -- in the protocols that are layered on top.  Intermediaries that are not participating in those protocols just have to know how to relay WebTransport (translating between HTTP versions) as Ben says.  And intermediaries that are participating aren't HTTP intermediaries at all, they are WebTransport servers.\r\n\r\nIn a way, datagrams never really belonged in HTTP itself, as they have no semantic meaning to HTTP, any more than server initiated bidirectional streams do.  In the early days it wasn't clear that WebTransport would be over HTTP, so there was less similarity.  But now that it is, having WebTransport be the single way for HTTP to access QUIC transport features beyond request/response is appealing.\r\n\r\nA couple notes on the proposal itself:\r\n\r\n> In WebTransport, Datagrams are associated with Streams, not Sessions. This requires simplifying H3 Datagram's \"Quarter Stream ID\" to just \"Stream ID\".\r\n\r\nWebTransport -02 uses HTTP Datagram, so the \"Quarter Stream ID\" is implicit.  It doesn't preclude you from attaching datagrams to WebTransport client initiated bidi-streams that are not HTTP request streams, but that's most likely an oversight.  I believe the intent is for datagrams to only associated with the CONNECT stream (Session).\r\n\r\n> UDP and IP proxy services only use Bidirectional Streams.\r\n\r\nWhy can they not also send datagrams?\r\n",
          "createdAt": "2021-11-10T17:38:16Z",
          "updatedAt": "2021-11-10T17:38:16Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I've often found it confusing that both WebTransport and masque are defining similar concepts like the CONNECT stream and how to associate datagrams with it. Deferring those concepts to WebTransport means there's only one way to do this.\r\n\r\nThat's not the case today. Capsules and how to send datagrams are defined in draft-ietf-masque-h3-datagram, and both WebTransport and CONNECT-UDP have a dependency on it. There is only one way to do this and there's no concept that is defined twice.\r\n\r\n> For example, I think connect-udp implemented with this proposal would result in almost identical bits being sent on the wire, so it's hard to argue that it's more complex. It also establishes clear boundaries about where the contexts, etc, belong -- in the protocols that are layered on top. Intermediaries that are not participating in those protocols just have to know how to relay WebTransport (translating between HTTP versions) as Ben says. And intermediaries that are participating aren't HTTP intermediaries at all, they are WebTransport servers.\r\n\r\nImplementing a WebTransport-supporting intermediary is much more complex than implementing a datagram-supporting intermediary. You now need to implement all of the stream logic form WebTransport which CONNECT-UDP doesn't need. In the Privacy Proxy space there's interest in building CONNECT-UDP intermediaries that have no interest in WebTransport.",
          "createdAt": "2021-11-10T17:46:24Z",
          "updatedAt": "2021-11-10T17:46:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "> WebTransport -02 uses HTTP Datagram, so the \"Quarter Stream ID\" is implicit.\r\n\r\nYes.  I'm proposing a modification to HTTP Datagram, replacing \"Quarter Stream ID\" with \"Stream ID\".\r\n\r\n> > UDP and IP proxy services only use Bidirectional Streams.\r\n\r\n> Why can they not also send datagrams?\r\n\r\nYes, they can.  I meant that they don't use unidirectional streams.  Sorry if that was confusingly worded.",
          "createdAt": "2021-11-10T17:47:11Z",
          "updatedAt": "2021-11-10T17:47:11Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> There is only one way to do this and there's no concept that is defined twice.\r\n\r\nThe extended CONNECT setup and how to translate between protocol versions is defined twice, right?  Maybe the latter would be reduced to once if the H2 version of WebTransport adopts Capsules.\r\n\r\n> Implementing a WebTransport-supporting intermediary is much more complex than implementing a datagram-supporting intermediary.\r\n> In the Privacy Proxy space there's interest in building CONNECT-UDP intermediaries that have no interest in WebTransport.\r\n\r\nCan you clarify \"intermediary\" here?  Are they looking to build an endpoint that terminates the CONNECT-UDP request and forwards raw UDP datagrams?  If this is all you do, you do not need to be a full WebTransport proxy, and the code is basically the same.\r\n\r\nIf they want to have a chain of proxies, then the non-terminating \"intermediaries\" would need to understand how to translate datagrams via WebTransport across HTTP/3 datagrams capable and non-HTTP/3 capable transports.  If they have no interest beyond datagrams, you can make a minimal WebTransport proxy that sets the stream limits to 0 and only handles datagrams, and again -- same code.\r\n\r\nWhere'd you run into trouble is that these layered protocols may need a control channel, and the Capsule protocol has been created to allow them to use the CONNECT stream for this. The WebTransporty design would be a protocol specific control stream.  There you'd need the WebTransport machinery for streams, which is pretty simple over H3 but heavierweight over H2.",
          "createdAt": "2021-11-10T18:12:12Z",
          "updatedAt": "2021-11-10T18:12:12Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> The extended CONNECT setup and how to translate between protocol versions is defined twice, right? Maybe the latter would be reduced to once if the H2 version of WebTransport adopts Capsules.\r\n\r\nYou're right, I was assuming a world where WebTransport-over-h2 uses capsules.\r\n\r\n> Can you clarify \"intermediary\" here?\r\n\r\nI was using the definition from [the CONNECT-UDP draft](https://datatracker.ietf.org/doc/html/draft-ietf-masque-connect-udp-06#section-1.1), which would be the \"non-terminating intermediary\" from your last comment.\r\n\r\n> If they want to have a chain of proxies, then the non-terminating \"intermediaries\" would need to understand how to translate datagrams via WebTransport across HTTP/3 datagrams capable and non-HTTP/3 capable transports. If they have no interest beyond datagrams, you can make a minimal WebTransport proxy that sets the stream limits to 0 and only handles datagrams, and again -- same code.\r\n\r\nSo you're saying we put MASQUE over WebTransport and then have MASQUE only implement a part of WebTransport. What's the value in pulling in WebTransport then?\r\n\r\n> Where'd you run into trouble is that these layered protocols may need a control channel, and the Capsule protocol has been created to allow them to use the CONNECT stream for this. The WebTransporty design would be a protocol specific control stream. There you'd need the WebTransport machinery for streams, which is pretty simple over H3 but heavierweight over H2.\r\n\r\nWebTransport and CONNECT-IP both need a control stream for operation of their base protocol, and CONNECT-UDP will most likely need one for extensibility. If you're suggesting we scrap capsules and have them all build their own control stream, that's not going to improve complexity.",
          "createdAt": "2021-11-10T20:28:36Z",
          "updatedAt": "2021-11-10T20:28:36Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "I can believe that there may be a need for single-purpose CONNECT-UDP intermediaries.  However, if we believe these intermediaries will normally be implemented using a general-purpose H3 server framework (e.g. Envoy), then the codebase will likely already contain a WebTransport forwarder, and we aren't helping anyone by not using it.\r\n\r\nI also don't see a lot of complexity in H3->H3 WebTransport forwarding, especially if we fully remove Capsules from WebTransport-H3.  H3<->H2 forwarding is complicated, but basically similar in all the different proposals.  The important thing (it seems we agree) is to avoid specifying it twice.\r\n\r\n> WebTransport and CONNECT-IP both need a control stream for operation of their base protocol, and CONNECT-UDP will most likely need one for extensibility.\r\n\r\nThis works fine within the proposal here.  The default stream type for CONNECT-IP (created by `INIT`) would allow some more capsule types for all the address management stuff.  If you don't like `INIT`, you could possibly send all those capsules on the CONNECT stream (in H3), and use its associated Datagrams for packets.  The other WebTransport streams would be used for extensibility, i.e. non-default format types,  As @afrind noted, this would allow a baseline-only MASQUE service to implement a subset of WebTransport.",
          "createdAt": "2021-11-10T21:54:31Z",
          "updatedAt": "2021-11-10T21:54:31Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "You're saying you get simplicity by removing capsules, and then you add `INIT` `ACK` `DATAGRAM` TLVs which are basically capsules. So it's unclear to me what complexity is saved by removing capsules, which probably means I'm not understanding the proposal here. @bemasc could I ask to show me the wire interactions (something like what we have in the [examples appendix](https://datatracker.ietf.org/doc/html/draft-ietf-masque-h3-datagram-05#appendix-A)) for these two scenarios?\r\n1. \"vanilla\" CONNECT-UDP without any extensions\r\n2. CONNECT-UDP with an extension such as your PMTUD extension",
          "createdAt": "2021-11-10T22:06:33Z",
          "updatedAt": "2021-11-10T22:06:33Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "> You're saying you get simplicity by removing capsules\r\n\r\nNo, I'm saying you get overall simplicity by removing Contexts, which duplicate the functionality of WebTransport Streams.  Capsules are relocated from H3 Datagram to \"MASQUE\", simplifying H3 Datagrams but not MASQUE.  Both #115 and this proposal start with 3 capsule types and expect more to be defined.\r\n\r\nHere are some interaction diagrams.  These show interaction on top of the WebTransport layer.  That could be considered cheating, but I'm assuming that a WebTransport implementation is available.\r\n\r\n1. Vanilla CONNECT-UDP\r\n~~~\r\nClient                                             Server\r\n\r\nWT_STREAM:             -------->\r\n  Stream ID = 44\r\n  Payload = INIT + DATAGRAM(UDP Payload)\r\n\r\n                <--------  WT_STREAM: \r\n                             Stream ID = 44\r\n                             Payload = ACK(error=0)\r\n\r\n/* Wait for target server to respond to UDP packet. */\r\n\r\n                <--------  WT_DATAGRAM:\r\n                             Stream ID = 44\r\n                             Payload = UDP Payload\r\n~~~\r\n\r\n2. CONNECT-UDP with the PING extension\r\n~~~\r\nClient                                             Server\r\n\r\nWT_STREAM:             -------->\r\n  Stream ID = 48\r\n  Payload = INIT_EXTENDED(Format=PING)\r\n\r\n                <--------  WT_STREAM: \r\n                             Stream ID = 48\r\n                             Payload = ACK(error=0)\r\n\r\nWT_DATAGRAM:           -------->\r\n  Stream ID = 48\r\n  Payload = PING(1234, \"blahblahblah\")\r\n\r\n                <--------  WT_DATAGRAM:\r\n                             Stream ID = 48\r\n                             Payload = PING(1235, \"\")\r\n~~~",
          "createdAt": "2021-11-11T16:32:54Z",
          "updatedAt": "2021-11-11T16:32:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't understand how this proposal allows a simple way to run multiple tunnels over a single QUIC connection. Can you explain how it would be supported to, for example, open multiple independent connections to e.g. conn-N.example.com for N up to 10? How can errors the server encounters opening tunnels be reflected back to the client (e.g. NXDOMAIN, or other such problems)?",
          "createdAt": "2021-11-11T16:40:30Z",
          "updatedAt": "2021-11-11T16:40:30Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "@LPardue In this proposal, each tunnel would be a separate WebTransport \"session\".  WebTransport supports multiplexing many sessions over a single HTTP/3 connection.  (I'm not sure if this was always true, but it's true in the latest draft.)  Errors could be reflected in the HTTP status code.  (This proposal does not alter the URL format used for CONNECT-UDP or CONNECT-IP.)",
          "createdAt": "2021-11-11T16:44:47Z",
          "updatedAt": "2021-11-11T16:44:47Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the clarification. I have concerns on how easy it would be to conflate webtransport for application services and for proxying services, that might be able to be solved with design changes, not sure. \r\n\r\nI would also be concerned about how many resources an HTTP/3 server might need to allocate to allowing sufficient bidirectional streams for WebTransport sessions, and conventional CONNECT streams. In contrast, the current design of HTTP datagrams and CONNECT-UDP mean is more straightforward to add CONNECT(-UDP) to an extant form of proxy server.",
          "createdAt": "2021-11-11T17:10:30Z",
          "updatedAt": "2021-11-11T17:10:30Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "What's the memory cost of an idle stream?  Is it significant?",
          "createdAt": "2021-11-11T17:23:45Z",
          "updatedAt": "2021-11-11T17:23:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "My concern is more that, right now I can bound the number of concurrent CONNECT(-UDP) streams easily by managing the concurrent stream limit (in either H2 or H3). In a WebTransport server, I would need to possibily also accomodate the additional bidi streams that can be latched onto web transport sessions. I'm assuming that in this proposal, MASQUE would actually need them. But if I'm standing up a webtransport service, then it isn't clear to me how clients might need to mix different actual usage of the webtransport sessions. That makes capacity planning harder that it is already for this use case. \r\n\r\nThis concern probably reflects more on the WebTransport design more than anything, but illustrates a concern we would place on proxy deployments that don't even have to worry about it today.",
          "createdAt": "2021-11-11T17:30:03Z",
          "updatedAt": "2021-11-11T17:30:03Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "Interesting.  However, as you hint, a better solution might be to make SETTINGS_ENABLE_WEBTRANSPORT an integer, the maximum number of open WebTransport sessions allowed.  That would allow _improved_ control over proxy resource usage.",
          "createdAt": "2021-11-11T17:57:31Z",
          "updatedAt": "2021-11-11T17:57:31Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc your second example from https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/123#issuecomment-966445450 is incomplete. \"CONNECT-UDP with the PING extension\" needs the ability to send both UDP payloads and pings, not just pings. I'm interested in understanding how demultiplexing works",
          "createdAt": "2021-11-11T18:24:49Z",
          "updatedAt": "2021-11-11T18:24:49Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi It's just Example 1 again, unmodified, so I didn't want to duplicate it.  Demultiplexing within a Session is by Stream ID.",
          "createdAt": "2021-11-11T18:38:18Z",
          "updatedAt": "2021-11-11T18:38:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, thanks for explaining. I think I understand the proposal now. If one accepts your premise that \"WebTransport is deployed everywhere, MASQUE arrives after that\", then your solution makes sense. I completely reject the premise though, as it doesn't match reality.",
          "createdAt": "2021-11-11T18:42:32Z",
          "updatedAt": "2021-11-11T18:42:48Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "This issue has reframed for me the way I think about CONNECT-UDP and CONNECT-IP.\r\n\r\nCONNECT-UDP is a subset of the WebTransport functionality that piggybacks a control stream on the CONNECT stream, and disallows other kinds of streams.  WebTransport could certainly provide required functionality.  David may be right that coupling could slow adoption because WebTransport has more moving pieces.  Lucas raises a good point that managing resources for those pieces is more complex too.\r\n\r\nI wonder how we think about what other applications might try to use H3-Datagram rather than WebTransport to leverage datagrams within an HTTP connection, and if we think any of those are good ideas.",
          "createdAt": "2021-11-11T22:12:24Z",
          "updatedAt": "2021-11-11T22:12:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "This has been supplanted by the proposal in #124.",
          "createdAt": "2021-11-30T17:16:50Z",
          "updatedAt": "2021-11-30T17:18:32Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "I_kwDODOpKfc4_OWdc",
      "title": "Zero-Latency Extensibility",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/125",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We've been discussing this topic on the [design team PR](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124#discussion_r751879354) and on the [RELIABLE_DATAGRAM issue](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/111), but @martinthomson rightly points out that this deserves its own issue.\r\n\r\n# Motivation\r\n\r\nThere is interest in deploying extensions to protocols that use HTTP Datagrams. Some of these extensions require the ability to send multiple types of HTTP datagrams associated with a single request stream. For example,\r\n* an extension to CONNECT-UDP that allows measuring the HTTP Datagram MTU\r\n* an extension to CONNECT-IP that allows compressing IP headers\r\n\r\nThis means that when these extensions are in use, HTTP Datagrams carry an identifier that allows the receiver to know what kind of HTTP Datagram it's receiving (e.g. \"is this a UDP payload or an MTU probe?\" or \"is this a full IP packet or a compressed one?\").\r\n\r\nOne potential solution is to have CONNECT-UDP and CONNECT-IP require their HTTP Datagrams to always start with an identifier. This has the unfortunate downside of wasting a byte for requests that do not use extensions, and also precludes WebTransport from using extensions in the future.\r\n\r\nAlternatively,  we could define an optional extension to HTTP Datagrams which has the advantage of not wasting bytes when not in use, and allows any protocol relying on HTTP Datagrams to use it if chooses to at any point in the future. This extension would be negotiated via an HTTP header.\r\n\r\n# Requirement: Zero-Latency Extensibility\r\n\r\nLet's assume we are going with the model of an optional extension to HTTP Datagrams. Since this is optional, a client will not know whether it is supported by the server until it receives the response headers. \"Zero-Latency Extensibility\" is the ability for a client to send HTTP Datagrams (both the \"regular\" datagram that's the default one from the request, and the \"extension\" datagrams). Note that this doesn't apply to the server because the server doesn't send HTTP Datagrams until after it's parsed the request headers. Let's call the flight of frames and/or packets that go alongside the HTTP request headers the \"first flight\". The requirement is for the client to be able to send both \"regular\" and \"extension\" HTTP datagrams with its first flight, and to have the server parse them as follows: if the server supports the extension, the server can correctly parse both \"regular\" and \"extension\" HTTP datagrams from the first flight; if the server doesn't support the extension, the server can correctly parse the \"regular\" datagrams and drop the \"extension\" ones.\r\n\r\n# Requirement: Unmodified Intermediaries\r\n\r\nIntermediaries shouldn't have to know or care about this extension. All that intermediaries need to do is blindly convert between QUIC DATAGRAM frames and DATAGRAM capsules regardless of any extension being used. This puts one constraint on the solution: QUIC DATAGRAM frames and DATAGRAM capsules need to have the same semantics because they can get converted between one another by intermediaries.\r\n\r\n# Solution\r\n\r\nSolving this problem once the headers is exchanged is pretty straightforward: if both endpoints support the extension, then datagrams start with an identifier. Otherwise, they don't contain the identifier. Getting this to work before the response headers are received is slightly more tricky: it requires having a way to distinguish between datagrams sent before the headers were received and ones sent after. The simplest way to distinguish them is to define two capsules and use the capsule type to tell us which is which.\r\n\r\nThe datagram context extension works as follows: it is negotiated by adding a header to both request and response, and when both endpoints support it, it adds a context ID varint at the start of the HTTP Datagram Payload field.\r\n\r\nNow, in order to achieve zero-latency extensibility, the client needs to be able to send datagrams before receiving the server headers in such a way that the server can correctly parse them (if you add the context ID and the server doesn't support the extension, you don't want the server to parse the context ID as part of the payload).\r\n\r\nSo here's my idea for how to accomplish that. The extension says the following:\r\n- clients that support the extension are not allowed to send QUIC DATAGRAM frames nor DATAGRAM capsule before they've received the server headers\r\n- the extension defines a new RELIABLE_DATAGRAM_EXT capsule that can be sent before and after receiving server headers\r\n```\r\nExtended Reliable Datagram Capsule {\r\n  Type (i) = RELIABLE_DATAGRAM_EXT,\r\n  Length (i),\r\n  Context ID (i),\r\n  HTTP Datagram Payload (..),\r\n}\r\n```\r\n- the extension does not change the semantics of the RELIABLE_DATAGRAM capsule, that still does not contain a Context ID\r\n```\r\nReliable Datagram Capsule {\r\n  Type (i) = RELIABLE_DATAGRAM,\r\n  Length (i),\r\n  HTTP Datagram Payload (..),\r\n}\r\n```\r\n- when both endpoints support the extension (after receiving headers) the extension changes the semantics of both the QUIC DATAGRAM frame and DATAGRAM capsule to include a Context ID at the start:\r\n```\r\nDatagram Capsule {\r\n  Type (i) = DATAGRAM,\r\n  Length (i),\r\n  Context ID (i),\r\n  HTTP Datagram Payload (..),\r\n}\r\nHTTP/3 Datagram { // contents of QUIC DATAGRAM frame\r\n  Quarter Stream ID (i),\r\n  Context ID (i),\r\n  HTTP Datagram Payload (..),\r\n}\r\n```\r\n- if the client wishes to use zero-latency extensibility, it can send RELIABLE_DATAGRAM and RELIABLE_DATAGRAM_EXT before receiving the server headers. Both of these will be parsed correctly by servers, whether or not the server supports the extension.\r\n\r\nAll of this relies on the fact that there is one bit that differentiates the DATAGRAM capsule from the RELIABLE_DATAGRAM capsule (the bit is in the capsule type), so that the extension can give the two capsules different semantics in a way that is backwards compatible.\r\n\r\nI'm realizing that calling this RELIABLE_DATAGRAM tied zero-latency extensibility to #111. This would work just as well if we renamed RELIABLE_DATAGRAM to EARLY_DATAGRAM or UNEXTENDED_DATAGRAM.",
      "createdAt": "2021-11-23T00:41:34Z",
      "updatedAt": "2021-11-29T16:07:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> One potential solution is to have CONNECT-UDP and CONNECT-IP require their HTTP Datagrams to always start with an identifier. This has the unfortunate downside of wasting a byte for requests that do not use extensions\r\n\r\nI don't view it as waste.  I view it as the (extremely low) cost of simple and performant 0-RTT extensibility.  When you make mechanisms complex, the may solve problems on paper, but no one will use them -- see HTTP/2 Priorities.  Is there a more concrete argument for how this byte will cause performance problems for users of unextended CONNECT-UDP or CONNECT-IP? \r\n\r\n> and also precludes WebTransport from using extensions in the future.\r\n\r\nIf WebTransport might ever want to change the layout of H3 Datagrams, it should add an identifier now.  ",
          "createdAt": "2021-11-23T01:38:14Z",
          "updatedAt": "2021-11-23T01:38:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I'm with Alan on this.  This design is considerably more complex and forces clients into using reliable, ordered transfer for ~1RTT if they want to use extensibility.  Spending the byte or so on a type discriminator is far simpler.\r\n\r\nFor WebTransport, I doubt we'll need this.  We hand off responsibility for the content of datagrams to applications.  And then there is always the possibility of a WebTransport version 2.  (Here, I am forced to acknowledge that protocol negotiation with extended CONNECT is likely a complete disaster, but now we're far enough into speculative territory that I'm OK with that risk.)",
          "createdAt": "2021-11-23T01:43:18Z",
          "updatedAt": "2021-11-23T01:43:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Separately,\r\n\r\n> Note that this doesn't apply to the server because the server doesn't send HTTP Datagrams until after it's parsed the request headers.\r\n\r\nThat presumes that the negotiation of extensions that modify the payload of datagrams occurs atomically.  If the extension is not negotiated atomically and uses capsules that are sent after the request, then a server might process a request and send DATAGRAM frames ignorant of the potential for extensions to be used.  That creates an ambiguity at the client.  The client cannot know if the server has not understood the extension (so that the datagram doesn't include a context/type/usage field) or whether it is using the extension (so that it does) when it receives the first DATAGRAM frame, which is likely to arrive before any negotiation signals.  That means that the server also has to follow the pattern of sending datagrams as part of the stream, with the various markings you have, unless you bind the processing of extensions into the HTTP request header fields.  \r\n\r\nThere's no mention of how these extensions are negotiated here, so I assume that you are planning to use HTTP header fields in order to get this.  My thought would be that it is easier to do that sort of negotiation with capsules, which is what previous versions of the draft did.\r\n\r\nThat this comes with this constraint on how extensions are negotiated or used makes it less appealing.\r\n",
          "createdAt": "2021-11-23T03:21:06Z",
          "updatedAt": "2021-11-23T03:21:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson sorry for being unclear. Whether or not contexts are in use (by which I mean \"does the payload start with a context ID varint?\")  is negotiated via an HTTP header. That occurs atomically. Subsequently, capsules are used to assign semantics to a given context. There's no ambiguity on the receiver there, because if you receive a datagram for context 4 and you haven't received or understood what context 4 means you can just drop that datagram.",
          "createdAt": "2021-11-23T20:51:56Z",
          "updatedAt": "2021-11-23T20:51:56Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that it's much simpler to just always have the context ID be present for protocol that want to be able to tag different datagrams. This means there's no complexity about when unreliable datagrams are allowed to be sent, or dealing with headers to try to guess how to interpret payloads. It's much more deterministic and will be less prone to implementation bugs.",
          "createdAt": "2021-11-28T21:46:01Z",
          "updatedAt": "2021-11-28T21:46:01Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Since both David and Tommy specifically mentioned \"Context ID\", I'll point out that the identifier could be the context ID as currently specified in the drafts, but alternate designs are possible.",
          "createdAt": "2021-11-29T16:07:07Z",
          "updatedAt": "2021-11-29T16:07:07Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "I_kwDODOpKfc4_oL1k",
      "title": "Handling of unrecognized capsule types",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/126",
      "state": "OPEN",
      "author": "bemasc",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "With #124 and https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/70, there is no longer a CLOSE_CONTEXT_ID Capsule, with its associated error codes.  H3 Datagram still says that unknown capsule types must be ignored.  This creates a dilemma: if I send a capsule like REGISTER_FOO_CONTEXT, acknowledged by a REGISTER_FOO_ACK response, how do I know if it worked?  If the REGISTER_FOO_CONTEXT capsule is ignored, I will have to wait indefinitely for the ACK, or set a timeout (yuck).\r\n\r\nThere are a few different ways to solve this, but I think the cleanest is the REGISTER_DATAGRAM_CONTEXT capsule type from the (published) H3 Datagram draft.  CONNECT-IP and CONNECT-UDP can make that capsule type mandatory to implement, so we don't need to worry about whether the other side supports it.\r\n\r\nThis also highlights why we need a \"Datagram Contexts\" draft supporting CONNECT-UDP and CONNECT-IP.  We need the \"Datagram Format Types\" concept, the CLOSE_DATAGRAM_CONTEXT capsule type, and all the other bits.  We could paste all of this into CONNECT-UDP, but I don't think we want to cross-reference it out of CONNECT-UDP every time we need to define a new extension or format.",
      "createdAt": "2021-11-30T17:31:18Z",
      "updatedAt": "2021-12-01T20:36:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "@tfpauly From yesterday's meeting I recall you were less interested in opening a new draft for Datagram Format Contexts.  How do you think we should resolve this problem?",
          "createdAt": "2021-11-30T17:33:25Z",
          "updatedAt": "2021-11-30T17:33:25Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc My suggestion is that CONNECT-UDP and CONNECT-IP both define that they use a varint as the first field in the datagram body, which is an identifier that capsules can register, and then various extensions define their own formats. Each new capsule/datagram extension would define its own Datagram Payload format.\r\n\r\nI strongly feel that we shouldn't have a generic REGISTER_DATAGRAM_CONTEXT or CLOSE_DATAGRAM_CONTEXT, since then you just need another registry of types within that. The capsule registry itself is sufficient.\r\n\r\nEach extension can define for itself the capsules it needs. Not all extensions need the ability to ack or close, but some do. So, if your extension needs to be have ACKs and CLOSE, define that. If you don't, don't.\r\n\r\nYou could have:\r\nREGISTER_FOO_CONTEXT\r\nACK_FOO_CONTEXT\r\nCLOSE_FOO_CONTEXT\r\n\r\nAnd for some other extension:\r\n\r\nREGISTER_BAR_CONTEXT\r\nCLOSE_BAR_CONTEXT\r\n\r\nAnd maybe for another, just a register:\r\n\r\nREGISTER_XYZ_CONTEXT",
          "createdAt": "2021-11-30T17:40:22Z",
          "updatedAt": "2021-11-30T17:40:22Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "@tfpauly OK, so I send you a REGISTER_FOO_CONTEXT and then I wait for ACK_FOO_CONTEXT to confirm.  How long do I wait before concluding that you don't support FOO, and dropped the capsule as unrecognized?",
          "createdAt": "2021-11-30T17:41:49Z",
          "updatedAt": "2021-11-30T17:41:49Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "You can use request headers that are expected to be echoed in responses to indicate if the other supports the extension at all.\r\n\r\nAlternatively, there could be a generic \"I didn't understand your capsule type\" error. I think that's better than trying to generalize context-specific errors.",
          "createdAt": "2021-11-30T17:44:37Z",
          "updatedAt": "2021-11-30T17:44:37Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "OK.  I would prefer the second option, to avoid request bloat.  That would require updating H3 Datagram with an UNKNOWN_TYPE capsule, containing a varint, emitted in response to any unrecognized capsule.\r\n\r\nThis still doesn't address the other registration failure modes we've considered (e.g. malformed request, context limit reached).  I would prefer not to have to duplicate those concepts for every extension we define, but I can tolerate it if necessary.",
          "createdAt": "2021-11-30T17:57:12Z",
          "updatedAt": "2021-11-30T17:58:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "HTTP headers are the best mechanism to establish support for extensions. I don't think we need anything generic here, we could revisit that if we see multiple extensions duplicating work though. ",
          "createdAt": "2021-11-30T19:14:15Z",
          "updatedAt": "2021-11-30T19:14:15Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "I've drawn up an example ([see here](https://bemasc.github.io/h3-datagram-ping/bemasc-timestamp-designteam/draft-schwartz-masque-h3-datagram-ping.html)) of how I think PING and TIMESTAMP extensions would work in this model (no generic registration, support negotiated by headers).  It can be done!\r\n\r\nIn my view, the lack of any generic signaling for context creation is going to be a major pain for implementors, resulting in a lot of duplicated (or worse, almost-duplicated) code.  To streamline it, I've left out all the detailed error codes for malformed or excessive registrations, which would also have to be duplicated for each extension.\r\n\r\nI think we'll get a higher-quality standard if context lifetime management is defined and implemented once, well, instead of being redefined and reimplemented poorly for each extension.\r\n\r\nEDIT: Added the IANA registration instructions for the new HTTP headers required for each extension.  Now it's even longer!",
          "createdAt": "2021-11-30T19:56:19Z",
          "updatedAt": "2021-12-01T20:36:58Z"
        }
      ]
    },
    {
      "number": 127,
      "id": "I_kwDODOpKfc4_oe65",
      "title": "Conditions on datagram forwarding",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/127",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> An intermediary that understands the request semantics enough to know that capsules are in use MAY convert between QUIC DATAGRAM frames and DATAGRAM capsules\r\n\r\nI think that this is right, but we should be more precise about what this means.\r\n\r\nThat is, if the method is CONNECT and either:\r\n\r\n1. the intermediary understands the :protocol selection, or\r\n2. the request includes Capsule-Protocol\r\n\r\nThen the intermediary can forward DATAGRAM capsules as QUIC DATAGRAM frames or forward QUIC DATAGRAM frames as DATAGRAM capsules.\r\n\r\nThose conditions could be spelled out more clearly.",
      "createdAt": "2021-11-29T21:36:57Z",
      "updatedAt": "2021-11-30T19:05:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree. I'll add this to the [PR](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124).\r\n\r\nNote that this was filed on the wrong repository, [draft-ietf-masque-h3-datagram](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues) is the droid you're looking for.",
          "createdAt": "2021-11-29T23:56:01Z",
          "updatedAt": "2021-11-29T23:56:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oops. You should be able to move the issue.",
          "createdAt": "2021-11-30T03:57:23Z",
          "updatedAt": "2021-11-30T03:57:23Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah right, thanks! I've moved the issue.",
          "createdAt": "2021-11-30T19:05:33Z",
          "updatedAt": "2021-11-30T19:05:33Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "I_kwDODOpKfc4_ofHZ",
      "title": "Add to security considerations that it's not possible to generate CONNECT from JS",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/128",
      "state": "OPEN",
      "author": "ekr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "And point to https://fetch.spec.whatwg.org/#methods\r\n\r\nThis is an important part of the security analysis.",
      "createdAt": "2021-11-29T21:11:59Z",
      "updatedAt": "2021-12-02T23:48:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Only if you believe that the Sec- prefix is useful for the Capsule-Protocol header field.  I don't.",
          "createdAt": "2021-11-29T21:18:51Z",
          "updatedAt": "2021-11-29T21:18:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "Sorry, I don't mean that it's the only thing that makes it work, merely that if were going to talk about how to analyze it, this is something we should say.",
          "createdAt": "2021-11-29T21:30:43Z",
          "updatedAt": "2021-11-29T21:30:43Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr can you clarify your intent? Your issue title starts with \"Add to JS\" but I suspect you didn't mean that we should modify the JavaScript specification. Would a note next to where the \"Capsule-Protocol\" header is defined resolve this?",
          "createdAt": "2021-11-29T23:51:29Z",
          "updatedAt": "2021-11-29T23:51:29Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "Aaargh. I meant \"add to the security considerations\". ",
          "createdAt": "2021-11-29T23:54:41Z",
          "updatedAt": "2021-11-29T23:54:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, that makes more sense :) Adding something to security considerations sounds good to me, I'll add text to the [PR](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124).\r\n\r\nNote that this was filed on the wrong repository, [draft-ietf-masque-h3-datagram](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues) is the droid you're looking for.",
          "createdAt": "2021-11-30T00:15:07Z",
          "updatedAt": "2021-11-30T00:15:07Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this assumption is useful in that it helps us avoid an analysis.  Though my sense is that that analysis isn't especially difficult.  The header field exists to enable datagram forwarding behaviour in an intermediary.  We only have to show that there is no harm inflicted if a client engages that behaviour for requests, under the constraint that the client is otherwise authorized to make from a web context.  The risk comes if this forwarding behaviour somehow generates different semantics as a result.  As the same client also provides the stream of data that will be forwarded, it is trivial to see that they are already in a position to engage whatever semantics they choose.  The only scenario that might benefit an attacker is where the elision of datagrams (or things that look like them) might be used to evade security protections that scan the stream of data.  For an attack to be effective, those same protections would have to be ignorant of datagram forwarding behaviour at the same intermediary.\r\n\r\nThis binding to CONNECT is a useful shortcut that means we don't need to engage with all that stuff, which wouldn't be that easy to write down. (This aversion to engagement is, I believe, a large part of why people want to slap \"Sec-\" on all new headers.)",
          "createdAt": "2021-12-01T23:56:54Z",
          "updatedAt": "2021-12-01T23:56:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "MT's framing of this is helpful. \r\n\r\nAdding some security consideration about what might go wrong for an intermediary seems potentially useful. Spending text on why a browser is special in this regard seems less compelling to nme.",
          "createdAt": "2021-12-02T01:59:38Z",
          "updatedAt": "2021-12-02T01:59:38Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I was about to write a PR for this, but I think we should first resolve #129. If we decide that capsules are only allowed for HTTP upgrade tokens (and not new methods) then we've restricted ourselves to CONNECT and Upgrade which are both inaccessible from JavaScript.",
          "createdAt": "2021-12-02T23:48:21Z",
          "updatedAt": "2021-12-02T23:48:21Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "I_kwDODOpKfc4_opWf",
      "title": "Do not allow capsules for new methods",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/129",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec currently says:\r\n\r\n> This specification defines the \"data stream\" of an HTTP request as the bidirectional stream of bytes that follow the headers in both directions. In HTTP/1.x, the data stream consists of all bytes on the connection that follow the blank line that concludes either the request header section, or the 2xx (Successful) response header section. In HTTP/2 and HTTP/3, the data stream of a given HTTP request consists of all bytes sent in DATA frames with the corresponding stream ID. The concept of a data stream is particularly relevant for methods such as CONNECT where there is no HTTP message content after the headers.\r\n\r\nIn HTTP/1.x, the message content is generally delineated by the Content-Length header field or the `chunked` Transfer-Encoding; another request can follow on the same connection.  One of the (many) ways in which CONNECT and Upgrade are special is that in H1 it takes over the connection and makes the request extend to the end of the connection, preventing any further requests from being made.\r\n\r\nThe description attempts to be generic about method, but implicitly assumes an indefinite length stream of bytes which (in H1) is only true of CONNECT or Upgrade.  This concept is correct for what we have in mind, but the boundaries aren't crisply described right now.\r\n\r\n@royfielding may have opinions.",
      "createdAt": "2021-11-30T19:56:33Z",
      "updatedAt": "2021-12-02T23:46:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The sentence right after the bit you pasted is:\r\n\r\n> Definitions of new HTTP Methods or of new HTTP Upgrade Tokens can state that their data stream uses the Capsule Protocol.\r\n\r\nThat constrains this to CONNECT/Upgrade/new methods. Is that not enough?",
          "createdAt": "2021-11-30T20:01:26Z",
          "updatedAt": "2021-11-30T20:01:26Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think \"new methods\" is probably the most questionable.  It's not clear to me that a new method can obtain the special behaviors of CONNECT.  If it were restricted to upgrade tokens (whether with HTTP/1.1 Upgrade or RFC 8441 Extended CONNECT), I think that would address the concern.",
          "createdAt": "2021-11-30T20:05:14Z",
          "updatedAt": "2021-11-30T20:05:14Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "I believe what he means is this definition of a data stream only holds for CONNECT requests. There is no mechanism to extend that to new request methods since all other methods are required to have length-delimited data (or no data).",
          "createdAt": "2021-11-30T20:05:21Z",
          "updatedAt": "2021-11-30T20:05:21Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "Likewise, I don't know of any reason we would want to support such extension methods in the future, since that is a known failure point for CONNECT. It is far simpler for a new method to require chunked or data frames.",
          "createdAt": "2021-11-30T20:07:16Z",
          "updatedAt": "2021-11-30T20:07:16Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Restricting this to extended CONNECT and Upgrade sounds reasonable to me",
          "createdAt": "2021-11-30T20:07:42Z",
          "updatedAt": "2021-11-30T20:07:42Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "For Upgrade, the new protocol takes over after the current response is complete. Hence, the description above doesn't really work for Upgrade either.",
          "createdAt": "2021-11-30T20:11:34Z",
          "updatedAt": "2021-11-30T20:11:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@royfielding the intent of that text was to mean \"after the current response is complete\" - do you have a proposal for phrasing that would work better?",
          "createdAt": "2021-11-30T20:13:42Z",
          "updatedAt": "2021-11-30T20:13:42Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Semantics says:\r\n\r\n> The capabilities and nature of the application-level communication after the protocol change is entirely dependent upon the new protocol(s) chosen. However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).\r\n>\r\n> For example, if the Upgrade header field is received in a GET request and the server decides to switch protocols, it first responds with a 101 (Switching Protocols) message in HTTP/1.1 and then immediately follows that with the new protocol's equivalent of a response to a GET on the target resource. This allows a connection to be upgraded to protocols with the same semantics as HTTP without the latency cost of an additional round trip. A server must not switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.\r\n>\r\n>The following is an example response to the above hypothetical request:\r\n>\r\n>     HTTP/1.1 101 Switching Protocols\r\n>     Connection: upgrade\r\n>     Upgrade: websocket\r\n>     \r\n>     [... data stream switches to websocket with an appropriate response\r\n>     (as defined by new protocol) to the \"GET /hello\" request ...]\r\n\r\n...which I think is consistent with the definition of \"data stream\" in this document. (And in fact uses the term \"data stream\" without defining it.)  That doesn't seem to match deferring the new protocol until after the response.",
          "createdAt": "2021-11-30T20:18:07Z",
          "updatedAt": "2021-11-30T20:18:07Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "I don't think there is any technical distinction between the two descriptions; it's nomenclature to say that what follows the CONNECT is a tunnel ended by connection closure, whereas what follows Upgrade is a different protocol that might very well come back to this one (as determined by the other protocol).",
          "createdAt": "2021-11-30T20:32:08Z",
          "updatedAt": "2021-11-30T20:32:08Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "I_kwDODOpKfc4_x5X3",
      "title": "Capsule protocol and status codes 204,205,206",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/130",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In [a PR comment](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124/files#r761469804), @MikeBishop points out that status codes 204, 205, and 206 don't make sense with the capsule protocol. Should we prohibit them?",
      "createdAt": "2021-12-02T22:39:18Z",
      "updatedAt": "2021-12-02T22:39:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 131,
      "id": "I_kwDODOpKfc4_x5dl",
      "title": "Capsule protocol and Content-Type",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/131",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In [a PR comment](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124/files#r761469804), @MikeBishop points out that Content-Type doesn't make sense with the capsule protocol. Should we prohibit it?",
      "createdAt": "2021-12-02T22:39:57Z",
      "updatedAt": "2021-12-02T22:48:09Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMwNzYxNzcz",
      "title": "Editorial nits",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/1",
      "state": "MERGED",
      "author": "erickinnear",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Minor editorial nits :)",
      "createdAt": "2019-10-22T01:02:48Z",
      "updatedAt": "2019-10-22T01:40:17Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "master",
      "baseRefOid": "d277f50bfd8f7e5b174e2dd8e9509780ad6726c6",
      "headRepository": "ekinnear/draft-h3-datagram",
      "headRefName": "ek/editorial_nits",
      "headRefOid": "32a41d0d6c9a0346d2dc071bcce8c2c117a3bfb1",
      "closedAt": "2019-10-22T01:40:17Z",
      "mergedAt": "2019-10-22T01:40:17Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b21a78cc6876789f151be3ee919c5e54cf3bd913"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0OTMzMzUy",
          "commit": {
            "abbreviatedOid": "32a41d0"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-10-22T01:40:08Z",
          "updatedAt": "2019-10-22T01:40:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg5NjM0NTc1",
      "title": "Simplify analogy",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/4",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The comparison to UDP sockets is not as good as a comparison to streams.\r\nUDP sockets are sometimes spun up in the fashion described, but they are\r\nalso often a fixed thing, such as the socket that a DNS server listens\r\non.  That evokes the wrong model in which the caller chooses and there\r\nis some possibility of persistence.",
      "createdAt": "2020-03-17T05:37:16Z",
      "updatedAt": "2020-03-17T23:25:54Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "master",
      "baseRefOid": "4d5e607970f52406318da396c21ca9b804b334af",
      "headRepository": "martinthomson/draft-h3-datagram",
      "headRefName": "conceptually-streams",
      "headRefOid": "8759f87f7661cb978b72442df931560c541c5ac0",
      "closedAt": "2020-03-17T23:25:53Z",
      "mergedAt": "2020-03-17T23:25:53Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "3f78050d80fc5a8dc214442a94310b7a6ed45df5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM5MTEyNjQy",
      "title": "editorial pass, mainly header -> header field",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/16",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-14T04:08:07Z",
      "updatedAt": "2020-12-14T20:15:21Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "1f0758e933b693bc5d317484544e462d23381b66",
      "headRepository": "LPardue/draft-h3-datagram",
      "headRefName": "editorialize-pass-1",
      "headRefOid": "b846fc303af4e3b53810dde9bd3122809b6114cc",
      "closedAt": "2020-12-14T20:15:20Z",
      "mergedAt": "2020-12-14T20:15:20Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "8984724e4a39f9c363632b1da4301c0b9bafea4c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM5NTQyNTQz",
      "title": "add Lucas to authors",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/17",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-14T15:03:19Z",
      "updatedAt": "2020-12-14T20:13:53Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "1f0758e933b693bc5d317484544e462d23381b66",
      "headRepository": "LPardue/draft-h3-datagram",
      "headRefName": "authorplusplus",
      "headRefOid": "67dd739dd39a41dcd973ac9a9e8a05cdc5a61027",
      "closedAt": "2020-12-14T20:13:53Z",
      "mergedAt": "2020-12-14T20:13:53Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "70acc6cee4b1664f411be1fb761d3558f8d67a14"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ3MDQ2MDU0",
      "title": "Make Datagram-Flow-Id a list",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/18",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR switches the header to a list on MT's suggestion to make the semantics clearer.\r\n\r\nCloses #9\r\nCloses #11\r\nCloses #12\r\nCloses #13\r\n",
      "createdAt": "2020-12-30T18:35:15Z",
      "updatedAt": "2021-09-14T16:22:29Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "12d95c99858d9eec43976133ec0e1376360745c7",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "dec2020",
      "headRefOid": "e969f3b56bd97e96bc58d7887e26f0d89b4102eb",
      "closedAt": "2021-01-05T12:26:13Z",
      "mergedAt": "2021-01-05T12:26:13Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "3d9a0aa2f9a9d4f23d7c3e2586715c7cfd953fe0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTI0NjE1",
          "commit": {
            "abbreviatedOid": "6c37b29"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-31T17:40:04Z",
          "updatedAt": "2020-12-31T18:04:45Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This is bit odd because the three top-level SF types are List, Dictionary and Item. \r\n\r\nI think you want to explain that `Datagram-Flow-Id` is a List Structured Field, whose members must be Items of type Integer",
              "createdAt": "2020-12-31T17:40:05Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nbe the first parameter of that element. The ordering of the list does not\r\n```",
              "createdAt": "2020-12-31T17:42:11Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            },
            {
              "originalPosition": 47,
              "body": "Maybe we could tweak this further to really strike home the prose? For instance, if I read carefully I think this order is also valid\r\n\r\n```\r\nDatagram-Flow-Id = 44; ecn-ect0, 42, 48; ecn-ce, 46; ecn-ect1; \r\n```\r\n\r\n",
              "createdAt": "2020-12-31T17:50:14Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            },
            {
              "originalPosition": 40,
              "body": "It's not clear to me how this works in practice.  Especially for extensibility, the current text might be too ambiguous. Are you proposing there MUST be only one parameter, that  MUST be of type boolean, and MUST be of type true? Do names have to be unique within a header field? For instance, how would you expect to process a received header like this?\r\n\r\n```\r\nDatagram-Flow-Id = 42, 44; ecn-ect0; likesdogs, 48; ecn-ce, 46; ecn-ect1,\r\n                   50; ecn-ect1; likescats=?0, 52; ecn-ect2=?0\r\n```\r\n",
              "createdAt": "2020-12-31T17:59:20Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            },
            {
              "originalPosition": 83,
              "body": "This is good. Is there something in Semantics we can cite to explain how malformed messages are handled?",
              "createdAt": "2020-12-31T18:03:42Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNzA5MDQ5",
          "commit": {
            "abbreviatedOid": "624f82f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-03T16:23:21Z",
          "updatedAt": "2021-01-03T16:23:21Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I ended up splitting the example in two: first the logical ordering then your example which nicely shows off that the unnamed can be in any position",
              "createdAt": "2021-01-03T16:23:21Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNzA5MDU5",
          "commit": {
            "abbreviatedOid": "624f82f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-03T16:23:29Z",
          "updatedAt": "2021-01-03T16:23:30Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Good call, done",
              "createdAt": "2021-01-03T16:23:30Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNzA5MTAx",
          "commit": {
            "abbreviatedOid": "624f82f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-03T16:24:11Z",
          "updatedAt": "2021-01-03T16:24:11Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Unfortunately I didn't find anything in Semantics, so I referenced 7540. It's not perfect but it'll do.",
              "createdAt": "2021-01-03T16:24:11Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNzA5MTMx",
          "commit": {
            "abbreviatedOid": "624f82f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-03T16:24:43Z",
          "updatedAt": "2021-01-03T16:24:43Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Good call, I tried to clarify the text",
              "createdAt": "2021-01-03T16:24:43Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMTc0Nzc4",
          "commit": {
            "abbreviatedOid": "624f82f"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-04T16:43:39Z",
          "updatedAt": "2021-01-04T16:43:39Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I think its simpler to write just\r\n\r\n\"Datagram-Flow-Id\" is a List Structured Field {{!STRUCT-FIELD=I-D.ietf-httpbis-header-structure}}, whose members MUST all be Items of type Integer. Its ABNF is:\"\r\n\r\n(GitHub prevents me from making this as an actual direct suggestion)",
              "createdAt": "2021-01-04T16:43:39Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMTgyNjQ2",
          "commit": {
            "abbreviatedOid": "624f82f"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-04T16:54:30Z",
          "updatedAt": "2021-01-04T17:04:18Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Structured fields uses the term \"member\" for things in the list, so you could /s/element/member or do something like coin the term \"element\" as so. I kind of like coining here, since it makes it clear that these requirements apply in addition to standard structured field requirements. But I'm not fussy.\r\n\r\n```suggestion\r\nList members are flow identifier elements, which can be named or unnamed.\r\nOne element in the list is allowed to be unnamed, but all but one elements\r\n```\r\n\r\n",
              "createdAt": "2021-01-04T16:54:30Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            },
            {
              "originalPosition": 83,
              "body": "Do flow identifiers have to use the same name (or stay unamed) across requests? I think it would help to be strict here.",
              "createdAt": "2021-01-04T17:00:29Z",
              "updatedAt": "2021-01-05T12:06:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNzM2ODM3",
          "commit": {
            "abbreviatedOid": "e969f3b"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T12:07:08Z",
          "updatedAt": "2021-01-05T12:07:09Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Oh I should have read my work more carefully, you're absolutely right. Done.",
              "createdAt": "2021-01-05T12:07:08Z",
              "updatedAt": "2021-01-05T12:07:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNzQ3NTI5",
          "commit": {
            "abbreviatedOid": "e969f3b"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T12:25:46Z",
          "updatedAt": "2021-01-05T12:25:46Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Discussed offline, the draft needs editorial work to clarify how to use names and their conceptual meaning, but we'll address that in a separate PR.",
              "createdAt": "2021-01-05T12:25:46Z",
              "updatedAt": "2021-01-05T12:25:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ4OTg3ODkw",
      "title": "Clarify 0-RTT value cannot exceed 1",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/19",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #14\ufeff\n",
      "createdAt": "2021-01-05T12:40:11Z",
      "updatedAt": "2021-01-05T12:48:32Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "3d9a0aa2f9a9d4f23d7c3e2586715c7cfd953fe0",
      "headRepository": "LPardue/draft-h3-datagram",
      "headRefName": "0-rtt-avoid-plusplus",
      "headRefOid": "92ce17d192ba5c5f6ef0c960dc42f62b82cd47c1",
      "closedAt": "2021-01-05T12:48:32Z",
      "mergedAt": "2021-01-05T12:48:32Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "c583c3e4bf9a183da0d7bbc98eae671a273023af"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNzYwMjY2",
          "commit": {
            "abbreviatedOid": "92ce17d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-05T12:48:17Z",
          "updatedAt": "2021-01-05T12:48:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ4OTkxMDY2",
      "title": "Allow retiring flow identifiers",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/20",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #10 ",
      "createdAt": "2021-01-05T12:43:15Z",
      "updatedAt": "2021-09-14T16:22:30Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "3d9a0aa2f9a9d4f23d7c3e2586715c7cfd953fe0",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "reuse",
      "headRefOid": "ba44cee6be7b4e67141704d35e8350abe4694ff3",
      "closedAt": "2021-01-05T12:53:24Z",
      "mergedAt": "2021-01-05T12:53:24Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "f9192fa1470b365b206525293f7d9c018d5d8839"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNzYxMzI0",
          "commit": {
            "abbreviatedOid": "6af48e8"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-05T12:50:04Z",
          "updatedAt": "2021-01-05T12:50:04Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\na shorter variable-length integer encoding.\r\n```",
              "createdAt": "2021-01-05T12:50:04Z",
              "updatedAt": "2021-01-05T12:52:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ4OTkzNTM4",
      "title": "frames too short for flow ID cause H3 errors",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/21",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #15\ufeff\n",
      "createdAt": "2021-01-05T12:45:41Z",
      "updatedAt": "2021-01-05T12:49:26Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "3d9a0aa2f9a9d4f23d7c3e2586715c7cfd953fe0",
      "headRepository": "LPardue/draft-h3-datagram",
      "headRefName": "h3-dgram-errors-are-h3-errors",
      "headRefOid": "6604ce8f1c39a171a550e34c03ced5a505789a04",
      "closedAt": "2021-01-05T12:49:26Z",
      "mergedAt": "2021-01-05T12:49:26Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "14e55584038ba3cd751aa559fbfde175a579f738"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNzYwODc5",
          "commit": {
            "abbreviatedOid": "6604ce8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-05T12:49:20Z",
          "updatedAt": "2021-01-05T12:49:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ5MDk5OTgy",
      "title": "Add HTTP Datagram Flow Identifier Element Names registry",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/23",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-05T14:24:36Z",
      "updatedAt": "2021-09-14T16:22:31Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "acefa05408483576a11ee7f737b2bc9a22e1f48e",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "iana_named_elements",
      "headRefOid": "6307f4908455147045702245097d5cd1033f19cf",
      "closedAt": "2021-01-05T17:06:28Z",
      "mergedAt": "2021-01-05T17:06:28Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "87e9be4e89b21a92a2ebee9eaee09c79ef589d53"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxOTIxNDM2",
          "commit": {
            "abbreviatedOid": "a884b4c"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-05T16:08:43Z",
          "updatedAt": "2021-01-05T16:08:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1ODY0ODQz",
      "title": "Split flow identifier term to flows and IDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/29",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This somewhat of an experiment. While trying to address #27 I got distracted by the document's use of the \"flow identifier\" term.\r\n\r\nThe document likes to compare \"flow identifiers\" with QUIC streams, which is fine. But QUIC makes the distinction between streams and stream IDs; the ID is a property of the stream but it isn't the only one, and sometimes it helps to talk about the stream in other contexts.\r\n\r\nThis change tries to channel a similar editorial style. It replaces:\r\n\r\n* \"flow identifiers\" with \"flows\" when talking about a logical entitiy\r\n* \"flow identifiers\" with \"flow IDs\" when talking about the wire format, encoding, examples etc.\r\n\r\nThis could be a change too far but I figured it would be a good discussion starter.",
      "createdAt": "2021-03-05T20:46:45Z",
      "updatedAt": "2021-03-08T15:27:07Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "76452b30be50f35f8b23fdc528a4fac3f511c5eb",
      "headRepository": "LPardue/draft-h3-datagram",
      "headRefName": "lucas/flows-and-flow-IDs",
      "headRefOid": "ba2565df896fbb65ade57163b958d50fb51ffcea",
      "closedAt": "2021-03-08T15:27:06Z",
      "mergedAt": "2021-03-08T15:27:06Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "eabfb327140651137c6c1053087d63dfdbdf18c5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTg4ODQ5",
          "commit": {
            "abbreviatedOid": "2c47568"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Overall I think this is a good improvement, thanks!",
          "createdAt": "2021-03-05T20:50:49Z",
          "updatedAt": "2021-03-05T20:55:49Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nnumeric value, referred to as the flow identifier (or flow ID).  A flow ID is a 62-bit integer (0\r\n```",
              "createdAt": "2021-03-05T20:50:49Z",
              "updatedAt": "2021-03-08T14:54:42Z"
            },
            {
              "originalPosition": 46,
              "body": "Do we want to call them \"flows\" or \"datagram flows\"? The second might be slightly clearer, albeit more wordy.",
              "createdAt": "2021-03-05T20:51:42Z",
              "updatedAt": "2021-03-08T14:54:42Z"
            },
            {
              "originalPosition": 72,
              "body": "Technically, you don't allocate a flow, you allocate a flow ID - which is part of what you need to do when creating a new flow. So while I like the concept of a flow in general, I think the allocation service should deal in identifiers. What do you think?",
              "createdAt": "2021-03-05T20:52:24Z",
              "updatedAt": "2021-03-08T14:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTkzMjAz",
          "commit": {
            "abbreviatedOid": "2c47568"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T20:58:11Z",
          "updatedAt": "2021-03-05T20:58:11Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "This text is liberally copied from QUIC transport stream definition. Im happy to diverge but just wanted to point that out.",
              "createdAt": "2021-03-05T20:58:11Z",
              "updatedAt": "2021-03-08T14:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTk0Nzc2",
          "commit": {
            "abbreviatedOid": "2c47568"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T21:00:40Z",
          "updatedAt": "2021-03-05T21:00:41Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I thought the same initially, I could go either way because the wordings doesn't bother me.",
              "createdAt": "2021-03-05T21:00:41Z",
              "updatedAt": "2021-03-08T14:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTk4MTUx",
          "commit": {
            "abbreviatedOid": "2c47568"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T21:06:27Z",
          "updatedAt": "2021-03-05T21:06:27Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I think this is probably the most controversial part, so I'm glad we can agree it needs discussion.\r\n\r\nFrom an implementation perspective I do allocate for flows but that is an application-context dependent property (CONNECT-UDP would setup a flow<>UDP socket mapping for instance). But you're right that this text is specifically about IDs and I think that ignoring application details in this document is probably fine.\r\n\r\nLet me sleep on things and circle back.",
              "createdAt": "2021-03-05T21:06:27Z",
              "updatedAt": "2021-03-08T14:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTk5MzE4",
          "commit": {
            "abbreviatedOid": "2c47568"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T21:08:27Z",
          "updatedAt": "2021-03-05T21:08:27Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "I can live with flow ID for consistency",
              "createdAt": "2021-03-05T21:08:27Z",
              "updatedAt": "2021-03-08T14:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTk5NjQ4",
          "commit": {
            "abbreviatedOid": "2c47568"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T21:09:02Z",
          "updatedAt": "2021-03-05T21:09:02Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Maybe we go with datagram flow then since it's slightly clearer and matches the header name?",
              "createdAt": "2021-03-05T21:09:02Z",
              "updatedAt": "2021-03-08T14:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2Mzc5NzA0",
          "commit": {
            "abbreviatedOid": "ba2565d"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-08T14:58:42Z",
          "updatedAt": "2021-03-08T14:58:42Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I've changed this to `Flow ID allocation service` throughout",
              "createdAt": "2021-03-08T14:58:42Z",
              "updatedAt": "2021-03-08T14:58:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2Mzc5OTM4",
          "commit": {
            "abbreviatedOid": "ba2565d"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-08T14:58:55Z",
          "updatedAt": "2021-03-08T14:58:56Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "agreed, done",
              "createdAt": "2021-03-08T14:58:55Z",
              "updatedAt": "2021-03-08T14:58:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2Mzg0Mzk1",
          "commit": {
            "abbreviatedOid": "ba2565d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-03-08T15:03:11Z",
          "updatedAt": "2021-03-08T15:03:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5MjgxMDk4",
      "title": "Experiment with HTTP/3 frames",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/37",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is a thought experiment aimed at seeing whether using HTTP/3 frames for H3DGRAM and CONNECT-UDP makes sense. We're not planning on merging this as-is.",
      "createdAt": "2021-03-24T00:31:24Z",
      "updatedAt": "2021-09-14T16:22:34Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "eabfb327140651137c6c1053087d63dfdbdf18c5",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "experiment_h3_frames",
      "headRefOid": "43f6970fe06c7e33129f62aff60d534d523b8f3a",
      "closedAt": "2021-05-27T01:22:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "General comment: Something you don't mention explicitly is whether it is permitted to send multiple REGISTER_DATAGRAM_FLOW_ID frames with different flow IDs on the same stream.",
          "createdAt": "2021-03-24T02:03:11Z",
          "updatedAt": "2021-03-24T02:03:11Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "@afrind For QPACK, a table is explicitly maintained, so I think things are Ok.  For h2, it's worse because the HPACK dictionary is LRU-based so if an extension frame is not supported, the dictionary gets out of sync.",
          "createdAt": "2021-03-24T22:06:01Z",
          "updatedAt": "2021-03-24T22:06:01Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "@ianswett : to clarify, you mean the QPACK table is not modified via encoded field sections.  Still, any extension that makes use of the QPACK dynamic table but doesn't properly decode all the sections will lead to state mismatch between the encoder and decoder -- the decoder still needs to send Section Acknowledgement or Stream Cancellation.  I guess it's not as bad as HPACK. \r\n\r\nI maintain that it's possible to write a safe extension to H2 or H3 that uses HPACK or QPACK dynamic tables, so long as it's guarded under SETTINGS.",
          "createdAt": "2021-03-24T22:27:34Z",
          "updatedAt": "2021-03-24T22:27:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is obsolete now that we've landed #52.",
          "createdAt": "2021-05-27T01:22:34Z",
          "updatedAt": "2021-05-27T01:22:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MjM1OTEy",
          "commit": {
            "abbreviatedOid": "dab39f2"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T01:45:34Z",
          "updatedAt": "2021-03-24T01:45:34Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "I think this needs some more explanation; what use cases motivate this freedom of extensibility?\r\n\r\nUnless there is a good reason to use QPACK I wouldn't. QPACK is for HTTP message metadata and these are clearly not those. I can predict this to cause all sorts of oddites/attacks when people try to reconstruct this field section and accidentally combine it with one reconstructed from HEADERS - or just the simple case of blocking/poisoning the QPACK dynamic table.\r\n\r\nCould we satisfy the extensibility requirements with a simple value-only field of `sf-list`?",
              "createdAt": "2021-03-24T01:45:34Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MjM5NjQ3",
          "commit": {
            "abbreviatedOid": "dab39f2"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T01:54:38Z",
          "updatedAt": "2021-03-24T01:54:38Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "I understand the spirit of the text but it seems slightly obtuse. It took a few reads and a cross-ref to CONNECT-UDP to help me. Maybe there is a some rewording to be done if we go in this direction.",
              "createdAt": "2021-03-24T01:54:38Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMDIwMDYz",
          "commit": {
            "abbreviatedOid": "dab39f2"
          },
          "author": "ianswett",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Thanks David, some initial thoughts.",
          "createdAt": "2021-03-24T17:26:22Z",
          "updatedAt": "2021-03-24T18:14:11Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Aside: I'd drop this piece of functionality and use whatever approach is agreed upon for h1 and h2.",
              "createdAt": "2021-03-24T17:26:22Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            },
            {
              "originalPosition": 88,
              "body": "This is feeling even more different from CONNECT as well as substantially different from the current design.",
              "createdAt": "2021-03-24T17:28:21Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            },
            {
              "originalPosition": 81,
              "body": "Agreed, it'd be good to understand what our extensibility requirements are here.  I can imagine a fairly wide range.",
              "createdAt": "2021-03-24T18:13:57Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMTk2MzM4",
          "commit": {
            "abbreviatedOid": "dab39f2"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T20:21:10Z",
          "updatedAt": "2021-03-24T20:46:32Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Does method always govern how DATAGRAMs are interpreted on a request/response stream?  Couldn't there be other mechanisms for specifying that?",
              "createdAt": "2021-03-24T20:21:10Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            },
            {
              "originalPosition": 81,
              "body": "I agree we should be looking at what the extensibility requirements are, and providing the appropriate degree of freedom here.\r\n\r\nI disagree that QPACK should only be used for HTTP message metadata and disallowed in extensions.  Why are we worried that this field section would be combined incorrectly with the header field section, but we're not worried about that for trailers?  Similar question for blocking/poisoning the QPACK table?",
              "createdAt": "2021-03-24T20:38:00Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            },
            {
              "originalPosition": 88,
              "body": "I think the text should also address collisions or re-use of flow IDs.  What happens if the same flow ID is registered to more than one stream?  What is the lifetime of a flow ID -- does it auto-retire at the end of a stream, or can it outlive the FIN?  If the latter, how does the receiver of this frame know that the flow ID is done and state can be removed?",
              "createdAt": "2021-03-24T20:39:48Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            },
            {
              "originalPosition": 95,
              "body": "Are datagrams coming to H1?",
              "createdAt": "2021-03-24T20:42:16Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            },
            {
              "originalPosition": 100,
              "body": "I don't think you mean 'sent over...' a frame?",
              "createdAt": "2021-03-24T20:42:51Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            },
            {
              "originalPosition": 104,
              "body": "What kinds of streams is this frame valid on?  If a flow ID can outlive a stream, how do you send it?",
              "createdAt": "2021-03-24T20:45:50Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzAzNjQz",
          "commit": {
            "abbreviatedOid": "dab39f2"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T23:12:03Z",
          "updatedAt": "2021-03-24T23:12:03Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "I don't know what these frames are in relation to HTTP semantics. They contain an encoded field section but to where does that field section apply? There are rules and documented limitiations for handling trailers https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#trailers.limitations.\r\n\r\nThis readslike a weird form of \"middlers\".\r\n\r\nMixing the use of a compression context between these HEADERS and extensions might be ok, or it might be horribly insecure. Is there precidence for extensions that have done this before?\r\n\r\nMaybe extensions can use QPACK but I want to know if H3_DATAGRAM needs to eat that complexity.",
              "createdAt": "2021-03-24T23:12:03Z",
              "updatedAt": "2021-03-24T23:47:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzE4OTcx",
          "commit": {
            "abbreviatedOid": "43f6970"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T23:48:59Z",
          "updatedAt": "2021-03-24T23:48:59Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Based on this discussion, QPACK isn't as simple as I originally thought, so I replaced it with a simple custom encoding.",
              "createdAt": "2021-03-24T23:48:59Z",
              "updatedAt": "2021-03-24T23:49:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzIxNTAy",
          "commit": {
            "abbreviatedOid": "43f6970"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T23:55:47Z",
          "updatedAt": "2021-03-24T23:55:47Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Hm, I think QPACK ended up perhaps too tightly coupled to HTTP semantics - at least it references Field Lines and Field Sections.  The specification itself is otherwise devoid of semantic meaning - it's just an encoding and compression scheme for name/value pairs.  I think it would be kind of a bummer if it couldn't be used, particularly by HTTP extensions, to convey compressed, structured metadata - like \"middlers\", etc.\r\n\r\nBut I can see @DavidSchinazi giving us a nudge to quit discussing QPACK here...",
              "createdAt": "2021-03-24T23:55:47Z",
              "updatedAt": "2021-03-24T23:55:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzI0Mjcx",
          "commit": {
            "abbreviatedOid": "43f6970"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T00:02:55Z",
          "updatedAt": "2021-03-25T00:02:56Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Oh I'm in complete agreement that HPACK/QPACK are very nice generic key-value compression schemes. It's slightly sad they are entwined with messages but that's what we've been dealt.",
              "createdAt": "2021-03-25T00:02:55Z",
              "updatedAt": "2021-03-25T00:02:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzNjgwODQ0",
          "commit": {
            "abbreviatedOid": "43f6970"
          },
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-29T21:52:58Z",
          "updatedAt": "2021-03-29T22:37:21Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Is it actually necessary to define syntax for the extension string, or would it make sense to leave it up to the extension using the datagrams (i.e. MASQUE or WebTransport)?  Also, why make it text and not binary?",
              "createdAt": "2021-03-29T21:52:58Z",
              "updatedAt": "2021-03-29T22:37:21Z"
            },
            {
              "originalPosition": 95,
              "body": "This feels weird, because this requires a party to make unilateral declarations about peer's flow IDs.  Why not just make the requester associate a flow from its side to a stream?",
              "createdAt": "2021-03-29T22:36:06Z",
              "updatedAt": "2021-03-29T22:37:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzNzQ5Mjk0",
          "commit": {
            "abbreviatedOid": "43f6970"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T00:23:34Z",
          "updatedAt": "2021-03-30T00:23:35Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I'd rather define this once instead of having each method dictate what this contains. Binary would work too, text just felt simpler.",
              "createdAt": "2021-03-30T00:23:34Z",
              "updatedAt": "2021-03-30T00:23:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzNzUwMDg5",
          "commit": {
            "abbreviatedOid": "43f6970"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T00:25:46Z",
          "updatedAt": "2021-03-30T00:25:46Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "The issue there is that you would then need some sort of acknowledgement to know when your peer has parsed that frame. The unilateral model removes the need for acknowledgements at the HTTP level (for example HTTP/2 has an ACK bit on the SETTINGS frame for this reason).",
              "createdAt": "2021-03-30T00:25:46Z",
              "updatedAt": "2021-03-30T00:25:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzNzU3OTM3",
          "commit": {
            "abbreviatedOid": "43f6970"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T00:48:46Z",
          "updatedAt": "2021-03-30T00:48:46Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I think something binary like Settings parameters has been too restrictive for extensibility. Depending exactly what extensibility people migh need, I think I'd probably still lean towards this being an encoded sf-list. This solves for many caveats of data-types and would give a nice pathway to migrate to binary Structured Fields if people really can't stomach strings in wire format.",
              "createdAt": "2021-03-30T00:48:46Z",
              "updatedAt": "2021-03-30T00:48:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NTM5OTI2",
          "commit": {
            "abbreviatedOid": "43f6970"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T17:43:27Z",
          "updatedAt": "2021-03-30T17:44:40Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "> the sender of the frame unilateraly defines the semantics it will apply to the datagrams it\r\nreceives\r\n\r\nThis feels backwards to me - my inclination is to have the sender define the semantics of datagrams it will send on a flow ID.  This is similar to how unidirectional extension streams work -- the sender-chosen stream type identifies the semantics.  \r\n",
              "createdAt": "2021-03-30T17:43:27Z",
              "updatedAt": "2021-03-30T17:44:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0Njg2ODMw",
          "commit": {
            "abbreviatedOid": "43f6970"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T20:43:42Z",
          "updatedAt": "2021-03-30T20:43:42Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "I don't think the analogy with stream types is correct. The semantics of stream types are determined by an IANA registry, whereas flow IDs are ephemeral per-connection numbers. If you reverse the direction then things break in the presence of reordering.",
              "createdAt": "2021-03-30T20:43:42Z",
              "updatedAt": "2021-03-30T20:43:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NzMyMjgw",
          "commit": {
            "abbreviatedOid": "43f6970"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T21:49:01Z",
          "updatedAt": "2021-03-30T21:49:01Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "\"I'm listening for X on Flow-ID Y\" requires a roundtrip before the sender can even send.  Saying, \"I'm sending you X on Flow-ID Y\" doesn't break in the face of reordering, you just might lose some datagrams if your stack discards datagrams with unknown Flow IDs.  The receiver can also buffer datagrams on unknown Flow IDs for a while if it's concerned about this case.\r\n\r\nConsider an extension for unreliable HTTP upload, where I send POST request headers on a stream and then the body comes in DATAGRAMs. If I've already seen the SETTINGS from the server and know it supports my extension, why do I need to wait another RTT to acquire a flow-ID?",
              "createdAt": "2021-03-30T21:49:01Z",
              "updatedAt": "2021-03-30T21:49:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEyOTk1MTMx",
      "title": "Experiment with two layers of indirection",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/38",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Similar to #37, this PR is a thought experiment aimed at seeing whether an alternate design makes sense. We're not planning on merging this as-is.\r\n\r\nThis design was inspired by a proposal by @bemasc. Ben gets the credit for the idea of using two layers of indirection here, and I take the blame for writing it down wrong.\r\n\r\nSince this is really hard to review in PR form, I've uploaded an HTML version [here](https://davidschinazi.com/stuff/draft-ietf-masque-h3-datagram.html) so I definitely suggest reading that instead.\r\n\r\nConceptually, I think this proposal is easier to reason about, and it has the advantage of requiring minimal work from intermediaries. Its downside is that the wire format is slightly less efficient because it requires another varint to be sent per datagram, but I think we can live with that.",
      "createdAt": "2021-04-11T02:18:51Z",
      "updatedAt": "2021-09-14T16:22:35Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "255935632c9247980273dfe418de8c2a4332727f",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "experiment_1_to_1",
      "headRefOid": "88e6caf21369d6986ec724d23d22550b47bf54de",
      "closedAt": "2021-05-27T01:22:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm still digesting this proposal, so take the following comments with a pinch of salt.\r\n\r\nI think the PR description glosses over some design changes and buries the lede. The major changes in this proposal seems to be that Flow IDs are no longer connection global, and Flow ID usage negotitation is no longer based on headers. If I were to reword the proposed concepts based on my understanding, we're talking about flow groups bound to each request. Flows can be added to the group during its lifetime but never retired. A flow allocation service needs only ensure uniqueness of flow IDs in a flow group. I'm failing to see why it is better to have an identifying tuple (stream-id:flow-id) instead of a global identifier (flow-id) but happy to be pointed out to why.\r\n\r\nThe examples are helpful so thanks for putting those in (I might have opinions on actually keeping them but this spec is currently weaker for not including any, I think we tracked this on a ticket already.)\r\n\r\nIf I were to summarise my understanding, this proposal replaces\r\n\r\n```\r\nHEADERS (on stream 44) {\r\n  method: CONNECT-UDP\r\n  {other headers}\r\n  datagram-flow-id: 0\r\n}\r\n```\r\n\r\nwith \r\n\r\n```\r\nHEADERS (on stream 44) {\r\n  method: CONNECT-UDP\r\n  {other headers}\r\n}\r\n\r\nRELIABLE_DATAGRAM (on stream 44) { \r\n  Flow-ID: 0\r\n  Registered-Flow-Id: 1\r\n  Extension-String: \"\"\r\n}\r\n```\r\n\r\nThe claim is that this makes it easier to reason about things, but frankly at this stage I can see it making some things harder. No longer can a MASQUE server reason about creating a tunnel based on HEADERS alone, it needs to combine that with some additional information that is delivered on the request stream but is not part of an HTTP request semantic. Such is the nature of H2/H3 frames, but I find it odd that the flow ID is described as an end-to-end signal in the same breath as being described as bound to a request context.\r\n\r\nThe surprising change I find in this design is it makes the flow registration unreliable, with a very weak suggestion to use something reliable. Can you embelish on why you picked this direction?  I'm not convinced if we want to do this flow groups thing but if we did, I find the overloading of RELIABLE_DATAGRAM unhelpful. It seems that you could combine some of this proposal with the REGISTER_DATAGRAM_FLOW_ID from #37. That would provide a clearer separation between the datagram control plane and data plane. One advantage of using a frame delivered on the request stream is that it avoids Flow-ID 0 being special case, which is ugly because it prevents requets from being made on Stream-ID 0. Another advantage is that it allows strict ordering of frames, in case we wanted to add rules about in-order flow ID usage.\r\n\r\nFinally, I'm slightly confused by how the CONNECT-IP example would work in reality if the server did not support the `\"ip=192.0.2.42,port=443\"` extension. If it drops the DATAGRAM payload silently, that seems like a sad move. I think someone (maybe Alan?) suggested somewhere that a frame-based registration design could benefit from some control-plane signal. I'm beginning to lean toward some further types of controls for flows, like an H3-layer STOP_SENDING/RESET_FLOW.\r\n\r\nTo to conclude my understanding/opinion of this proposal\r\n\r\n1. flow IDs are request-scoped, not global. I'm not sure if this is a good, bad or neutral change.\r\n1. flow IDs reservation is  done using a frame and can be done during the lifetime of a request\r\n  * This makes things gnarlier for my current implementation. It would require API changes to expose such events to an application.\r\n1. flow ID reservation could include extension strings I don't understand. If so, I have to just drop all datagrams for that flow and can't signal it back to my peer.",
          "createdAt": "2021-04-12T02:19:26Z",
          "updatedAt": "2021-04-12T02:19:26Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "Hi Lucas,\r\n\r\n>No longer can a MASQUE server reason about creating a tunnel based on HEADERS alone, it needs to combine that with some additional information that is delivered on the request stream but is not part of an HTTP request semantic.\r\n\r\nI'm not sure what you mean by \"creating a tunnel\", but note that the actual call to `bind()`, to allocate a UDP socket, can indeed be performed based on the headers alone.  (Actually, you don't even need the headers.)\r\n\r\nIt's true that, like #37, this proposal allows flows to be created at any time during CONNECT-UDP's lifetime.  This feature is not strictly necessary, but can be useful in various scenarios.  For example, it is hard to imagine how QUIC connection ID compression can work without this.\r\n\r\n> Such is the nature of H2/H3 frames, but I find it odd that the flow ID is described as an end-to-end signal in the same breath as being described as bound to a request context.\r\n\r\nHTTP requests are end-to-end: they are communicated through the intermediaries but are not _for_ the intermediaries.  They're not even version-specific.  Flows in MASQUE have these properties too.\r\n\r\n> The surprising change I find in this design is it makes the flow registration unreliable, with a very weak suggestion to use something reliable. Can you embelish on why you picked this direction?\r\n\r\nI interpreted this as \"you definitely want to use reliable registration, but technically nobody is going to enforce this requirement on you\".  I think we can adjust this easily enough.\r\n\r\n> I'm not convinced if we want to do this flow groups thing but if we did, I find the overloading of RELIABLE_DATAGRAM unhelpful. It seems that you could combine some of this proposal with the REGISTER_DATAGRAM_FLOW_ID from #37. That would provide a clearer separation between the datagram control plane and data plane.\r\n\r\nThe key claim of this design is that flows are only meaningful end-to-end, so exposing them to intermediaries is unnecessary.  From the HTTP transport's perspective, a flow-registration is just more data to be routed along with the request/response; it's only meaningful to the client and server.\r\n\r\n> One advantage of using a frame delivered on the request stream is that it avoids Flow-ID 0 being special case, which is ugly because it prevents requets from being made on Stream-ID 0.\r\n\r\nFWIW, I think \"zero is special\" is a fairly elegant common pattern.\r\n\r\n> Another advantage is that it allows strict ordering of frames, in case we wanted to add rules about in-order flow ID usage.\r\n\r\nIt's not spelled out here, but RELIABLE_DATAGRAMs would be strictly ordered, so this is still possible.\r\n\r\n> Finally, I'm slightly confused by how the CONNECT-IP example would work in reality if the server did not support the `\"ip=192.0.2.42,port=443\"` extension.\r\n\r\nI think @DavidSchinazi is implying that the listed extensions all happen to be Mandatory To Implement for the corresponding methods.  I agree, it would be good to discuss how non-mandatory extensions are negotiated.\r\n\r\n> I'm beginning to lean toward some further types of controls for flows, like an H3-layer STOP_SENDING/RESET_FLOW.\r\n\r\nThis is a key advantage of the two-layer design here.  These types of commands are only meaningful end-to-end, but without the second layer, adding new commands requires upgrading every intermediary and negotiating support in SETTINGS at each hop.",
          "createdAt": "2021-04-12T14:47:22Z",
          "updatedAt": "2021-04-12T14:47:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Hey Ben, \r\n\r\nThanks for the reply, it paints a much fuller picture. I'm still wondering how this form of design might work across HTTP/1, 2 and 3 but that is a broader question for the WG so I'll leave aside. I'm not sure how best to reply here but I'll give quoting a shot. \r\n\r\n> I'm not sure what you mean by \"creating a tunnel\", but note that the actual call to bind(), to allocate a UDP socket, can indeed be performed based on the headers alone. (Actually, you don't even need the headers.)\r\n\r\nAs my first comment, I probably had the weakest view of the proposal. Based on the current design, a MASQUE server could reject a request if, for example, it detected a bad flow ID. I realize now that some of those failure conditions just go away. So I retract my comment.\r\n\r\n> It's true that, like #37, this proposal allows flows to be created at any time during CONNECT-UDP's lifetime. This feature is not strictly necessary, but can be useful in various scenarios. For example, it is hard to imagine how QUIC connection ID compression can work without this.\r\n\r\nYep this seems like a useful extension point and something that is difficult to achieve today.\r\n\r\n> >     The surprising change I find in this design is it makes the flow registration unreliable, with a very weak suggestion to use something reliable. Can you embelish on why you picked this direction?\r\n\r\n> I interpreted this as \"you definitely want to use reliable registration, but technically nobody is going to enforce this requirement on you\". I think we can adjust this easily enough.\r\n\r\nWhy not enforce it though? What scenario benefits from an unreliable flow creation. DATAGRAMs can be lost in the network or in the application buffers. The opportunity for problems get worse when adding intermediaries.\r\n\r\n> The key claim of this design is that flows are only meaningful end-to-end, so exposing them to intermediaries is unnecessary. From the HTTP transport's perspective, a flow-registration is just more data to be routed along with the request/response; it's only meaningful to the client and server.\r\n\r\nThat explanation helps, thanks. I think this speaks to my earlier point though. It seems this is a design that adds stuff to HTTP message but is not HTTP metadata or HTTP content. So what is it? H2 and H3 frames are hop-by-hop but their contents can be forwarded without being processed by anyone but the intended recipient. An intermediary that knows how to forward a request can forward frame contents. It seems this is the desired goal of using RELIABLE_DATAGRAM for control and data planes. But my point is that you could equally define REGISTER_DATAGRAM_FLOW_ID and other control frames that behave similarly, without having to overload them as a DATAGRAM on a special flow.\r\n\r\n> FWIW, I think \"zero is special\" is a fairly elegant common pattern.\r\n\r\nWe avoided it for QUIC and HTTP/3. If every deployment of HTTP/3 DATAGRAM would have to burn the first request stream, that seems ugly to me.\r\n\r\n>>    Finally, I'm slightly confused by how the CONNECT-IP example would work in reality if the server did not support the \"ip=192.0.2.42,port=443\" extension.\r\n\r\n> I think @DavidSchinazi is implying that the listed extensions all happen to be Mandatory To Implement for the corresponding methods. I agree, it would be good to discuss how non-mandatory extensions are negotiated.\r\n\r\n>>    I'm beginning to lean toward some further types of controls for flows, like an H3-layer STOP_SENDING/RESET_FLOW.\r\n\r\n> This is a key advantage of the two-layer design here. These types of commands are only meaningful end-to-end, but without the second layer, adding new commands requires upgrading every intermediary and negotiating support in SETTINGS at each hop.\r\n\r\nI see two separate things. First, it is useful to be able to handle DATAGRAM frames with different formats, without needing all points in the change to understand how to process that format - I agree with this. Second, we can use DATAGRAM frames to carry control messages for managing datagram flows. This one I have more of a problem with, how extensible does flow management need to be? For this proposal, changes are needed to add RELIABLE_DATAGRAM support through the chain in the first instance. Adding support for other frames at the same time doesn't much more difficult.\r\n\r\n",
          "createdAt": "2021-04-12T18:49:06Z",
          "updatedAt": "2021-04-12T18:49:57Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "\r\n> > > ```\r\n> > > The surprising change I find in this design is it makes the flow registration unreliable, with a very weak suggestion to use something reliable. Can you embelish on why you picked this direction?\r\n> > > ```\r\n> \r\n> > I interpreted this as \"you definitely want to use reliable registration, but technically nobody is going to enforce this requirement on you\". I think we can adjust this easily enough.\r\n> \r\n> Why not enforce it though?\r\n\r\nI'm fine with enforcing it, so long as we're clear that enforcement only happens at the endpoints.  Intermediaries shouldn't be looking past the Quarter Stream ID.\r\n\r\n> > The key claim of this design is that flows are only meaningful end-to-end, so exposing them to intermediaries is unnecessary. From the HTTP transport's perspective, a flow-registration is just more data to be routed along with the request/response; it's only meaningful to the client and server.\r\n> \r\n> That explanation helps, thanks. I think this speaks to my earlier point though. It seems this is a design that adds stuff to HTTP message but is not HTTP metadata or HTTP content. So what is it?\r\n\r\nIn an idealized version of HTTP, I see a stack of layers: hop, cache, exchange (request/response, end-to-end), method, resource (payload/representation).  The Quarter Stream ID is part of the hop layer.  Everything past that point is owned by the exchange.  The Flow ID, commands, and extension types are at the method layer.  The content of the extensions is at the resource layer.\r\n\r\nConcretely, this means that intermediaries can forward datagrams for unrecognized methods, even if we cannot predict what requirements future methods may have for datagrams.\r\n\r\n> H2 and H3 frames are hop-by-hop but their contents can be forwarded without being processed by anyone but the intended recipient.\r\n\r\nYes, and this PR essentially defines a frame type that means \"forward this without processing unless you're the intended recipient\".\r\n\r\n> An intermediary that knows how to forward a request can forward frame contents. It seems this is the desired goal of using RELIABLE_DATAGRAM for control and data planes. But my point is that you could equally define REGISTER_DATAGRAM_FLOW_ID and other control frames that behave similarly, without having to overload them as a DATAGRAM on a special flow.\r\n> \r\n> > FWIW, I think \"zero is special\" is a fairly elegant common pattern.\r\n> \r\n> We avoided it for QUIC and HTTP/3. If every deployment of HTTP/3 DATAGRAM would have to burn the first request stream, that seems ugly to me.\r\n\r\nThe obvious alternative is to put a DatagramType varint after the Quarter Stream ID, like an H3 frame on a stream.  This costs us one byte of MTU.  I don't think it buys us anything concrete, but I'm willing to spend a byte if it makes the design feel more consistent.\r\n\r\n> > > I'm beginning to lean toward some further types of controls for flows, like an H3-layer STOP_SENDING/RESET_FLOW.\r\n> \r\n> > This is a key advantage of the two-layer design here. These types of commands are only meaningful end-to-end, but without the second layer, adding new commands requires upgrading every intermediary and negotiating support in SETTINGS at each hop.\r\n> \r\n> I see two separate things. First, it is useful to be able to handle DATAGRAM frames with different formats, without needing all points in the change to understand how to process that format - I agree with this. Second, we can use DATAGRAM frames to carry control messages for managing datagram flows. This one I have more of a problem with, how extensible does flow management need to be? For this proposal, changes are needed to add RELIABLE_DATAGRAM support through the chain in the first instance. Adding support for other frames at the same time doesn't much more difficult.\r\n\r\nExposing the concept of flows to intermediaries makes them everything much more complicated.  For example, intermediaries would need their own flow count limits to avoid memory exhaustion.  Will clients and servers be able to figure out what happened when that limit is reached?  In the case of flow cleanup commands, the commands would presumably need to be ack'd end-to-end before flows could be reused, and both the commands and the acks would need to be interpreted and translated by intermediaries.  As an intermediary, what do I do with a datagram on a mapping for which a \"stop\" command has been forwarded but the \"ack\" has not yet been observed?  This complexity is not buying us anything.\r\n\r\nExtensibility, with additional commands negotiated via SETTINGS, is even more of a mess.  If I'm a CDN reverse proxy for myriad backends with different capabilities, what commands do I claim to support?\r\n\r\nI think we're much better off if we can draw a clear, simple line between hop-by-hop and end-to-end data.",
          "createdAt": "2021-04-12T20:17:23Z",
          "updatedAt": "2021-04-12T20:17:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to respond to one specific point:\r\n\r\n>>    I see two separate things. First, it is useful to be able to handle DATAGRAM frames with different formats, without needing all points in the change to understand how to process that format - I agree with this. Second, we can use DATAGRAM frames to carry control messages for managing datagram flows. This one I have more of a problem with, how extensible does flow management need to be? For this proposal, changes are needed to add RELIABLE_DATAGRAM support through the chain in the first instance. Adding support for other frames at the same time doesn't much more difficult.\r\n\r\n> Exposing the concept of flows to intermediaries makes them everything much more complicated. For example, intermediaries would need their own flow count limits to avoid memory exhaustion. Will clients and servers be able to figure out what happened when that limit is reached? In the case of flow cleanup commands, the commands would presumably need to be ack'd end-to-end before flows could be reused, and both the commands and the acks would need to be interpreted and translated by intermediaries. As an intermediary, what do I do with a datagram on a mapping for which a \"stop\" command has been forwarded but the \"ack\" has not yet been observed? This complexity is not buying us anything.\r\n\r\nI think we might be talking across ourselves but mean the same thing. All I'm suggesting is that a REGISTER_DATAGRAM_FLOW_ID (or whatever we call it) could contain the same information as the proposed RELIABLE_DATAGRAM on flow 0. Intermediaries wouldn't process the contents of the frame, they'd just forward it on the stream.\r\n\r\nto repurpose an example\r\n\r\n\r\n```\r\n~~~\r\nClient                                             Server\r\n\r\nSTREAM(44): DATA{HEADERS}      -------->\r\n  :method = CONNECT-UDP\r\n  :scheme = https\r\n  :path = /\r\n  :authority = target.example.org:443\r\n\r\nSTREAM(44): REGISTER_DATAGRAM_FLOW_ID  -------->\r\n  Registered Flow ID = 1\r\n  Extension String = \"\"\r\n\r\nDATAGRAM                       -------->\r\n  Quarter Stream ID = 11\r\n  Flow ID = 1\r\n  Payload = Encapsulated UDP Payload\r\n\r\n           <--------  STREAM(44): DATA{HEADERS}\r\n                        :status = 200\r\n\r\n           <--------  STREAM(44): REGISTER_DATAGRAM_FLOW_ID\r\n                        Registered Flow ID = 1\r\n                        Extension String = \"\"\r\n\r\n/* Wait for target server to respond to UDP packet. */\r\n\r\n           <--------  DATAGRAM\r\n                        Quarter Stream ID = 11\r\n                        Flow ID = 1\r\n                        Payload = Encapsulated UDP Payload\r\n~~~\r\n```",
          "createdAt": "2021-04-12T22:04:06Z",
          "updatedAt": "2021-04-12T22:04:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "Got it, thanks.  I agree, that works fine.  However, I do feel that it's somewhat less elegant and much less extensible.  Ideally, I would like all data that intermediaries don't need to process to be opaque to them, so there's no ambiguity about what is hop-by-hop and what is end-to-end.  Or to put it another way: at the transport level, \"REGISTER_DATAGRAM_FLOW_ID\" and \"RELIABLE_DATAGRAM\" have the same semantics, so why define it twice?\r\n\r\nAnother way to see this is to consider HTTP/1.1 usage.  In that case, we literally need to encode the flow registration commands into the request and response bodies.  That makes it clear that these commands are part of the end-to-end resource.",
          "createdAt": "2021-04-12T22:36:02Z",
          "updatedAt": "2021-04-12T22:36:02Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC this proposal moves the flow ID registration from an always reliable transfer, to a maybe reliable one. I think that's important to call out and get group consensus. If am understanding incorrectly, then please do correct me :) Putting reliability-needed messages on a reliable stream is a no-brainer to me.\r\n\r\nGenerally we're carry traffic intended for the target server in datagrams, and we expect that tunneled protocol to run it's own loss detection algorithm if it cares. But flow 0 here is special case and is seems like it might need it's own loss detection too.\r\n\r\nAt risk of going off on a tangent, as an implementer I need to decide how to handle RELIABLE_DATAGRAM. Is it reliable just for the hop that it is being carried over, or should it be reliable all the way? This PR implies its ok to leave the reliability choice up to implementations, and I don't trust them not to have hard-to-debug problems. I.e. say we had\r\n\r\nmasque client -> intermediary A -> intermediary B -> masque server\r\n\r\nIf client sent RELIABLE_DATAGRAM to A, is A allowed to shift the contents into a DATAGRAM for transmission to B?\r\nOr what if I write an implementation that operates a shared in-memory queue of DATAGRAMS for all flows, that drops the oldest to maintain a fixed size. Am I allowed to put RELIABLE_DATAGRAMs on that queue? \r\n\r\n",
          "createdAt": "2021-04-12T23:32:57Z",
          "updatedAt": "2021-04-12T23:33:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "A different point, before I forget. I like this proposal's change of flow IDs to be unidirectional. The Flow ID becomes more about the format of the datagram message, rather than it's purpose, which is powerful. The CONNECT-IP example is easy to overlook, the client is able to send DATAGRAMS either uncompressed or compressed, while the server can only do uncompressed. \r\n\r\nThe impact to an implementation that handles the DATAGRAM is that is needs to keep 2 sets of {stream:flow} tuples for each stream - one in the send direction, one in the receive direction. But I think that is manageable.",
          "createdAt": "2021-04-13T00:23:23Z",
          "updatedAt": "2021-04-13T00:23:23Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "This PR doesn't spell out RELIABLE_DATAGRAM, but you're right that the details there are important.  In H2, RELIABLE_DATAGRAM needs to carry a flag to ensure that messages that need to be reliable (like control messages) stay reliable end-to-end, and are not converted into H3 unreliable datagrams at H2->H3 intermediaries.",
          "createdAt": "2021-04-13T00:51:51Z",
          "updatedAt": "2021-04-13T00:51:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is obsolete now that we've landed #52.",
          "createdAt": "2021-05-27T01:22:39Z",
          "updatedAt": "2021-05-27T01:22:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0MDIxNzk4",
      "title": "Yet another experiment with two layers of indirection",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/39",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a variation on #38 but with the \"flow ID = 0 means register\" replaced with the REGISTER_DATAGRAM_FLOW_ID frame from #37.\r\n\r\nSince this is really hard to review in PR form, I've uploaded an HTML version [here](https://davidschinazi.com/stuff/draft-ietf-masque-h3-datagram-exp2.html#name-register_datagram_flow_id-ht) so I definitely suggest reading that instead.",
      "createdAt": "2021-04-12T23:58:04Z",
      "updatedAt": "2021-09-14T16:23:49Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "255935632c9247980273dfe418de8c2a4332727f",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "experiment_1_to_1_with_register_frame",
      "headRefOid": "ea7fbdb8e6371d0d8fa5fdfe7962709234b02cb8",
      "closedAt": "2021-05-27T01:22:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is obsolete now that we've landed #52.",
          "createdAt": "2021-05-27T01:22:43Z",
          "updatedAt": "2021-05-27T01:22:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM1MTg1MDU1",
          "commit": {
            "abbreviatedOid": "ea7fbdb"
          },
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-14T03:30:56Z",
          "updatedAt": "2021-04-14T03:30:57Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "I see why this frame is necessary for #38, since that was used to register flows, but I'd prefer to see this removed from this version of the proposal for simplicity and clarity. If people need it, it can be an extension later.",
              "createdAt": "2021-04-14T03:30:56Z",
              "updatedAt": "2021-04-14T03:30:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI5NDE0NzI2",
      "title": "Remove reuse",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/48",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #22.",
      "createdAt": "2021-05-03T22:57:09Z",
      "updatedAt": "2021-05-04T00:51:51Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "255935632c9247980273dfe418de8c2a4332727f",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "no_reuse",
      "headRefOid": "b8344dfdc9c876a64466bc1d73d4db7c4e3585f1",
      "closedAt": "2021-05-03T22:57:45Z",
      "mergedAt": "2021-05-03T22:57:44Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b5b2cc5cb506ebae31de75dd619171b961bfc524"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI5NDE1NzM1",
      "title": "Remove guidance about packing DATAGRAM frames in packets",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/49",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #26.",
      "createdAt": "2021-05-03T23:00:09Z",
      "updatedAt": "2021-05-04T00:51:33Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "b5b2cc5cb506ebae31de75dd619171b961bfc524",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "no_packing",
      "headRefOid": "01ed8b88b2d3ada41188a4b067de6d38b50b1b62",
      "closedAt": "2021-05-03T23:00:58Z",
      "mergedAt": "2021-05-03T23:00:58Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "db6f3ef1f551435e2ac847079b0600fa23f62aef"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI5NDE3NTk1",
      "title": "Remove ECN example",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/50",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #35 ",
      "createdAt": "2021-05-03T23:05:47Z",
      "updatedAt": "2021-05-04T00:51:38Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "db6f3ef1f551435e2ac847079b0600fa23f62aef",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "no_ecn",
      "headRefOid": "596664648c38738cb9ec0c89d0036a802688d4b3",
      "closedAt": "2021-05-03T23:06:43Z",
      "mergedAt": "2021-05-03T23:06:43Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b7720a8befd842989a8d9c14eddc04918d824f4c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI5NDE5NTk3",
      "title": "Add text about sticking out",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/51",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #36 ",
      "createdAt": "2021-05-03T23:11:50Z",
      "updatedAt": "2021-05-04T00:51:44Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "b7720a8befd842989a8d9c14eddc04918d824f4c",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "sticking_out",
      "headRefOid": "c80b82e278bc11825626bd158163e4c545644b11",
      "closedAt": "2021-05-03T23:14:12Z",
      "mergedAt": "2021-05-03T23:14:12Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "6cccb0e8b5149c1dae7d33c3579321032c591864"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI5NDUxODY2",
      "title": "Two layer design with CAPSULE",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/52",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR aims to take the design discussions we had at the last\r\ninterim, and propose a potential solution. This PR should in theory\r\ncontain enough information to allow folks to implement this new\r\ndesign. That will allow us to perform interop testing and confirm\r\nwhether the design is sound.\r\n\r\n[An HTML version of the draft with these changes is available here.](https://ietf-wg-masque.github.io/draft-ietf-masque-h3-datagram/two_layer_capsule/draft-ietf-masque-h3-datagram.html)\r\n\r\nCloses #41, closes #42, closes #43, closes #44.",
      "createdAt": "2021-05-04T00:52:14Z",
      "updatedAt": "2021-09-14T16:23:44Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "6cccb0e8b5149c1dae7d33c3579321032c591864",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "two_layer_capsule",
      "headRefOid": "5e3f4b8af2497bfc26f7d9eae1df20aaf2966e89",
      "closedAt": "2021-05-13T22:16:59Z",
      "mergedAt": "2021-05-13T22:16:59Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "a419fb7b581b0fe2900349b65664928ed1a942fd"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "I'm confused by this pull request (probably because I was out of the loop for a while).  My understanding, at least when I first read the proposal a month ago was that we would separate multiplexing streams and multiplexing contexts into different layers, so that methods that need context would get it (CONNECT-UDP), and features that don't (WebTransport/extended CONNECT) could use stream-associated datagrams directly.",
          "createdAt": "2021-05-07T18:21:21Z",
          "updatedAt": "2021-05-07T18:59:45Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv you're referring to #45 which this PR isn't trying to address. That'll happen in a subsequent PR.",
          "createdAt": "2021-05-07T19:19:05Z",
          "updatedAt": "2021-05-07T19:19:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxNTQxNTAx",
          "commit": {
            "abbreviatedOid": "1efe34e"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T18:27:40Z",
          "updatedAt": "2021-05-04T18:27:40Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "This requirement seems awkard to implement as specified. I think some of that comes from mixing length checks and parsing. To elabortate:\r\n\r\n\r\n* it states endpoints, but what about intermediaries (they need to parse just the Quarter Stream ID but should they forward a frame whose length is exactly the Quarter Stream ID?)\r\n* for an endpoint parsing both fields it probably needs to be an 'and' \r\n* since the fields are varints its harder to check the DATAGRAM payload length can satisfy the field requirements. The obvious case is if payload length is 1 (less than two minimally encoded varints) but other combos make it harder.\r\n\r\nThe way that H3 specs the requirement isn't a perfect fit but I think the spirit is more closely align with what you're trying to say - https://tools.ietf.org/html/draft-ietf-quic-http-34#section-7.1",
              "createdAt": "2021-05-04T18:27:40Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxNjgzODUz",
          "commit": {
            "abbreviatedOid": "ec60f26"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T21:29:01Z",
          "updatedAt": "2021-05-04T21:29:01Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Good point, one of those is hop-by-hop but the other is end-to-end. I've tweaked the requirements here to reflect that.",
              "createdAt": "2021-05-04T21:29:01Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxNzU1Njk4",
          "commit": {
            "abbreviatedOid": "617ea29"
          },
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-04T23:46:22Z",
          "updatedAt": "2021-05-05T00:02:51Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Way to have an intro that just copies the abstract =)",
              "createdAt": "2021-05-04T23:46:22Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 51,
              "body": "Editorial suggestion that  `{#datagram-contexts}` and `{#context-id-alloc}` could be subsections of Multiplexing, as \"##\" sections, which could remove the need to have `(see {{datagram-contexts}})` right before the section itself.",
              "createdAt": "2021-05-04T23:48:09Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nContexts refer to bidirectional exchanges of datagrams associated with a single HTTP\r\n```",
              "createdAt": "2021-05-04T23:48:44Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 120,
              "body": "Why does this say \"zero modulo four\"? Shouldn't it be \"the QUIC stream ID modulo four\"?",
              "createdAt": "2021-05-04T23:51:00Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 151,
              "body": "Bikeshed bikeshed bikeshed...",
              "createdAt": "2021-05-05T00:00:30Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 255,
              "body": "```suggestion\r\nunilaterally informs its peer of the closure. Endpoints can use\r\n```",
              "createdAt": "2021-05-05T00:01:09Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 257,
              "body": "```suggestion\r\nregistered by either themselves, or by their peer. Endpoints MAY use the\r\n```",
              "createdAt": "2021-05-05T00:01:22Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxNzY5OTA1",
          "commit": {
            "abbreviatedOid": "617ea29"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the review!",
          "createdAt": "2021-05-05T00:29:30Z",
          "updatedAt": "2021-05-05T00:35:17Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Indeed :)",
              "createdAt": "2021-05-05T00:29:30Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 51,
              "body": "Ah, that was my original intention. Thanks. Fixed.",
              "createdAt": "2021-05-05T00:30:55Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 56,
              "body": "Done.",
              "createdAt": "2021-05-05T00:32:34Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 120,
              "body": "Reworded to use divisible instead of modulo",
              "createdAt": "2021-05-05T00:33:25Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 151,
              "body": "Nope nope nope",
              "createdAt": "2021-05-05T00:33:35Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 255,
              "body": "Done",
              "createdAt": "2021-05-05T00:34:03Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 257,
              "body": "Done",
              "createdAt": "2021-05-05T00:34:21Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyMzIxMTYy",
          "commit": {
            "abbreviatedOid": "5d90c34"
          },
          "author": "bemasc",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I think this is a good change.  Thanks!\r\n\r\nThere are some things that I think we should still discuss, but we shouldn't hold up this change on those details.",
          "createdAt": "2021-05-05T13:42:29Z",
          "updatedAt": "2021-05-05T13:51:29Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "Allowing endpoints to close contexts created by the peer seems confusing to me.  If my peer just closed the context I've been using ... what do I do?  Do I reopen it?  Do I fail the connection?",
              "createdAt": "2021-05-05T13:42:29Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 258,
              "body": "I think it would probably be better to distinguish CLOSE from \"registration rejected\".  Did the server close the context because it accepted my packets and believes the context is no longer needed?  Or did it close because I hit a resource limit?  Or was my request incompatible?\r\n\r\nIf something can be used to communicate failures, then I think it probably needs an error code, so the recipient knows what to do next.",
              "createdAt": "2021-05-05T13:48:05Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 153,
              "body": "```suggestion\r\nCAPSULE (placeholder, final name TBD) allows reliably sending request-related information end-to-end, even in\r\n```",
              "createdAt": "2021-05-05T13:49:48Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyNzM2OTA2",
          "commit": {
            "abbreviatedOid": "5d90c34"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T20:53:19Z",
          "updatedAt": "2021-05-05T21:02:46Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Given that the draft is not in WGLC, everything's still up for discussion. That definitely includes the name \"CAPSULE\", but I don't think we need to spell that out explicitly in the document.",
              "createdAt": "2021-05-05T20:53:19Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 257,
              "body": "I'd say that depends on the application. In CONNECT-UDP if you close the main context then things break, so you might as well close the stream. But as another example, if your peer introduced a CONNECT-IP compression context and used it for a while and you're seeing low usage of it and want to reclaim memory, you can close than context and have the tunnel still be functional. Let's move this conversation to #43.",
              "createdAt": "2021-05-05T21:00:35Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 258,
              "body": "That's an interesting idea. I've filed #53 to track it so we don't forget after this is merged.",
              "createdAt": "2021-05-05T21:01:41Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyNzQ1Mzc5",
          "commit": {
            "abbreviatedOid": "5d90c34"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T21:04:33Z",
          "updatedAt": "2021-05-05T22:29:53Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "This reference to contexts comes before it is defined.  Add it to a definition of terms section, or forward reference?  It's a very generic term.",
              "createdAt": "2021-05-05T21:04:34Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 39,
              "body": "Maybe just 'encoded stream identifier'?",
              "createdAt": "2021-05-05T21:05:12Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 41,
              "body": "ID -> identifier",
              "createdAt": "2021-05-05T21:05:31Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 62,
              "body": "multiple -> one or more",
              "createdAt": "2021-05-05T21:27:50Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 88,
              "body": "What does it mean for a context ID to be 'client-initiated'?  Perhaps contexts are 'defined' by either the client or the server?",
              "createdAt": "2021-05-05T21:31:08Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 56,
              "body": "Given how vague the word context is, I think we should try to provide a bit more description of what this document thinks they are.  They are more specific than simply a bidirectional exchange, right?  It's a sub-group of the bidirectional exchange of datagrams that share some property or metadata?",
              "createdAt": "2021-05-05T21:40:20Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 92,
              "body": "can be used -> can be included in DATAGRAMs sent by",
              "createdAt": "2021-05-05T21:41:10Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 133,
              "body": "Do you need to specify behavior when the quarter stream ID refers to a non-existent or previously closed stream, etc?",
              "createdAt": "2021-05-05T21:44:11Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 158,
              "body": "frame -> frames",
              "createdAt": "2021-05-05T21:44:59Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 193,
              "body": "remove 'upcoming'",
              "createdAt": "2021-05-05T21:46:09Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 158,
              "body": "Is it a bug or a feature that intermediaries are not allowed to modify the contents of a capsule, but there's nothing stopping them from doing so?  eg: why not require end-to-end encryption or integrity protection of the payloads?\r\n\r\nAre there use-cases where we might want to allow an intermediary to modify the context information, or inject its own contexts?",
              "createdAt": "2021-05-05T21:47:54Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 197,
              "body": "I find it annoying that I have to register a context ID in order to use any datagrams, even if I don't want to use it.  I prefer being able to negotiate the use of context IDs in datagrams, or at least defining a value (0?) which does not need to be registered and carries the empty context.\r\n\r\nAfter reading the examples, which all register context-ID 0 with the empty extension string, I think this would help reduce boilerplate in a lot of cases.",
              "createdAt": "2021-05-05T21:51:16Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 233,
              "body": "for a short while in hopes of receiving -> temporarily while awaiting",
              "createdAt": "2021-05-05T21:53:42Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 224,
              "body": "Specify errors if a sender attempts to register a context ID that it has registered but not yet closed, or of the wrong parity.",
              "createdAt": "2021-05-05T21:54:52Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 606,
              "body": "TImestamp -> Timestamp",
              "createdAt": "2021-05-05T22:04:04Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 500,
              "body": "I assume this is for the 'extension-string' parameter in Register Datagram Context.  The word key first appears here.",
              "createdAt": "2021-05-05T22:09:27Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 151,
              "body": "After reading this document, the main benefit I see to CAPSULE is that it makes it easier to deploy future end-to-end extension \"frames\" without having to modify intermediaries (because H3 drops unknown frames).  It may also make it easier to extend in client <--> server cases where the H3 stack itself is not easily modifiable (owned by a third-party, say).\r\n\r\nEventually it would probably warrant its own document and not be buried in DATAGRAM?",
              "createdAt": "2021-05-05T22:24:11Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyODQxNTkx",
          "commit": {
            "abbreviatedOid": "5d90c34"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T23:09:28Z",
          "updatedAt": "2021-05-05T23:09:28Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "A generic HTTP library capable of receiving and sending datagrams could be used to build either an intermediary or an endpoint.  WIth this specification, It would need two sets of APIs, one that had the context ID (for endpoints) and one without (for intermediaries).  If datagrams carry context IDs then intermediaries should be able to parse them.",
              "createdAt": "2021-05-05T23:09:28Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxNzM4NjQy",
          "commit": {
            "abbreviatedOid": "617ea29"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T23:04:38Z",
          "updatedAt": "2021-05-05T23:34:25Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "The odd-numbered context IDs are throwing me. Is this an attempt to leave that door open even if this proposal defines mot means to establish the flow?",
              "createdAt": "2021-05-04T23:04:38Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 158,
              "body": "I think adding a secure integrity mechanism is overkill. I'd treat these more like how headers and intermediaries work. Most intermediaries really have no business looking at the stuff, but some will decide to do stuff and if they break things then hopefully the failure to abide the spec will be reflected in market position.",
              "createdAt": "2021-05-05T23:31:19Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 138,
              "body": "What would intermediaries do with it? It might be fair to parse it and tell your API users \"this field is entirely meaningless unless you are an endpoint\".",
              "createdAt": "2021-05-05T23:34:19Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyODM2MjY0",
          "commit": {
            "abbreviatedOid": "5d90c34"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the review!",
          "createdAt": "2021-05-05T22:57:09Z",
          "updatedAt": "2021-05-05T23:37:04Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Good point, I rephrased this.",
              "createdAt": "2021-05-05T22:57:09Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 39,
              "body": "Agreed, done.",
              "createdAt": "2021-05-05T22:57:19Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 41,
              "body": "Done",
              "createdAt": "2021-05-05T22:57:38Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 56,
              "body": "Added more text to explain contexts",
              "createdAt": "2021-05-05T23:07:28Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 62,
              "body": "Done",
              "createdAt": "2021-05-05T23:08:24Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 88,
              "body": "The next sentence explains this further, I prefer initiated over defined.",
              "createdAt": "2021-05-05T23:09:21Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 92,
              "body": "I find used to be clearer",
              "createdAt": "2021-05-05T23:09:52Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 133,
              "body": "Done",
              "createdAt": "2021-05-05T23:15:07Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 151,
              "body": "I agree with your benefit analysis. I'd prefer to avoid splitting the document further though. Let's wait and see if anyone wants to use CAPSULE but cannot implement DATAGRAM.",
              "createdAt": "2021-05-05T23:16:29Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 158,
              "body": "Done",
              "createdAt": "2021-05-05T23:16:49Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 158,
              "body": "Capsules are by definition end-to-end. If intermediaries start looking inside, they might cause ossification. In theory, I'd happily use end-to-end encryption to protect them but we don't have keys for this purpose.",
              "createdAt": "2021-05-05T23:18:33Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 193,
              "body": "Done",
              "createdAt": "2021-05-05T23:18:56Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 197,
              "body": "I consider that to be a feature rather than a bug. If we don't exercise this path, implementors will cut corners and we won't be able to deploy extensions down the road. Requiring the main path to use the extension mechanism ensures that the mechanism is exercised and functional.",
              "createdAt": "2021-05-05T23:20:57Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 224,
              "body": "Done",
              "createdAt": "2021-05-05T23:26:55Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 233,
              "body": "Done",
              "createdAt": "2021-05-05T23:27:24Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 500,
              "body": "These are the keys from that section, I added references.",
              "createdAt": "2021-05-05T23:31:45Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 606,
              "body": "Done",
              "createdAt": "2021-05-05T23:32:53Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 138,
              "body": "Your HTTP implementation is going to need to know whether to act on datagrams (endpoint) or forward them (intermediaries). Plumbing that bool to the parse function doesn't seem complex?",
              "createdAt": "2021-05-05T23:34:16Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyODU1NTcx",
          "commit": {
            "abbreviatedOid": "943fdbc"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T23:44:17Z",
          "updatedAt": "2021-05-05T23:44:18Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Odd-numbered context IDs allow servers to register their own contexts. For example, a CONNECT-IP server could choose to start compressing using a compression context of its choosing.",
              "createdAt": "2021-05-05T23:44:17Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyODU2MTI2",
          "commit": {
            "abbreviatedOid": "943fdbc"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T23:45:42Z",
          "updatedAt": "2021-05-05T23:51:20Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "> What would intermediaries do with it?\r\n\r\nThe same thing it does with other opaque things it get from the peer (eg: body bytes, datagram payloads) - forward to the other peer.\r\n\r\nWhatever thing handles an HTTP stream would now have APIs like\r\n\r\n```\r\nonDatagram(payload)\r\nsendDatagram(payload)\r\n```\r\nfor intermediaries, or, if you are for endpoints:\r\n\r\n```\r\nonDatagram(contextID, payload)\r\nsendDatagram(contextID, payload)\r\n```\r\n\r\nI'd prefer to have the library only have the second variant.  If using the library to implement a proxy, then the proxy implementation would pass the context ID and payload from one peer's `onDatagram` to the other side's `sendDatagram`. \r\n\r\nLogging/stats are another possible use.\r\n\r\nI guess the broader point is -- as this spec is written, the datagram has to have that context ID, so why be so prescriptive about what the intermediary can and can't do with it.",
              "createdAt": "2021-05-05T23:45:42Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            },
            {
              "originalPosition": 197,
              "body": "Most wg's approach grease by defining it and encouraging implementers to use it liberally enough to prevent this, but not require it.  HTTP/3 doesn't require a GREASE frame in order to function.",
              "createdAt": "2021-05-05T23:48:25Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyODU4NTkw",
          "commit": {
            "abbreviatedOid": "943fdbc"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T23:52:21Z",
          "updatedAt": "2021-05-05T23:52:21Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Yeah this makes sense, I just didn't digest all of the concepts before posting.",
              "createdAt": "2021-05-05T23:52:21Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyODU5OTEz",
          "commit": {
            "abbreviatedOid": "943fdbc"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-05T23:55:53Z",
          "updatedAt": "2021-05-05T23:55:54Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "We're considering making the Context ID optional (see #45). If intermediaries start parsing the context ID, it'll prevent us from doing that.",
              "createdAt": "2021-05-05T23:55:53Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyODYyMzUy",
          "commit": {
            "abbreviatedOid": "943fdbc"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-06T00:02:32Z",
          "updatedAt": "2021-05-06T00:02:33Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "This isn't about grease, it's about using your extension mechanism. HTTP/3 forces all HTTP implementations to correctly support HTTP headers, because otherwise they couldn't send or parse `:method`. That guarantees that everyone correctly handles headers. We could have said that if no HEADERS frame is sent then it means GET, but we decided against that.",
              "createdAt": "2021-05-06T00:02:32Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyODYzNzgy",
          "commit": {
            "abbreviatedOid": "943fdbc"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-06T00:06:22Z",
          "updatedAt": "2021-05-06T00:06:23Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "I was being a bit tongue in cheek by suggesting security measures here. It strikes me as overkill too.\r\n\r\nSo is it explicitly forbidden for a proxy to register its own context ID on a stream via CAPSULE?  This would require some careful context-ID allocations by the proxy to avoid potential collisions, which in turn break the rules about the context-IDs being end-to-end.\r\n\r\nI don't have a use case, but I'm not sure I see the the value in locking this down quite so tightly.  Are there designs that depend on the context identifier being the same at every hop?  Perhaps tunneling QUIC in 'forward' mode relies on this?\r\n",
              "createdAt": "2021-05-06T00:06:22Z",
              "updatedAt": "2021-05-06T00:21:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUyODY5NDMz",
          "commit": {
            "abbreviatedOid": "057155d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-06T00:22:53Z",
          "updatedAt": "2021-05-06T00:22:53Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "The core tenet of the two-layer design is that Stream IDs are per-hop and context IDs are end-to-end. That allows extensions to rely on the fact that both endpoints have the same view of context IDs. CAPSULE exists as an end-to-end mechanism, and similarly relies on that property. If we need a new per-hop mechanism, then we can use a different h3 frame. I've clarified that intermediaries don't send capsules apart from forwarding them, so they're not allowed to inject their own context IDs.",
              "createdAt": "2021-05-06T00:22:53Z",
              "updatedAt": "2021-05-06T00:22:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUzNTUxNTE3",
          "commit": {
            "abbreviatedOid": "057155d"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-06T15:17:48Z",
          "updatedAt": "2021-05-06T15:20:37Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Whatever mechanism the endpoint will use to know if it should parse the context ID can also be used by the intermediary as well.  My point was that in this PR, they are required.\r\n\r\nPresumably if/when negotiation is added the specification can be updated to reflect that.",
              "createdAt": "2021-05-06T15:17:48Z",
              "updatedAt": "2021-05-06T15:20:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUzNjU2MTc0",
          "commit": {
            "abbreviatedOid": "057155d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-06T16:25:37Z",
          "updatedAt": "2021-05-06T16:25:37Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "I've filed #54 to keep track of this discussion so it doesn't get lost when this is merged. Let's continue this conversation there.",
              "createdAt": "2021-05-06T16:25:37Z",
              "updatedAt": "2021-05-06T16:25:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2MDM2NzUy",
          "commit": {
            "abbreviatedOid": "057155d"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-10T20:01:17Z",
          "updatedAt": "2021-05-10T20:01:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ2MDU4MzQ4",
      "title": "Add some rules on ordering of register capsules",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/55",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This prevents some flavors of DoS attacks and provides clearer assumptions to endpoints.",
      "createdAt": "2021-05-17T17:53:28Z",
      "updatedAt": "2021-09-14T16:23:42Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "a419fb7b581b0fe2900349b65664928ed1a942fd",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "register_ordering",
      "headRefOid": "d50a473c7d991d0bcfaa93dcf1429ff293bb526d",
      "closedAt": "2021-05-17T18:00:34Z",
      "mergedAt": "2021-05-17T18:00:33Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "104359017bdb560d20c1fa337ca34216b0f65cdb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYxMjUyNDk1",
          "commit": {
            "abbreviatedOid": "d50a473"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-17T17:59:10Z",
          "updatedAt": "2021-05-17T17:59:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ2MTExNDk5",
      "title": "Make contexts optional",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/56",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change allows clients to disable contexts for a given stream.\r\nThis uses a new REGISTER_DATAGRAM_NO_CONTEXT capsule for negotiation.\r\nThe important property here is that it requires capsule support even\r\nwhen contexts are not required. This is critical to the health of the\r\necosystem as it will ensure that intermediaries that support datagrams\r\nbut not capsules cannot be deployed, as that would prevent future\r\nextensibility.\r\n\r\nCloses #45.",
      "createdAt": "2021-05-17T19:10:01Z",
      "updatedAt": "2021-09-14T16:23:38Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "104359017bdb560d20c1fa337ca34216b0f65cdb",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "optional_context",
      "headRefOid": "b02a4872420c769ef91511f0afd8c2b298b4e9a3",
      "closedAt": "2021-05-24T16:16:13Z",
      "mergedAt": "2021-05-24T16:16:13Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "9c4c32917d22e8600f4818382ec151c045728bd2"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Editorial comments aside, I support the protocol feature of an optional DATAGRAM Context ID. Using a registration capsule, as proposed in this PR, is a very logical way of achieving that. I plan to implement this in my WIP code.",
          "createdAt": "2021-05-17T21:40:30Z",
          "updatedAt": "2021-05-17T21:40:30Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like there's support for merging this. Some additional editorial work is needed, but we'll do that in followups.",
          "createdAt": "2021-05-24T16:16:08Z",
          "updatedAt": "2021-05-24T16:16:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYxMzQxODk5",
          "commit": {
            "abbreviatedOid": "b02a487"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Left some specific comments in-line.\r\n\r\nThis change also has implications for CLOSE_DATAGRAM_CONTEXT. For instance, I presume it is an error to receive CLOSE_DATAGRAM_CONTEXT after receiving REGISTER_DATAGRAM_NO_CONTEXT.",
          "createdAt": "2021-05-17T19:30:59Z",
          "updatedAt": "2021-05-17T20:04:12Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I think these rules are correct but a bit hard to follow in isolation and especially when there's only a few characters of difference.\r\n\r\nI wonder if pulling some of the text that discusses the relationship between CONTEXT and NO_CONTEXT registrations in the same stream into {datagram-contexts} could help.",
              "createdAt": "2021-05-17T19:31:00Z",
              "updatedAt": "2021-05-17T20:04:12Z"
            },
            {
              "originalPosition": 132,
              "body": "This is a good example of my prior comment, we could probably say earlier in the document that these can't be mixed in the same stream and then point to this section for wire-specifics.",
              "createdAt": "2021-05-17T19:43:07Z",
              "updatedAt": "2021-05-17T20:04:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYxNjA1MTIw",
          "commit": {
            "abbreviatedOid": "b02a487"
          },
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Looks good overall.",
          "createdAt": "2021-05-18T03:42:10Z",
          "updatedAt": "2021-05-18T06:26:55Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "I am not sure this is necessary.  Extension strings only make sense if you have multiple contexts within a request; when you only have one, any extensions can be negotiated within headers.",
              "createdAt": "2021-05-18T03:42:10Z",
              "updatedAt": "2021-05-18T06:26:55Z"
            },
            {
              "originalPosition": 111,
              "body": "There's a bit of contradiction here.  You claim that capsules are end-to-end; yet stream resets are per-hop mechanism, and in general I don't believe there is a reliable error propagation of stream reset codes across hops.",
              "createdAt": "2021-05-18T03:45:26Z",
              "updatedAt": "2021-05-18T06:26:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYyMzYzODYw",
          "commit": {
            "abbreviatedOid": "b02a487"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-18T17:12:15Z",
          "updatedAt": "2021-05-18T17:12:16Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "As far as I know, HTTP/3 doesn't have any other way to abruptly close request streams apart from reseting the stream. That reset will be propagated, and if the error code is changed that's not a big deal. This matches how HTTP/3 CONNECT reacts to a TCP RST for example.",
              "createdAt": "2021-05-18T17:12:16Z",
              "updatedAt": "2021-05-18T17:12:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYyMzY1MDYx",
          "commit": {
            "abbreviatedOid": "b02a487"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-18T17:13:35Z",
          "updatedAt": "2021-05-18T17:13:35Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "You could use a header, but if you've already defined an extension key for the multiple context use-case, why have to define a header too? I prefer the simplicity and symmetry of using the same mechanism.",
              "createdAt": "2021-05-18T17:13:35Z",
              "updatedAt": "2021-05-18T17:13:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYyMzc1MzAx",
          "commit": {
            "abbreviatedOid": "b02a487"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-18T17:25:11Z",
          "updatedAt": "2021-05-18T17:25:12Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "It's good behaviour to propagate errors across hops, even if they require mapping. For example, see the H2-H3 mapping advice in https://datatracker.ietf.org/doc/html/draft-ietf-quic-http-34#appendix-A.4.1.\r\n\r\nI think the text is fine right to focus on HTTP/3 right now. Subsequent follow up work to make this design work over other HTTP versions can add guidance on how to propagate errors if specific advice is needed. I wouldn't worry about it in isolation since we might overlook details.",
              "createdAt": "2021-05-18T17:25:12Z",
              "updatedAt": "2021-05-18T17:25:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUxNjIxNzAy",
      "title": "Clarify datagram lifetime with stream",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/57",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Minor editorial clarification.\r\n\r\nCloses #40.",
      "createdAt": "2021-05-24T20:59:37Z",
      "updatedAt": "2021-09-14T16:23:38Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "be59a39d45f44b3a0321a6976674635af81dfa9d",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "lifetime",
      "headRefOid": "60777c8da14e01939beff432ca9865a19f5f5758",
      "closedAt": "2021-05-24T21:42:23Z",
      "mergedAt": "2021-05-24T21:42:23Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "d922f8071d357e1bb37a3acbed1546bd35c9e711"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MTkxNzAw",
          "commit": {
            "abbreviatedOid": "279aeff"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T21:24:16Z",
          "updatedAt": "2021-05-24T21:24:16Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "There still seems to be some ambiguity here. Where you say \"Endpoints MUST NOT send HTTP/3 datagrams unless the corresponding stream is open\" do you really mean that it is ok to send Datagrams if the local send side is closed? CONNECT-UDP, IIRC, prohibits clients closing their end of the stream but there seems to be no requirement for other methods to do so. I think a model where you can only send DATAGRAM frames while you can send STREAM frames is the most rational way to approach this. \r\n\r\nSince there is no general ordering guarantee between DATAGRAM and STREAM, your recommendation \"If an HTTP/3 datagram is received and its Quarter Stream ID maps to a stream that has already been closed, the receiver MUST silently drop\" is good. We might want to loosen this a little and say \"If an HTTP/3 receiver detects that it has received a datagram with a Quarter Stream ID that maps to a closed stream, it MUST silently drop.\" - the reason being that certain types of housekeeping might be impractical for some implementations.",
              "createdAt": "2021-05-24T21:24:16Z",
              "updatedAt": "2021-05-24T21:24:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjA3NTkz",
          "commit": {
            "abbreviatedOid": "60777c8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T21:31:40Z",
          "updatedAt": "2021-05-24T21:31:40Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I tweaked the text to make clear it's tied to one direction of the stream, and that should resolve this.",
              "createdAt": "2021-05-24T21:31:40Z",
              "updatedAt": "2021-05-24T21:31:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjExMjkx",
          "commit": {
            "abbreviatedOid": "60777c8"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This improvement is good enough for me. Thanks.",
          "createdAt": "2021-05-24T21:38:10Z",
          "updatedAt": "2021-05-24T21:38:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUxNjMyNTgw",
      "title": "Make prioritization undefined",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/58",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Punt prioritization to extensions like QUIC and HTTP/3 did.\r\n\r\nCloses #46.",
      "createdAt": "2021-05-24T21:14:26Z",
      "updatedAt": "2021-09-14T16:23:37Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "be59a39d45f44b3a0321a6976674635af81dfa9d",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "priority",
      "headRefOid": "a4fe673de4655eeecd8b06162864a6c4d9ddb76f",
      "closedAt": "2021-05-24T21:42:33Z",
      "mergedAt": "2021-05-24T21:42:33Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "0cdcdd054dc1815352d79c3031fb9d91107ea74e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MTk4MDE0",
          "commit": {
            "abbreviatedOid": "a4fe673"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-24T21:26:33Z",
          "updatedAt": "2021-05-24T21:26:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUxNjQzNTA2",
      "title": "Clarify intermediary parsing rules",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/59",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Contexts are end-to-end, and intermediaries MUST NOT parse them.\r\n\r\nCloses #54.",
      "createdAt": "2021-05-24T21:26:23Z",
      "updatedAt": "2021-09-14T16:23:36Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "be59a39d45f44b3a0321a6976674635af81dfa9d",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "intermediary",
      "headRefOid": "0aba1736801c7160d03fa142baac244b1e225950",
      "closedAt": "2021-05-24T22:08:28Z",
      "mergedAt": "2021-05-24T22:08:28Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "f899b094074eda3bb0f5141d5e6c79074121c5c8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjA5NjY5",
          "commit": {
            "abbreviatedOid": "43473fb"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T21:35:16Z",
          "updatedAt": "2021-05-24T21:35:16Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nH3_GENERAL_PROTOCOL_ERROR. The Context ID field is optional and its use is\r\nnegotiated end-to-end see {{ref}}. Therefore intermediaries cannot\r\nknow whether the Context ID field is present or absent and they \r\nMUST ignore any HTTP/3 Datagram fields after the Quarter Stream ID.\r\n```\r\n\r\nHere's an alternative that's less wordy at risk of losing some points you were trying to make. \r\n\r\nI don't think putting/repeating the negotiation requirement right here is too great, so I've replace the parenthesised clause with a reference to wherever that requirement actually lives.\r\n\r\nI also made a horrible mess of your line wrapping :D",
              "createdAt": "2021-05-24T21:35:16Z",
              "updatedAt": "2021-05-24T21:35:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjEzNTA0",
          "commit": {
            "abbreviatedOid": "0aba173"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T21:42:04Z",
          "updatedAt": "2021-05-24T21:42:04Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Took that text and tweaked it a bit more.",
              "createdAt": "2021-05-24T21:42:04Z",
              "updatedAt": "2021-05-24T21:42:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjE3NjQ2",
          "commit": {
            "abbreviatedOid": "0aba173"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM! :shipit: ",
          "createdAt": "2021-05-24T21:49:53Z",
          "updatedAt": "2021-05-24T21:49:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUxNjk3ODcw",
      "title": "Clarify Opaque Capsules",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/60",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@afrind points out that in order to correctly forward DATAGRAMs between transports where the QUIC DATAGRAM frame isn't always available, intermediaries need the ability to parse some capsules.",
      "createdAt": "2021-05-24T23:13:55Z",
      "updatedAt": "2021-09-14T16:23:26Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "13a8ccd227f217367896cef03f92649db5c5bba3",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "opaque",
      "headRefOid": "93ac485e5afbaafcf2ceabca70e8de7ed800703b",
      "closedAt": "2021-05-26T23:53:57Z",
      "mergedAt": "2021-05-26T23:53:57Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "d60d5f524c0182dcb79f62a05851de289cefc6bd"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "CAPSULE was easier to understand when it was fully opaque.  When should I choose to define a semi-opaque CAPSULE vs defining a new frame?  Aren't both constructs effectively hop-by-hop?",
          "createdAt": "2021-05-25T15:44:02Z",
          "updatedAt": "2021-05-25T15:44:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind you're the one who asked for this :-)\r\n\r\nThe benefit of a semi-opaque capsule is that it allows defining new capsules without having to update every single intermediary in the chain, because intermediaries forward all unknown capsules.",
          "createdAt": "2021-05-25T16:11:58Z",
          "updatedAt": "2021-05-25T16:11:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4MTQ0Nzk4",
          "commit": {
            "abbreviatedOid": "3395b87"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-25T17:29:24Z",
          "updatedAt": "2021-05-25T19:09:35Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Non-opqaue (transparent?) CAPSULEs are not forwarded in their unmodified entirety.  \r\n\r\nShould we state here that there are two types of CAPSULE (opaque and transparent)?.  Opaque CAPSULEs are always forwarded in their unmodified entirety.  Transparent CAPSULEs may be inspected and decapsulated by an intermediary and forwarded via a semantically equivalent protocol construct, when available.\r\n\r\nAlso in this PR, the DATAGRAM CAPSULE is *not* reliable end-to-end (see line 198), since converting to an H3 datagram on any hop along the path makes it unreliable.",
              "createdAt": "2021-05-25T17:29:24Z",
              "updatedAt": "2021-05-25T19:09:35Z"
            },
            {
              "originalPosition": 31,
              "body": "Order of transparent CAPSULEs (such as DATAGRAM) is no longer guaranteed, because an H3 -> H2 intermediary can have reordering effects.",
              "createdAt": "2021-05-25T19:09:23Z",
              "updatedAt": "2021-05-25T19:09:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4NDk4ODAz",
          "commit": {
            "abbreviatedOid": "caa0d35"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T00:13:49Z",
          "updatedAt": "2021-05-26T00:13:49Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Good catch, fixed",
              "createdAt": "2021-05-26T00:13:49Z",
              "updatedAt": "2021-05-26T00:13:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4NDk5MTM3",
          "commit": {
            "abbreviatedOid": "caa0d35"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T00:14:43Z",
          "updatedAt": "2021-05-26T00:14:44Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I like transparent. Updated the text.\r\n\r\nYes, datagrams are not reliable, even if sent by capsule.",
              "createdAt": "2021-05-26T00:14:43Z",
              "updatedAt": "2021-05-26T00:14:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4NTAzNzEz",
          "commit": {
            "abbreviatedOid": "caa0d35"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T00:27:21Z",
          "updatedAt": "2021-05-26T00:27:21Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "> I like transparent\r\n\r\nHeh, now that I read it I like it less :) \r\n\r\nIt's good that transparent is the opposite of opaque, but as I read the text it seems strange that an intermediary is removing or inserting something that's called 'transparent'.  \r\n\r\nNaming is hard though.  The property of the 'transparent' capsule that makes them different is that they are convertible to other protocol elements or extensions (I'm imagining what WebTransport streams might look like if conveyed by capsule).  But opaque vs convertible seems weird too.  I hereby resign from this bikeshed.\r\n\r\n> Yes, datagrams are not reliable, even if sent by capsule.\r\n\r\nIs that true?  Capsules are always sent on an HTTP stream which is reliable.  You mean that a receiver has the option to drop a DATAGRAM capsule?  I didn't text to this effect.",
              "createdAt": "2021-05-26T00:27:21Z",
              "updatedAt": "2021-05-26T00:27:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4NTA5NTA3",
          "commit": {
            "abbreviatedOid": "668a62e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T00:44:14Z",
          "updatedAt": "2021-05-26T00:44:14Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I also don't much care for bikesheds. I'm going to keep \"transparent\" until someone proposes something better.\r\n\r\nI've added text to spell out that yes: datagrams are unreliable, even when initially sent in capsules.",
              "createdAt": "2021-05-26T00:44:14Z",
              "updatedAt": "2021-05-26T00:44:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4NTEzMzYx",
          "commit": {
            "abbreviatedOid": "668a62e"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T00:55:25Z",
          "updatedAt": "2021-05-26T01:03:14Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "It might be a better flow to move these two sentences to immediately after the first sentence of this para. But see the other review comment below.",
              "createdAt": "2021-05-26T00:55:25Z",
              "updatedAt": "2021-05-26T01:03:14Z"
            },
            {
              "originalPosition": 38,
              "body": "This para seems a bit like a fragment, maybe you could just append the clause to the end of the sentence 2 paras up? I.e. \"Intermediaries MUST treat unknown Capsule Types as opaque and MUST silently drop the Capsule.\"",
              "createdAt": "2021-05-26T01:02:30Z",
              "updatedAt": "2021-05-26T01:03:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MTU1NTMx",
          "commit": {
            "abbreviatedOid": "668a62e"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T15:14:23Z",
          "updatedAt": "2021-05-26T15:19:45Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Maybe just 'Intermediaries forward received CAPSULE frames on the same stream...' , since the capsule type (opacity) described in the next sentence explicitly carves out cases where capsules are not forwarded in their entirety.",
              "createdAt": "2021-05-26T15:14:23Z",
              "updatedAt": "2021-05-26T15:19:45Z"
            },
            {
              "originalPosition": 14,
              "body": "Is 'parsed or added' what we want to say, or rather, 'transparent ones can be converted to semantically equivalent protocol features or extensions by an intermediary, as defined by the specific Capsule Type', or something like that.",
              "createdAt": "2021-05-26T15:16:20Z",
              "updatedAt": "2021-05-26T15:19:45Z"
            },
            {
              "originalPosition": 38,
              "body": "This is talking about Endpoints.  Intermediaries MUST forward, regardless if they know the type.  Specifying that the endpoint MUST 'drop' unknown capsules seems prescriptive - perhaps 'MAY ignore' is better?",
              "createdAt": "2021-05-26T15:19:30Z",
              "updatedAt": "2021-05-26T15:19:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NDgxMDUz",
          "commit": {
            "abbreviatedOid": "668a62e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T19:53:58Z",
          "updatedAt": "2021-05-26T19:58:30Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "For intermediaries it's MUST forward, not MUST drop. Otherwise new capsules won't work without modifying intermediaries.",
              "createdAt": "2021-05-26T19:53:58Z",
              "updatedAt": "2021-05-26T19:58:30Z"
            },
            {
              "originalPosition": 14,
              "body": "I'd rather leave this vague. If it's transparent, the intermediary is allowed to do anything to a capsule if it wants to. I tweaked the text to clarify the intent.",
              "createdAt": "2021-05-26T19:54:51Z",
              "updatedAt": "2021-05-26T19:58:30Z"
            },
            {
              "originalPosition": 11,
              "body": "I agree, fixed.",
              "createdAt": "2021-05-26T19:55:49Z",
              "updatedAt": "2021-05-26T19:58:30Z"
            },
            {
              "originalPosition": 29,
              "body": "I think this flows better here, see response on other comment",
              "createdAt": "2021-05-26T19:57:40Z",
              "updatedAt": "2021-05-26T19:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NjI0NTgz",
          "commit": {
            "abbreviatedOid": "1ef7bc2"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T23:33:12Z",
          "updatedAt": "2021-05-26T23:33:13Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "oh sorry I misread things",
              "createdAt": "2021-05-26T23:33:12Z",
              "updatedAt": "2021-05-26T23:33:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NjI2OTAw",
          "commit": {
            "abbreviatedOid": "1ef7bc2"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T23:39:09Z",
          "updatedAt": "2021-05-26T23:39:09Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Not specific to this PR but the changes made me realise we probably want to specific what receivers of CAPSULE on the wrong type of stream do. I.E. if I understand CAPSULE and I see one arrive on the peer's control stream, I probably should be closing the connection with H3_FRAME_UNEXPECTED. Maybe we should spin this off to a new issue?",
              "createdAt": "2021-05-26T23:39:09Z",
              "updatedAt": "2021-05-26T23:39:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NjI2OTU0",
          "commit": {
            "abbreviatedOid": "1ef7bc2"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T23:39:18Z",
          "updatedAt": "2021-05-26T23:39:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NjMwNTMx",
          "commit": {
            "abbreviatedOid": "93ac485"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T23:48:39Z",
          "updatedAt": "2021-05-26T23:48:40Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Fixed",
              "createdAt": "2021-05-26T23:48:39Z",
              "updatedAt": "2021-05-26T23:48:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUxNzU1NDQw",
      "title": "Add context close codes and make extensibility binary",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/61",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a new concept of context close codes which\r\nwill allow applications that use contexts to indicate\r\nthe reason for closing a context.\r\n\r\nThis PR also makes the extensibility mechanism binary as\r\nthat is easier to implement.\r\n\r\nCloses #53.",
      "createdAt": "2021-05-25T01:17:28Z",
      "updatedAt": "2021-09-14T16:23:33Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "13a8ccd227f217367896cef03f92649db5c5bba3",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "errors",
      "headRefOid": "e9fad671582da9a3f4ecbc15e20d7161c7c7103b",
      "closedAt": "2021-05-26T20:32:50Z",
      "mergedAt": "2021-05-26T20:32:50Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "a54a431ba043141321fe8107e17c00beb6d99526"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NDU3MzU3",
          "commit": {
            "abbreviatedOid": "bbe4fac"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T19:24:33Z",
          "updatedAt": "2021-05-26T19:32:31Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "```suggestion\r\nRESOURCE_LIMIT (code=0x02):\r\n```",
              "createdAt": "2021-05-26T19:24:33Z",
              "updatedAt": "2021-05-26T19:32:31Z"
            },
            {
              "originalPosition": 142,
              "body": "Omitting the code seems like a micro optimization. Is there a strong case for this?",
              "createdAt": "2021-05-26T19:28:33Z",
              "updatedAt": "2021-05-26T19:32:31Z"
            },
            {
              "originalPosition": 255,
              "body": "```suggestion\r\n| RESOURCE_LIMIT              | 0x02  | This Document |\r\n```",
              "createdAt": "2021-05-26T19:30:26Z",
              "updatedAt": "2021-05-26T19:32:31Z"
            },
            {
              "originalPosition": 302,
              "body": "Longer term, we might want to explain the presentation format for extensions but for now I think this is ok.",
              "createdAt": "2021-05-26T19:32:19Z",
              "updatedAt": "2021-05-26T19:32:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NDc1MTQx",
          "commit": {
            "abbreviatedOid": "bbe4fac"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T19:46:39Z",
          "updatedAt": "2021-05-26T19:51:34Z",
          "comments": [
            {
              "originalPosition": 302,
              "body": "Agreed, these example are likely to be removed before publication.",
              "createdAt": "2021-05-26T19:46:39Z",
              "updatedAt": "2021-05-26T19:51:34Z"
            },
            {
              "originalPosition": 142,
              "body": "That's a good point, fixed.",
              "createdAt": "2021-05-26T19:47:41Z",
              "updatedAt": "2021-05-26T19:51:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NDkzMjgz",
          "commit": {
            "abbreviatedOid": "4a3ceda"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM thanks",
          "createdAt": "2021-05-26T20:08:34Z",
          "updatedAt": "2021-05-26T20:08:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NTA5ODMy",
          "commit": {
            "abbreviatedOid": "4a3ceda"
          },
          "author": "bemasc",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T20:29:16Z",
          "updatedAt": "2021-05-26T20:29:52Z",
          "comments": [
            {
              "originalPosition": 313,
              "body": "I find this example kind of confusing, especially now that contexts are bidirectional.  A more realistic hypothetical might be something like `IP_COMPRESSION=tcp,192.0.2.41:54321,192.0.2.42:443`.  Or just `IP_COMPRESSION=<TBD connection info>`.",
              "createdAt": "2021-05-26T20:29:16Z",
              "updatedAt": "2021-05-26T20:29:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 62,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU0MjA1MjQ4",
      "title": "Allow keeping receive around for a short time",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/62",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #40.",
      "createdAt": "2021-05-26T20:29:25Z",
      "updatedAt": "2021-09-14T16:23:25Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "13a8ccd227f217367896cef03f92649db5c5bba3",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "lifetime_again",
      "headRefOid": "55c8d94b3497b04a09f7c7b4a586488bfa618826",
      "closedAt": "2021-05-27T01:21:55Z",
      "mergedAt": "2021-05-27T01:21:55Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "ef994baae9067ca1d9398f4eb562c20e5e7c42b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NjQ0Njkz",
          "commit": {
            "abbreviatedOid": "55c8d94"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-27T00:27:42Z",
          "updatedAt": "2021-05-27T00:27:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU4NjI4MzA2",
      "title": "Update CONTRIBUTING.md",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/63",
      "state": "MERGED",
      "author": "bashi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix links.",
      "createdAt": "2021-06-01T04:09:16Z",
      "updatedAt": "2021-06-01T23:50:54Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "e849120695d694a5e8fe5e5834ff431f32ee51ca",
      "headRepository": "bashi/draft-ietf-masque-h3-datagram",
      "headRefName": "patch-1",
      "headRefOid": "a1039c41c4616d186cc6918d6d0bb7b33c7e3e00",
      "closedAt": "2021-06-01T22:11:00Z",
      "mergedAt": "2021-06-01T22:11:00Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "fdbcba1f228273ff37ac7a553754aaa7ff5331db"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczNjI3NzM1",
          "commit": {
            "abbreviatedOid": "a1039c4"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for catching this and writing a PR!",
          "createdAt": "2021-06-01T22:10:56Z",
          "updatedAt": "2021-06-01T22:10:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg4MTgxNzY3",
      "title": "Rename to HTTP Datagrams",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/64",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-12T21:14:23Z",
      "updatedAt": "2021-09-14T16:23:14Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "fdbcba1f228273ff37ac7a553754aaa7ff5331db",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "rename",
      "headRefOid": "2c453b4bfa673f5851f5add0a745dbe40cec4265",
      "closedAt": "2021-07-12T21:32:10Z",
      "mergedAt": "2021-07-12T21:32:10Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "876f1b2b37ca148f3f3f62b7ed66ba107acd314c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0NTU1MDMz",
          "commit": {
            "abbreviatedOid": "7403de5"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T21:21:59Z",
          "updatedAt": "2021-07-12T21:21:59Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "alternatively you could say \r\n\r\n```suggestion\r\nHTTP/2 framing layer. When running over HTTP/1, requests are strictly serialized\r\nin the connection, therefore the first layer of demultiplexing is not needed.\r\n```",
              "createdAt": "2021-07-12T21:21:59Z",
              "updatedAt": "2021-07-12T21:21:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0NTU2OTgx",
          "commit": {
            "abbreviatedOid": "7403de5"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "thanks for this, LGTM modulo the one nit",
          "createdAt": "2021-07-12T21:24:54Z",
          "updatedAt": "2021-07-12T21:24:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 69,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkwMDA2OTg0",
      "title": "Do not convert datagrams to capsules",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/69",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Credit to @bemasc for the proposal on the [mailing list](https://mailarchive.ietf.org/arch/msg/masque/7KJiS6bznHSlCqz1q8HTXoAk0to/).\r\n\r\nCloses #65.",
      "createdAt": "2021-07-14T15:19:47Z",
      "updatedAt": "2021-09-14T16:22:15Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "bfd4d8fea782e7ec879c07b29635233ee9ff1faa",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "mtu",
      "headRefOid": "edf247364dd28569b23002a7c4dd84a48d89726c",
      "closedAt": "2021-07-15T16:21:28Z",
      "mergedAt": "2021-07-15T16:21:28Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "53cab196b6afed5bd9e950c84aa645d13868c0b4"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "reading this in isolation, I'm a but unsure what the \"effectiveness of DPLPMTUD\" is supposed to mean.\r\n\r\nIs there something implied here about how the intermediary will pack DATAGRAM frames into QUIC packets? For instance, is it being suggested that to make this work, we really need the intermediary not to pack out the size with other things?",
          "createdAt": "2021-07-14T16:04:39Z",
          "updatedAt": "2021-07-14T16:04:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The intent was to enable \"end-to-end application DPLPMTUD\" though I couldn't come up with a clear and concise name for it - in other words, there will be an application protocol that is running over HTTP Datagrams, and this is about the endpoints of that application performing DPLPMTUD at their layer. Does that make sense? If so, do you have thoughts on how best to word that?",
          "createdAt": "2021-07-14T16:15:13Z",
          "updatedAt": "2021-07-14T16:15:13Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "> Is there something implied here about how the intermediary will pack DATAGRAM frames into QUIC packets?\r\n\r\nThe implication here is that the intermediary (1) knows a lower bound on the QUIC MTU and (2) never adds frames to a packet that is already larger than this bound (if it allows such packets at all).  I believe this is always true for QUIC, although I'm not sure it's stated explicitly anywhere.",
          "createdAt": "2021-07-14T16:25:59Z",
          "updatedAt": "2021-07-14T16:25:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc can you clarify what you meant by \"a lower bound on the QUIC MTU\" ? The MTU can change dynamically due to changes outside of QUIC's control so the only real lower bound is 1200 - and we need to be able to send packets larger than that.",
          "createdAt": "2021-07-14T16:35:19Z",
          "updatedAt": "2021-07-14T16:35:19Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "I mean that, at any given time, a QUIC endpoint has a lower bound L on the estimated path MTU.  This lower bound is sometimes wrong, but it's never zero.  If an H3 DATAGRAM produces a QUIC packet that is larger than L, we just need to be sure that QUIC won't add other frames to this packet.  (I don't know if QUIC will send this packet or just drop the datagram, but either way, DPLPMTUD on the inner connection will work fine.)",
          "createdAt": "2021-07-14T16:46:28Z",
          "updatedAt": "2021-07-14T16:46:28Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "The `SHOULD NOT` in the PR sounds fine. I'm still confused by the justification though, even after these comments.\r\n\r\n```\r\n           hop 1              hop 2                 hop 3\r\nClient  -->   Intermediary A  -->   Intermediary B  --> Target\r\n```\r\n\r\nFor hop2, which is QUIC, it must have a minimum PMTU of 1200. The maximum PMTU could be bigger. The maximum QUIC packet size that can be sent should be the min(max MTU, max_udp_payload_size advertised by peer). After the intermediary gets the H3 DATAGRAM payload, it will need to reencode it. We're suggesting into a QUIC DATAGRAM frame, with H3 DATAGRAM headers. This reencoding could have different overhead sizes (hop2 might have larger QUIC packet overheads, or H3 DATAGRAM overheads.\r\n\r\nIs the suggestion that the intermediary is using a PMTU size P1, and if it sees a H3 DATAGRAM that would produce a packet larger that P1, it should try to send it as a sort of probe? \r\n ",
          "createdAt": "2021-07-14T17:44:20Z",
          "updatedAt": "2021-07-14T17:44:50Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "> This reencoding could have different overhead sizes (hop2 might have larger QUIC packet overheads, or H3 DATAGRAM overheads.\r\n\r\nThat's fine, so long as the overhead of each hop rarely changes.\r\n\r\n> Is the suggestion that the intermediary is using a PMTU size P1, and if it sees a H3 DATAGRAM that would produce a packet larger that P1, it should try to send it as a sort of probe?\r\n\r\nIt could try to send it, or it could drop it.  (It's not much of a \"probe\", since the intermediary won't necessarily know if it was dropped.)  Either way, the end-to-end DPLPMTUD will converge to some working value, which is all that matters.",
          "createdAt": "2021-07-14T17:48:08Z",
          "updatedAt": "2021-07-14T17:48:08Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "So, can we remove this statement wrt to DPLPMTUD? I don't know what I'm supposed to apply it to.",
          "createdAt": "2021-07-14T17:52:16Z",
          "updatedAt": "2021-07-14T17:52:16Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK removing it, but in general I think it would be helpful to have the draft explain why that SHOULD NOT is there. And the motivation is to allow e2e DPLPMTUD. Because if the intermediary reencodes as capsules some of the time, the application-endpoints won't be able to get a sense for what packet sizes get through or not.",
          "createdAt": "2021-07-14T20:08:32Z",
          "updatedAt": "2021-07-14T20:08:32Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "What you just said is much clearer than the proposed text. \r\n\r\nLonger term, I think what we'll probably end up with is a whole section that collects intermediary concerns. But until we arrive at that point, a better way to present the matter at hand could be something like the following, which is intended to follow on the theme of discussion from the paragraphs in that section.\r\n\r\n\"Intermediaries that receive HTTP Datagrams in QUIC DATAGRAM frames need to decide how to forward them. If the onward connection supports QUIC DATAGRAM frames, intermediaries SHOULD attempt to forward HTTP Datagrams in a QUIC frame. If the HTTP Datagram is too large to fit in a QUIC frame, the intermediary SHOULD drop it. This preserves the end-to-end unreliability characteristic that methods such as DPLPMTUD depend on. An intermediary that forwards HTTP Datagrams in DATAGRAM capsules allows HTTP Datagrams to be arbitrarily large. This can misrepresent the true path properties, defeating methods such a DPLPMTUD.\"\r\n\r\n\r\n\r\n",
          "createdAt": "2021-07-15T00:06:56Z",
          "updatedAt": "2021-07-15T00:06:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I like that, @LPardue. I've updated the text based on your comment, let me know what you think.",
          "createdAt": "2021-07-15T00:20:10Z",
          "updatedAt": "2021-07-15T00:20:10Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "So this is the first step to drop them. However, I am fairly convinced that we also need the signal to the Intermediaries when they need to send a HTTP datagram over the reliable stream instead of over the QUIC Datagram. Otherwise we will have MTU black holes for the minimal IPv6 packet size. ",
          "createdAt": "2021-07-15T08:15:28Z",
          "updatedAt": "2021-07-15T08:15:28Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "To expand on my previous comment. At least in CONNECT-IP and I think also for CONNECT-UDP. We do need a solution to ensure that we can tunnel and not blackhole inner payloads that correspond to the IPv6 minimal packet size. So for Connect-IP with all the overhead we need to send HTTP datagram containing a payload for 1280 IPv6 packets, otherwise we are not IPv6 compliant. For CONNECT-UDP this is not as clearly required as in the case of IPv6, however I think it would be a tradgic if this solution couldn't handle the required smallest allowed size of QUIC initial packets. \r\n\r\nThat is why I think we need to have a solution where the endpoint can be certain that even if less efficient that the packets make it through if they are below these minimal sizes. ",
          "createdAt": "2021-07-15T08:31:22Z",
          "updatedAt": "2021-07-15T08:31:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds like a form of fragmentation to me. I'd rather fail hard than be fooled by unknown intermediaries that the path supports the size required. \r\n\r\nInstead of signalling the explicit MTUs as suggested on the mialing list, what about a capsule type equivalent to PTB that could be returned to the client to indicate something was too large and dropped. Then the client can make the active decision whether to reduce size (if possible) or retry by putting the HTTP Datagram in a DATAGRAM capsule itself.",
          "createdAt": "2021-07-15T11:16:23Z",
          "updatedAt": "2021-07-15T11:16:23Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "@LPardue that I think works for me. In fact I think that is a better solution then the boundary value which requires state keeping and allows the HTTP endpoint to decided what to do. Also it can provide an endpoint with the actual current MTU. It is only executed when you can't forward the HTTP Datagram so it appear simpler than my original idea which would have needed cross layer interaction on changes in lower layers independent of when it occurs. \r\n\r\nBut, yes this is fragmentation and reassembly. Just the matter that we have the facilities available in the form of QUIC streams or TCP. ",
          "createdAt": "2021-07-15T12:01:30Z",
          "updatedAt": "2021-07-15T12:02:31Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "I think a PTB reply is likely unnecessary complexity.  Anything on CONNECT-IP has to exit the tunnel eventually, and it still needs PMTUD on that path.  ICMP connectivity is not reliable, so PLPMTUD is mandatory regardless, and will automatically handle any bottlenecks in the tunnel without the need for PTB.",
          "createdAt": "2021-07-15T14:28:18Z",
          "updatedAt": "2021-07-15T14:28:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "just to clarify a little, I didn't mean a literal PTB. I meant to address Magnus' point that an end-to-end QUIC connection could fail to even get an client Initial through because the intermediary willingfully dropped it. A client might benefit from an immediate signal from the intermediary in such a case. I'm not sworn to this idea though.",
          "createdAt": "2021-07-15T14:41:12Z",
          "updatedAt": "2021-07-15T14:41:12Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "Note that in CONNECT-UDP, the Initial should almost always travel in a CAPSULE, so it can be sent immediately (\"false start\") without worrying about reordering or packet loss.  That has ... interesting implications for MTU.",
          "createdAt": "2021-07-15T14:44:40Z",
          "updatedAt": "2021-07-15T14:44:40Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "interesting, I hadn't thought of doing that. Right now my implementation buffers received datagrams, so whether I receive the DATAGRAM frame before a corresponding HEADERS is negligible. \r\n\r\nAgree it might have interesting implications.",
          "createdAt": "2021-07-15T15:18:07Z",
          "updatedAt": "2021-07-15T15:18:07Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "@bemasc I don't think it is sufficient for us to simply declare that it is someone else problem with the MTU. From an Internet Architecture perspective the MASQUE tunnel is the equivalent of a link layer. There are certain requirements on link layers that carry IP packets, especially IPv6 packets. This requires support of the 1280 MTU, so we need a solution for that case. \r\n\r\nSecondly, I am a bit intrigued by your statement that in the case of Connect-UDP the first UDP packets would travel as capsule. I don't think the HTTP Datagram mandates that in any way. To my understanding, which appears to match @LPardue ones. Is that one can send a Connect-UDP request, followed by a HTTP Datagram context registration capsules for the needed Context IDs and then send HTTP Datagrams. There is nothing in the protocol that prevents this. Our Connect-UDP implementation will buffer these early HTTP datagrams and provide them to the Masque Server when it has processed the registration to create the IP/UDP packets based on the payload. \r\n\r\n",
          "createdAt": "2021-07-15T15:41:15Z",
          "updatedAt": "2021-07-15T15:41:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi folks, as per [our GitHub process](https://datatracker.ietf.org/doc/html/rfc8874#section-4.2.1) let's have this discussion somewhere that's not a GtiHub PR. I'd suggest [Magnus' email thread](https://mailarchive.ietf.org/arch/msg/masque/_fiWFDqS4UDKECR_cQW4bswhUkY/).\r\n\r\nSince I haven't heard any objections on the text in this PR, I'm going to merge it. Let's discuss on the list whether we think more should be done about MTU or not.",
          "createdAt": "2021-07-15T16:21:23Z",
          "updatedAt": "2021-07-15T16:21:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2ODIzMTEy",
          "commit": {
            "abbreviatedOid": "77d6ec4"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-15T00:31:03Z",
          "updatedAt": "2021-07-15T00:31:03Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Can we avoid using MTU here? https://www.rfc-editor.org/rfc/rfc9000.html#section-14 is relevant, unfortunately it calls it \"Datagram size\" which is a world of hurt. But the important thing is that the forwarding is limited by the peer just as much as the path. \r\n\r\n> Enforcement of the max_udp_payload_size transport parameter (Section 18.2) might act as an additional limit on the maximum datagram size.\r\n\r\nWould \"maximum UDP payload size (Section 18.2; RFC 9000)\" work as a replacement.",
              "createdAt": "2021-07-15T00:31:03Z",
              "updatedAt": "2021-07-15T00:31:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2ODI4Mzkw",
          "commit": {
            "abbreviatedOid": "77d6ec4"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-15T00:47:25Z",
          "updatedAt": "2021-07-15T00:47:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Can you clarify why would we want to avoid using MTU?",
              "createdAt": "2021-07-15T00:47:25Z",
              "updatedAt": "2021-07-15T00:47:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2ODM5MDEz",
          "commit": {
            "abbreviatedOid": "77d6ec4"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-15T01:17:55Z",
          "updatedAt": "2021-07-15T01:17:55Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Mainly because all of the hoops that RFC 9000 jumps through in order to spell out considerations for QUIC packet sizes beyond just MTU.\r\n\r\nIn the simplest sense, if an operator has configured a network in such a way to believes that MTU of the single hop is 1600 but the QUIC endpoints both advertise a max_udp_payload_size TP of 1400, they might be surprised when the larger size isn't used.",
              "createdAt": "2021-07-15T01:17:55Z",
              "updatedAt": "2021-07-15T01:17:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2ODQzNDky",
          "commit": {
            "abbreviatedOid": "edf2473"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-15T01:30:14Z",
          "updatedAt": "2021-07-15T01:30:14Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "That makes sense. How about phrasing it as examples (see latest commit)",
              "createdAt": "2021-07-15T01:30:14Z",
              "updatedAt": "2021-07-15T01:30:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2ODQ0OTEw",
          "commit": {
            "abbreviatedOid": "edf2473"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-15T01:34:23Z",
          "updatedAt": "2021-07-15T01:34:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2ODQ1MDI0",
          "commit": {
            "abbreviatedOid": "edf2473"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-15T01:34:40Z",
          "updatedAt": "2021-07-15T01:34:41Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "great, ship it!",
              "createdAt": "2021-07-15T01:34:41Z",
              "updatedAt": "2021-07-15T01:34:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkwMDQ3MjYw",
      "title": "Specify how to support multiple drafts",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/70",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will help interop efforts before publication.",
      "createdAt": "2021-07-14T16:12:02Z",
      "updatedAt": "2021-09-14T16:22:21Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "bfd4d8fea782e7ec879c07b29635233ee9ff1faa",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "drafts",
      "headRefOid": "7ce765111d68ebba7288a24550a40a69fbcc511c",
      "closedAt": "2021-07-14T21:23:51Z",
      "mergedAt": "2021-07-14T21:23:51Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "a682a0ff73eb7ed867a090ce255c3910af2eb7f3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NDg0Nzk0",
          "commit": {
            "abbreviatedOid": "224e51d"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-14T16:28:50Z",
          "updatedAt": "2021-07-14T16:28:50Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "This is a good change.\r\n\r\nOne thought, since `H3_DATAGRAM` is just a logical identifier we could have encoded the draft version into it and made it easier to talk about. But I think that ship has probably sailed.",
              "createdAt": "2021-07-14T16:28:50Z",
              "updatedAt": "2021-07-14T16:28:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NDg5MDQx",
          "commit": {
            "abbreviatedOid": "224e51d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-14T16:33:12Z",
          "updatedAt": "2021-07-14T16:33:12Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Agreed. That's what I plan on doing in our code. I think using `H3_DATAGRAM` in the draft and when it's ambiguous in email or code using `H3_DATAGRAM-03` seems fine.",
              "createdAt": "2021-07-14T16:33:12Z",
              "updatedAt": "2021-07-14T16:33:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NDkzOTg0",
          "commit": {
            "abbreviatedOid": "224e51d"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-14T16:38:28Z",
          "updatedAt": "2021-07-14T16:38:28Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "this is a _little_ lose. I'm likely to write an implementation that supports both but would provide an option to let people run a client or server instance that supports a) supports multiple version b) only one version. This is important if I want to force testing of a newer version without falling back to an older one. \r\n\r\nFor a suggested rewording:\r\n```suggestion\r\nincompatible changes. Multiple draft versions MAY be supported by either\r\nendpoint in a connection. Such endpoints must MUST send multiple values for\r\nH3_DATAGRAM. Once an endpoint has sent and received SETTINGS, it MUST compute\r\n```",
              "createdAt": "2021-07-14T16:38:28Z",
              "updatedAt": "2021-07-14T16:38:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NDk5MzQy",
          "commit": {
            "abbreviatedOid": "224e51d"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-14T16:44:13Z",
          "updatedAt": "2021-07-14T16:44:13Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Do we want to say anything about when the intersection is empty? Perhaps it's useful to close the connection with a specific error code like \"H3_DATAGRAM_REQUIRED\" or something. The receiving endpoint can then use that to see if it is due to mismatched sets, or that the peer was hoping for datagrams where they'll never be supported.",
              "createdAt": "2021-07-14T16:44:13Z",
              "updatedAt": "2021-07-14T16:44:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NDk5ODQy",
          "commit": {
            "abbreviatedOid": "224e51d"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-14T16:44:45Z",
          "updatedAt": "2021-07-14T16:44:45Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "WFM",
              "createdAt": "2021-07-14T16:44:45Z",
              "updatedAt": "2021-07-14T16:44:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NjY5OTAy",
          "commit": {
            "abbreviatedOid": "7ce7651"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-14T20:03:39Z",
          "updatedAt": "2021-07-14T20:03:39Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Merged without the \"must MUST\"",
              "createdAt": "2021-07-14T20:03:39Z",
              "updatedAt": "2021-07-14T20:03:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NjcxMDQx",
          "commit": {
            "abbreviatedOid": "7ce7651"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-14T20:05:06Z",
          "updatedAt": "2021-07-14T20:05:06Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think that degrades easily to the case where the peer doesn't support datagram? Adding that error sounds reasonable, but is orthogonal to the multiple drafts question. Maybe file an issue and we can bring it up at 111?",
              "createdAt": "2021-07-14T20:05:06Z",
              "updatedAt": "2021-07-14T20:05:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NzA5ODk4",
          "commit": {
            "abbreviatedOid": "7ce7651"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-14T20:52:41Z",
          "updatedAt": "2021-07-14T20:52:41Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I'm happy to punt a special close code to a new issue but I think we need to fix this text up a bit more. The more i think about it, the more I'm unsure what the intent is.\r\n\r\nSection 6 doesn't do a brilliant job of stating if both ends have to send a setting with value 1 in order for H3 Datagram to function or not. Theoretically, you could use true QUIC datagrams in one direction and datagram capsules in another (I'm not vouching to actually do that fwiw).\r\n\r\nExtending to this PR, all one way to interpret this is that only the versions have to intersect. Not the values (0 or 1). It's implied that an endpoint advertises support with 1. But if I send you \"old 0\" and \"new 1\" and you send \"old 1\" then interop might fail because we agreed on a version but not how to use it.",
              "createdAt": "2021-07-14T20:52:41Z",
              "updatedAt": "2021-07-14T20:52:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NzMzMzMw",
          "commit": {
            "abbreviatedOid": "7ce7651"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-14T21:23:47Z",
          "updatedAt": "2021-07-14T21:23:48Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Discussed offline, let's merge this and have a follow up to clean up the exact semantics of the setting",
              "createdAt": "2021-07-14T21:23:47Z",
              "updatedAt": "2021-07-14T21:23:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkwMjM4MzQ1",
      "title": "Clarify meaning of setting",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/71",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-14T21:31:03Z",
      "updatedAt": "2021-07-14T21:42:19Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "a682a0ff73eb7ed867a090ce255c3910af2eb7f3",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "setting",
      "headRefOid": "7b1c46c82ebae4716850602711ecb73ca968c5de",
      "closedAt": "2021-07-14T21:42:18Z",
      "mergedAt": "2021-07-14T21:42:18Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "8ec257e7ae875b633603d11b68473d020c50d3dc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NzQxMTkw",
          "commit": {
            "abbreviatedOid": "7b1c46c"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-14T21:35:19Z",
          "updatedAt": "2021-07-14T21:35:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkwMzI0MDQ1",
      "title": "Disallow sending REGISTER_DATAGRAM_CONTEXT for peer's contexts",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/72",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/48 we should disallow echoing a peer's registration, and more generally registering any of the peer's context IDs.",
      "createdAt": "2021-07-15T01:27:45Z",
      "updatedAt": "2021-09-14T16:22:19Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "8ec257e7ae875b633603d11b68473d020c50d3dc",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "no_register_peer",
      "headRefOid": "18f9e7b5cf19eafe0e95bbc1bdf81762b1009177",
      "closedAt": "2021-07-15T01:39:02Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2ODQ0NTgz",
          "commit": {
            "abbreviatedOid": "18f9e7b"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-15T01:33:26Z",
          "updatedAt": "2021-07-15T01:33:26Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Am I missing something or is this jut duplicating what is already on L291-295?",
              "createdAt": "2021-07-15T01:33:26Z",
              "updatedAt": "2021-07-15T01:33:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2ODQ2NTUz",
          "commit": {
            "abbreviatedOid": "18f9e7b"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-15T01:38:55Z",
          "updatedAt": "2021-07-15T01:38:55Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Nope you are correct. I need to step away from the computer and go do something else for a bit :-)",
              "createdAt": "2021-07-15T01:38:55Z",
              "updatedAt": "2021-07-15T01:38:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk0NDI3OTc2",
      "title": "make CAPSULE frame ordering wrt HEADERS a global requirement",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/76",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes the requirement global to clients, servers, and\r\nintermediaries.\r\n\r\ncloses #73 ",
      "createdAt": "2021-07-21T14:30:13Z",
      "updatedAt": "2021-09-14T16:23:52Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "53cab196b6afed5bd9e950c84aa645d13868c0b4",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "lucas/fix-73",
      "headRefOid": "20a264e2579de5d596312c3ce463f9a42020305a",
      "closedAt": "2021-07-22T14:52:58Z",
      "mergedAt": "2021-07-22T14:52:58Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "9fc07bd27d52255614261d31fe304c2016007632"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "@lnicco does the PR address your issue?",
          "createdAt": "2021-07-21T23:40:54Z",
          "updatedAt": "2021-07-21T23:40:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "merging, please reopen the ticket if you need anything more",
          "createdAt": "2021-07-22T14:52:42Z",
          "updatedAt": "2021-07-22T14:52:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEyMjU5OTMz",
          "commit": {
            "abbreviatedOid": "20a264e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-21T23:08:09Z",
          "updatedAt": "2021-07-21T23:08:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk0NDI4ODUw",
      "title": "intermediaries do not have to buffer DATAGRAMs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/77",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #75 ",
      "createdAt": "2021-07-21T14:30:50Z",
      "updatedAt": "2021-09-14T16:22:25Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "53cab196b6afed5bd9e950c84aa645d13868c0b4",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "lucas/fix-75",
      "headRefOid": "3af0ba91ee65057abdb09bcf6ee66b7b6e578fac",
      "closedAt": "2021-07-22T14:52:15Z",
      "mergedAt": "2021-07-22T14:52:15Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "59535d1da4b7a94fc31838e8b874d0b5e2ce0b80"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEyMjU2MjUz",
          "commit": {
            "abbreviatedOid": "3af0ba9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-21T22:59:36Z",
          "updatedAt": "2021-07-21T22:59:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NTEyNjgy",
      "title": "Intensive, not incentive",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/80",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-22T21:09:16Z",
      "updatedAt": "2021-07-22T21:33:11Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "9fc07bd27d52255614261d31fe304c2016007632",
      "headRepository": "MikeBishop/draft-ietf-masque-h3-datagram",
      "headRefName": "patch-1",
      "headRefOid": "6778a2aa6871fac9762aa6312e64627fdc93d4bd",
      "closedAt": "2021-07-22T21:33:11Z",
      "mergedAt": "2021-07-22T21:33:11Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "f239497fbdf99754b2354bb0b047812aefbe250c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzMjUzNDU3",
          "commit": {
            "abbreviatedOid": "6778a2a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-22T21:32:57Z",
          "updatedAt": "2021-07-22T21:32:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 82,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2MTgwMjIw",
      "title": "split the DATAGRAM capsule",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/82",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #81.\r\n\r\nThis follows the explicit naming from REGISTER_CONTEXT and REGISTER_NO_CONTEXT but I've purposely defined both capsule types in the same section because the substantive considerations for both are mostly identical and I don't like duplication.\r\n\r\nPreviously we discussed the optionality of parsing the Context ID field. This change replaces that with requirements on endpoints to send the right datagram type, and reject the wrong datagram type, depending on the registration.",
      "createdAt": "2021-07-23T19:59:48Z",
      "updatedAt": "2021-10-20T23:18:19Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "f239497fbdf99754b2354bb0b047812aefbe250c",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "lucas/split-datagram-capsule",
      "headRefOid": "5832935289df025f44931a64e2ab85ebf6a4a48d",
      "closedAt": "2021-10-20T23:11:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I now realize the diff looks big but most of the later paragraphs are just substituting \"DATAGRAM Capsule\" and reflowing the text.",
          "createdAt": "2021-07-23T20:01:23Z",
          "updatedAt": "2021-07-23T20:01:23Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I agree with this direction, let's discuss on the issue (#81).",
          "createdAt": "2021-07-24T16:59:29Z",
          "updatedAt": "2021-07-24T16:59:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Ack",
          "createdAt": "2021-07-24T17:32:03Z",
          "updatedAt": "2021-07-24T17:32:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this since it has been overtaken by other design changes like Capsule",
          "createdAt": "2021-10-20T23:11:08Z",
          "updatedAt": "2021-10-20T23:11:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxMDA5MzIy",
      "title": "Editorial: fix tables",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/86",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #83 ",
      "createdAt": "2021-09-09T22:28:40Z",
      "updatedAt": "2021-09-09T22:31:13Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "f239497fbdf99754b2354bb0b047812aefbe250c",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "bobby_tables",
      "headRefOid": "7fe60a982b4babc9724ad5c47df6dddb7be68875",
      "closedAt": "2021-09-09T22:31:06Z",
      "mergedAt": "2021-09-09T22:31:06Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "1e96740dba46fd700afe72e6bf1eb1f187347658"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 87,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxMDEyOTY4",
      "title": "Clarify that the H3_DATAGRAM setting applies only to datagrams",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/87",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per h3 rules, it's fine to send capsules without a setting. The setting is about the semantics of datagrams. Also remove the requirement to send the datagram transport parameter because we now have capsules.\r\n\r\nCloses #85 ",
      "createdAt": "2021-09-09T22:37:56Z",
      "updatedAt": "2021-09-09T23:33:00Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "1e96740dba46fd700afe72e6bf1eb1f187347658",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "setting_again",
      "headRefOid": "b70a4f9f8226ddd193d9bfc6ec7e7192e2012ccc",
      "closedAt": "2021-09-09T23:32:42Z",
      "mergedAt": "2021-09-09T23:32:42Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "e05bacf55124c05e73f020cdb612d32f737a04e6"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm a bit confused about this one with the removal of the requirement. What purpose does the setting have now? Is it \"I'm an endpoint that supports both H3 DATAGRAM frame and DATAGRAM capsule\"? If so, using settings doesn't seem to gel well with the possible change of capsules to be conveyed in the datastream rather than in a CAPSULE frame.\r\n\r\n",
          "createdAt": "2021-09-09T22:54:49Z",
          "updatedAt": "2021-09-09T22:54:49Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed offline and clarified. This spec defines the format of DATAGRAM frame or capsule.  The  SETTING helps articulate how the endpoint intends to consume things it receives. \r\n\r\nThis might raise some interesting questions if someone tries to define a new formation the future. But they'll have to solve the problem they've made for themselves. This is fine as it is.",
          "createdAt": "2021-09-09T23:31:30Z",
          "updatedAt": "2021-09-09T23:31:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTI1Nzc3",
          "commit": {
            "abbreviatedOid": "b70a4f9"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-09T23:31:38Z",
          "updatedAt": "2021-09-09T23:31:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 88,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxMDk0MTg1",
      "title": "Move capsules to the data stream",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/88",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-10T01:49:54Z",
      "updatedAt": "2021-09-10T01:50:53Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "2709a3a46c3eec6a31e7c108fadf89828b1eda79",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "capsule_data",
      "headRefOid": "ee775464b48d86fdc7a449ad990c374da07b61a8",
      "closedAt": "2021-09-10T01:50:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxMDk0NTky",
      "title": "Move capsules to the data stream",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/89",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-10T01:51:18Z",
      "updatedAt": "2021-09-10T17:54:04Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "6181f2846574e0d07bc666bfb3f03dac8f8c0f9c",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "capsule_data",
      "headRefOid": "34387306609f2f64388acdf6a4d09ea08587c441",
      "closedAt": "2021-09-10T17:54:02Z",
      "mergedAt": "2021-09-10T17:54:02Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "1531b37163ff6bdd1d1d2a7fbe33489fedf685cd"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Had offline conversation with Lucas, conclusion was that this is good enough to merge to allow interop - we'll have plenty of time to figure out details in subsequent issues and PRs.",
          "createdAt": "2021-09-10T17:53:57Z",
          "updatedAt": "2021-09-10T17:53:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxNTM1NTQ4",
          "commit": {
            "abbreviatedOid": "ee77546"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-10T15:26:37Z",
          "updatedAt": "2021-09-10T16:41:42Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "HTTP/1.1 description is slightly broken for some kinds of 1xx response. E.g. where a server responds with 100 then 101, I expect the data stream is everything after the 101's field section. Or a more realistic sequence for our uses with extended CONNECT is a 1xx then an 2xx, the data stream being everything after the 2xx.",
              "createdAt": "2021-09-10T15:36:21Z",
              "updatedAt": "2021-09-10T16:41:42Z"
            },
            {
              "originalPosition": 26,
              "body": "It might help to highlight here that this is not HTTP message content in some way.",
              "createdAt": "2021-09-10T15:38:03Z",
              "updatedAt": "2021-09-10T16:41:42Z"
            },
            {
              "originalPosition": 90,
              "body": "Are we really saying that request _and_ response messages have no content? In which case, are *any* fields that relate to content prohibited, or only the two explicitly mentioned?",
              "createdAt": "2021-09-10T15:59:38Z",
              "updatedAt": "2021-09-10T16:41:42Z"
            },
            {
              "originalPosition": 112,
              "body": "assume \"modification\" of a capsule is really remove and add?",
              "createdAt": "2021-09-10T16:40:40Z",
              "updatedAt": "2021-09-10T16:41:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxNjIwMDc3",
          "commit": {
            "abbreviatedOid": "3438730"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-10T17:03:12Z",
          "updatedAt": "2021-09-10T17:04:40Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Done",
              "createdAt": "2021-09-10T17:03:12Z",
              "updatedAt": "2021-09-10T17:04:40Z"
            },
            {
              "originalPosition": 90,
              "body": "I added a note about response, we can add more headers in a followup?",
              "createdAt": "2021-09-10T17:03:31Z",
              "updatedAt": "2021-09-10T17:04:40Z"
            },
            {
              "originalPosition": 112,
              "body": "Clarified that modification of the data of transparent capsules is OK, after all it's isomorphic to remove + add",
              "createdAt": "2021-09-10T17:03:58Z",
              "updatedAt": "2021-09-10T17:04:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxNjIxNjI1",
          "commit": {
            "abbreviatedOid": "3438730"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-10T17:05:10Z",
          "updatedAt": "2021-09-10T17:05:10Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Fixed",
              "createdAt": "2021-09-10T17:05:10Z",
              "updatedAt": "2021-09-10T17:05:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 90,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxNjg4ODA3",
      "title": "Use of contexts is not negotiated, it is decided unilaterally by the client",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/90",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #78",
      "createdAt": "2021-09-10T19:00:25Z",
      "updatedAt": "2021-09-10T19:01:15Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "1531b37163ff6bdd1d1d2a7fbe33489fedf685cd",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "no_negotiation",
      "headRefOid": "1752605549748a53f1d283297a7e59e43707a571",
      "closedAt": "2021-09-10T19:01:13Z",
      "mergedAt": "2021-09-10T19:01:13Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "72eca3b5134a8dcf346738ce0ec338c20a94a6e7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 91,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxNzE3OTA3",
      "title": "Rework how datagram format extensibility works",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/91",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After spending some time on CONNECT-IP, I realized that the current design won't work well. The primary motivation for including contexts and formatting in this document (as opposed to in the individual drafts) is that it allows to build a layer that can handle extensions without round trip negotiations: in particular it means clients can start using an extension format immediately without waiting for the HTTP response. For that to work, the server needs to drop unknown formats, so we need a single format enum as opposed to a list of them - that way the entire context is ignored instead of accepting the context but ignoring the extension that might have changed the encoding.\r\n\r\n[Rendered view of this PR here](https://ietf-wg-masque.github.io/draft-ietf-masque-h3-datagram/rework_extensibility/draft-ietf-masque-h3-datagram.html).\r\n\r\nCloses #66.\r\nCloses #79.",
      "createdAt": "2021-09-10T19:53:24Z",
      "updatedAt": "2021-09-21T00:30:41Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "5e9027f1a45cda7fb90709bacd17dcb19a3eebc8",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "rework_extensibility",
      "headRefOid": "a478652c0993bb0764677768062891e5d0c8682b",
      "closedAt": "2021-09-21T00:30:34Z",
      "mergedAt": "2021-09-21T00:30:34Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "7c234e11a490cb824408da406bc696458752ac44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4tLxKU",
          "commit": {
            "abbreviatedOid": "69b6800"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-18T12:45:47Z",
          "updatedAt": "2021-09-20T23:40:10Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I read this sentence a few times and still how minor difficulty parsing it (in the context of the surrounding sentences). I don't have an immediate suggestion to improve readability though.\r\n\r\nLooking at the example below, it seems this PR is proposing that the nature of DATAGRAM payload **always** has to be communicated by the type. That didn't used to be the case. ",
              "createdAt": "2021-09-20T23:29:15Z",
              "updatedAt": "2021-09-20T23:40:10Z"
            },
            {
              "originalPosition": 13,
              "body": "Following from the above comment, since it sounds like datagrams always have a format, maybe it would be better to call this \"Datagram Format Additional Data\" to clearly mark it as separate to actual datagram data? ",
              "createdAt": "2021-09-20T23:40:03Z",
              "updatedAt": "2021-09-20T23:40:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4tQFLa",
          "commit": {
            "abbreviatedOid": "69b6800"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-20T23:45:23Z",
          "updatedAt": "2021-09-20T23:45:24Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "That's right, the idea would be to now always have an explicit type",
              "createdAt": "2021-09-20T23:45:23Z",
              "updatedAt": "2021-09-20T23:45:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4tQFey",
          "commit": {
            "abbreviatedOid": "a478652"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-20T23:48:32Z",
          "updatedAt": "2021-09-20T23:48:32Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Good idea, done.",
              "createdAt": "2021-09-20T23:48:32Z",
              "updatedAt": "2021-09-20T23:48:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4tQGqD",
          "commit": {
            "abbreviatedOid": "a478652"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T00:00:34Z",
          "updatedAt": "2021-09-21T00:00:34Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Another reason for rejecting a registration, for example, would be when receiving a Format Type of IP_PACKET on a CONNECT-UDP stream. Perhaps we can defined another code for that obviously broken case?",
              "createdAt": "2021-09-21T00:00:34Z",
              "updatedAt": "2021-09-21T00:00:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4tQHsI",
          "commit": {
            "abbreviatedOid": "a478652"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T00:11:06Z",
          "updatedAt": "2021-09-21T00:11:07Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Agreed, though the reaction to the code would be the same (MUST NOT use this type again) so I don't think we need a separate code",
              "createdAt": "2021-09-21T00:11:07Z",
              "updatedAt": "2021-09-21T00:11:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4tQIOm",
          "commit": {
            "abbreviatedOid": "a478652"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T00:17:07Z",
          "updatedAt": "2021-09-21T00:17:07Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "yeah renaming DENIED to REJECTED and just stating policy or unsupported as examples where to use it could work. It's not a blocker to this PR though",
              "createdAt": "2021-09-21T00:17:07Z",
              "updatedAt": "2021-09-21T00:17:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4tQITH",
          "commit": {
            "abbreviatedOid": "a478652"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-21T00:17:58Z",
          "updatedAt": "2021-09-21T00:17:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDODOpKfc4sV-5d",
      "title": "expand capsule diagrams to include all fields",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/97",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The thing that sucks here is that the diagram won't auto expand `{{iana-types}}`, so we can't easily ref the section. Manually referring to the section is a maintenance pain. So instead just state the actual type in the text an the diagram. I have a feeling you were linking to the section to avoid the maintenance hassle of updating type codes in multiple place. But I'm quite happy to take that burden because I find it more pleasant to read this way.\r\n\r\n\r\nfixes #94 \r\n\r\n",
      "createdAt": "2021-09-27T22:47:20Z",
      "updatedAt": "2021-09-27T23:24:15Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "7c234e11a490cb824408da406bc696458752ac44",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "full-frame-figures",
      "headRefOid": "f171a576954836c33cb3f491faa6ff31c784f416",
      "closedAt": "2021-09-27T23:24:11Z",
      "mergedAt": "2021-09-27T23:24:11Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "c3f5b8bd96cb44da63bb66e7b2d95b7d6fb76220"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Perfectly reasonable",
          "createdAt": "2021-09-27T23:04:39Z",
          "updatedAt": "2021-09-27T23:04:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4tlj7N",
          "commit": {
            "abbreviatedOid": "fa9bb44"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "It's not just a maintenance hassle, I've been guilty of forgetting to update parts of redundant information like this in the past and I don't trust myself to not forget in the future - then you end up with a spec that disagrees with itself. How about instead:\r\n\r\n\r\n```\r\nThe REGISTER_DATAGRAM_CONTEXT capsule (see {{iana-types}} for the value of the\r\ncapsule type) allows an endpoint to inform its peer of the encoding and\r\nsemantics of datagrams associated with a given context ID. Its Capsule Data\r\nfield consists of:\r\n\r\n~~~\r\nREGISTER_DATAGRAM_CONTEXT Capsule {\r\n  Type (i) = REGISTER_DATAGRAM_CONTEXT,\r\n  Length (i),\r\n  Context ID (i),\r\n  Datagram Format Type (i),\r\n  Datagram Format Additional Data (..),\r\n}\r\n~~~\r\n```\r\n\r\nAlso, to state the obvious: when we get to WGLC and don't expect to modify these numbers again, I fully support writing the final values into both the texts and diagrams to improve readability.",
          "createdAt": "2021-09-27T22:56:52Z",
          "updatedAt": "2021-09-27T22:57:20Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "`Its Capsule Data field consists of` is no longer correct, we should rephrase it",
              "createdAt": "2021-09-27T22:56:52Z",
              "updatedAt": "2021-09-27T22:57:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4tlmFB",
          "commit": {
            "abbreviatedOid": "fa9bb44"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-27T23:14:57Z",
          "updatedAt": "2021-09-27T23:14:57Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I vote for just remove it\r\n",
              "createdAt": "2021-09-27T23:14:57Z",
              "updatedAt": "2021-09-27T23:14:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4tlmc-",
          "commit": {
            "abbreviatedOid": "fa9bb44"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-27T23:18:19Z",
          "updatedAt": "2021-09-27T23:18:19Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Fine by me",
              "createdAt": "2021-09-27T23:18:19Z",
              "updatedAt": "2021-09-27T23:18:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4tlnG6",
          "commit": {
            "abbreviatedOid": "f171a57"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-27T23:24:00Z",
          "updatedAt": "2021-09-27T23:24:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDODOpKfc4sqsMt",
      "title": "document the document structure",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/98",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #92 \r\n\r\nerr'ing on the side of succinct ",
      "createdAt": "2021-10-04T23:37:52Z",
      "updatedAt": "2021-10-20T23:17:44Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "c3f5b8bd96cb44da63bb66e7b2d95b7d6fb76220",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "doc-doc-structure",
      "headRefOid": "5cb9e0038dd7c4ccdd18e6d7ffcc7c3f6887982c",
      "closedAt": "2021-10-05T11:26:07Z",
      "mergedAt": "2021-10-05T11:26:06Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "e6dcb2440ddbbd62582c2b22b5919e27cb7cc483"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4t8mzs",
          "commit": {
            "abbreviatedOid": "5cb9e00"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for doing this!",
          "createdAt": "2021-10-04T23:46:53Z",
          "updatedAt": "2021-10-04T23:46:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDODOpKfc4sqtIm",
      "title": "quarter stream ID has a legal range, state it and punishment for brea\u2026",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/99",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026king hte law\r\n\r\nAlso, switch to format to beatuiful superscript HTML rendering as used by RFC 9000.\r\n\r\nfixes #93 ",
      "createdAt": "2021-10-04T23:48:36Z",
      "updatedAt": "2021-10-20T23:17:43Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "c3f5b8bd96cb44da63bb66e7b2d95b7d6fb76220",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "quarter-stream-legal-range",
      "headRefOid": "40dda79fa94035a3dbaef5a99ca5b8b13949aa96",
      "closedAt": "2021-10-05T11:25:53Z",
      "mergedAt": "2021-10-05T11:25:52Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "2b7191459f35e0e57f9ad23a185c4ea2f0ac789b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4t8od1",
          "commit": {
            "abbreviatedOid": "8df31dc"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice. Approved modulo a couple nits",
          "createdAt": "2021-10-05T00:04:33Z",
          "updatedAt": "2021-10-05T00:05:58Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "nit: if you remove the dot, then remove the following uppercase?\r\n```suggestion\r\nbidirectional stream that this datagram is associated with, divided by four (the\r\n```",
              "createdAt": "2021-10-05T00:04:33Z",
              "updatedAt": "2021-10-05T00:05:58Z"
            },
            {
              "originalPosition": 20,
              "body": "That's just too much value :P\r\n```suggestion\r\nso the largest legal value of Quarter Stream ID is 2<sup>62</sup>-1 / 4.\r\n```",
              "createdAt": "2021-10-05T00:05:44Z",
              "updatedAt": "2021-10-05T00:05:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4t8pMy",
          "commit": {
            "abbreviatedOid": "8df31dc"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T00:12:04Z",
          "updatedAt": "2021-10-05T00:12:04Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "derp",
              "createdAt": "2021-10-05T00:12:04Z",
              "updatedAt": "2021-10-05T00:12:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4t8q2F",
          "commit": {
            "abbreviatedOid": "bd22748"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T00:30:18Z",
          "updatedAt": "2021-10-05T00:30:18Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Well now we have an extra dot I think\r\n```suggestion\r\ndivisible by four). The largest legal QUIC stream ID value is 2<sup>62</sup>-1,\r\n```",
              "createdAt": "2021-10-05T00:30:18Z",
              "updatedAt": "2021-10-05T00:30:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 100,
      "id": "PR_kwDODOpKfc4s27XS",
      "title": "state more clearly the purpose of close codes",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/100",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This borrows some of the spin off suggestions made during the discussion on #95. It does not address the issue itself. See that issue for next steps.",
      "createdAt": "2021-10-06T22:14:15Z",
      "updatedAt": "2021-10-20T23:17:42Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "92a45bac93fee117a9acefb920a7c4c348d1b68a",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "close-code-tweaks",
      "headRefOid": "a4a6d41b13eb2fac1d910a660e1c62a749053fc8",
      "closedAt": "2021-10-06T23:50:37Z",
      "mergedAt": "2021-10-06T23:50:37Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "5f4744693785e4f63e121003d19e9e077c743dad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4uF2GX",
          "commit": {
            "abbreviatedOid": "26bfbbd"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approved modulo a typo",
          "createdAt": "2021-10-06T22:26:29Z",
          "updatedAt": "2021-10-06T22:27:14Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\n: This indicates that a context was closed without any action specified for the\r\nreceiver.\r\n```",
              "createdAt": "2021-10-06T22:26:29Z",
              "updatedAt": "2021-10-06T22:27:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4uF25-",
          "commit": {
            "abbreviatedOid": "26bfbbd"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T22:31:21Z",
          "updatedAt": "2021-10-06T22:31:22Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "deliberate mistake to ensure you're attentive, well done.",
              "createdAt": "2021-10-06T22:31:21Z",
              "updatedAt": "2021-10-06T22:31:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 101,
      "id": "PR_kwDODOpKfc4s3GnT",
      "title": "state that data streams can be prioritized",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/101",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #96 ",
      "createdAt": "2021-10-06T22:43:02Z",
      "updatedAt": "2021-10-20T23:17:40Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "92a45bac93fee117a9acefb920a7c4c348d1b68a",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "data-stream-priority",
      "headRefOid": "033cbe4fdebeb81fd96a5fabd2a56026ff5a297e",
      "closedAt": "2021-10-06T23:51:46Z",
      "mergedAt": "2021-10-06T23:51:45Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "95b93dfc8b00bd4e9ec7e5eb6d95f16de47e70a2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4uGAFE",
          "commit": {
            "abbreviatedOid": "033cbe4"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-06T23:51:40Z",
          "updatedAt": "2021-10-06T23:51:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 103,
      "id": "PR_kwDODOpKfc4s6pkU",
      "title": "fix CONNECT-UDP examples",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/103",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #102 ",
      "createdAt": "2021-10-07T22:16:28Z",
      "updatedAt": "2021-10-07T23:39:00Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "73c3d0b8d5d46cf3840a5976fdd204b0fb43f68d",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "example-connect-udp",
      "headRefOid": "7c6ba63de1bc5ee5009f333668f501d7111c92c7",
      "closedAt": "2021-10-07T23:38:57Z",
      "mergedAt": "2021-10-07T23:38:57Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "8d79e92675291ac1ea2cb50a43e296bb35b299fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4uKYXY",
          "commit": {
            "abbreviatedOid": "7c6ba63"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-07T23:13:37Z",
          "updatedAt": "2021-10-07T23:13:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDODOpKfc4tW8aO",
      "title": "Make datagram contexts optional to implement",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/105",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[WebTransport](https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3) uses HTTP Datagrams but doesn't currently have a need for datagram contexts. Because of this, some members of the WebTransport community prefer to not have to implement datagram contexts. This PR changes how datagram contexts are negotiated to make them optional to implement. One important design goal of this change was to allow optimistic use of contexts: in other words, the client shouldn't have to wait a round trip to find out whether contexts are supported before being able to optimistically use them.\r\n\r\nBefore this PR, contexts were mandatory to implement and the client would decide whether to use them by sending either REGISTER_DATAGRAM_CONTEXT or REGISTER_DATAGRAM_NO_CONTEXT.\r\n\r\nWith this PR, endpoints use a new Sec-Use-Datagram-Contexts header to indicate support. The PR makes a few small tweaks to capsules in order to allow the optimistic use described above. In particular, it incorporates the DATAGRAM capsule split from #82 as that allows the client to use contexts before knowing whether the server supports them because the server can just drop the variant of the capsule with contexts.\r\n\r\n[Rendered view of this PR here](https://ietf-wg-masque.github.io/draft-ietf-masque-h3-datagram/context_impl_optional/draft-ietf-masque-h3-datagram.html).",
      "createdAt": "2021-10-19T01:42:38Z",
      "updatedAt": "2021-10-20T23:17:10Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "8d79e92675291ac1ea2cb50a43e296bb35b299fa",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "context_impl_optional",
      "headRefOid": "675c932e786146ef3d57651aa3ee1b67dff1d3d5",
      "closedAt": "2021-10-20T23:17:08Z",
      "mergedAt": "2021-10-20T23:17:07Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "c80be7810297082ca9edb18261da107b4ac2a32c"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "> In particular, it incorporates the DATAGRAM capsule split from #82 as that allows the client to use contexts before knowing whether the server supports them because the server can just drop the variant of the capsule with contexts.\r\n\r\nI've held my finger over the \"close PR\" button a few times on that one :face_with_spiral_eyes: ",
          "createdAt": "2021-10-19T01:45:10Z",
          "updatedAt": "2021-10-19T01:45:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4uuU53",
          "commit": {
            "abbreviatedOid": "6700c11"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "a few nits and minor comments",
          "createdAt": "2021-10-20T00:28:31Z",
          "updatedAt": "2021-10-20T02:58:16Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "```suggestion\r\nImplementations of HTTP Datagrams that support datagram contexts MUST provide\r\n```",
              "createdAt": "2021-10-20T00:28:31Z",
              "updatedAt": "2021-10-20T02:58:16Z"
            },
            {
              "originalPosition": 103,
              "body": "Not sure what you mean here, since there's an error in identifying one type. There's QUIC DATAGRAM frame, HTTP/3 Datagrams and HTTP/3 DATA frames.",
              "createdAt": "2021-10-20T00:31:21Z",
              "updatedAt": "2021-10-20T02:58:16Z"
            },
            {
              "originalPosition": 150,
              "body": "The logical ordering switches part way through the first sentence, which is hard when being introduced to the concepts. So how about something like\r\n\r\n```suggestion\r\nThis document defines the the REGISTER_DATAGRAM and REGISTER_DATAGRAM_CONTEXT\r\ncapsules types (see {{iana-types}}), known collectively as the datagram\r\nregistration capsules. The REGISTER_DATAGRAM capsule is used by endpoints to\r\ninform their peer of the encoding and semantics of all datagrams associated with\r\na stream. The REGISTER_DATAGRAM_CONTEXT capsule is used by endpoints to inform\r\ntheir peer of the encoding and semantics of all datagrams associated with a\r\ngiven context ID, or with all datagrams if context ID.\r\n```",
              "createdAt": "2021-10-20T00:42:15Z",
              "updatedAt": "2021-10-20T02:58:16Z"
            },
            {
              "originalPosition": 538,
              "body": "```suggestion\r\nIn these examples, the client supports a CONNECT-UDP Timestamp Extension, which\r\n```",
              "createdAt": "2021-10-20T00:54:12Z",
              "updatedAt": "2021-10-20T02:58:17Z"
            },
            {
              "originalPosition": 539,
              "body": "```suggestion\r\nuses a different Datagram Format Type that carries a timestamp followed by the\r\n```",
              "createdAt": "2021-10-20T00:54:34Z",
              "updatedAt": "2021-10-20T02:58:17Z"
            },
            {
              "originalPosition": 539,
              "body": "```suggestion\r\nuses a different Datagram Format Type that carries a timestamp followed by the\r\n```",
              "createdAt": "2021-10-20T00:54:42Z",
              "updatedAt": "2021-10-20T02:58:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4uyBBd",
          "commit": {
            "abbreviatedOid": "6700c11"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-20T18:36:47Z",
          "updatedAt": "2021-10-20T18:42:31Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "I'm not sure I understand what you mean, can you elaborate?",
              "createdAt": "2021-10-20T18:36:47Z",
              "updatedAt": "2021-10-20T18:42:31Z"
            },
            {
              "originalPosition": 150,
              "body": "Applied a variation on this text",
              "createdAt": "2021-10-20T18:42:03Z",
              "updatedAt": "2021-10-20T18:42:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4uyH3Y",
          "commit": {
            "abbreviatedOid": "c1b074c"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-20T19:07:13Z",
          "updatedAt": "2021-10-20T19:07:13Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "You say \r\n\r\n> If this QUIC DATAGRAM frame arrives before the QUIC DATA frame\r\n\r\nbut there is no such thing as a QUIC DATA frame",
              "createdAt": "2021-10-20T19:07:13Z",
              "updatedAt": "2021-10-20T19:07:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4uytGT",
          "commit": {
            "abbreviatedOid": "675c932"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-20T22:13:28Z",
          "updatedAt": "2021-10-20T22:13:28Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Ah, right :) I've reworded this to refer to the concept instead of the frame that carries it",
              "createdAt": "2021-10-20T22:13:28Z",
              "updatedAt": "2021-10-20T22:13:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4uy0Q4",
          "commit": {
            "abbreviatedOid": "675c932"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM now, thanks!",
          "createdAt": "2021-10-20T23:08:50Z",
          "updatedAt": "2021-10-20T23:08:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 110,
      "id": "PR_kwDODOpKfc4td5QJ",
      "title": "Whoops, of an editorial nature",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/110",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #108",
      "createdAt": "2021-10-21T00:48:23Z",
      "updatedAt": "2021-10-21T00:48:32Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "c80be7810297082ca9edb18261da107b4ac2a32c",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "whoops",
      "headRefOid": "d05de324aad42355c81695fd6811033a6e80bc4a",
      "closedAt": "2021-10-21T00:48:29Z",
      "mergedAt": "2021-10-21T00:48:29Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "57378112966888943cb02079a6a00235d9d12333"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 112,
      "id": "PR_kwDODOpKfc4t8Sp6",
      "title": "Treat malformed capsules as stream errors",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/112",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Borrowing text from H3.  Also I don't think there is a 'FRAME_ENCODING_ERROR' defined anywhere.",
      "createdAt": "2021-11-01T18:34:10Z",
      "updatedAt": "2021-11-02T23:01:59Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "a8ae65dc2eda7f27a0ef43d39d8dbcb046ae5adb",
      "headRepository": "afrind/draft-ietf-masque-h3-datagram",
      "headRefName": "malformed-capsules",
      "headRefOid": "fc0621657e1315798c97aa0ab16b7cad984d5e7a",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4vW5UO",
          "commit": {
            "abbreviatedOid": "b746e2c"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-01T18:40:48Z",
          "updatedAt": "2021-11-01T18:40:49Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This is a funny one.\r\n\r\nHTTP/3 Datagram is not an HTTP/3 frame, so reporting this error code feels odd. \r\n\r\nI think it was me that picked FRAME_ENCODING_ERROR, which is defined in transport\r\n\r\n> FRAME_ENCODING_ERROR (0x07):  An endpoint received a frame that was\r\n      badly formatted -- for instance, a frame of an unknown type or an\r\n      ACK frame that has more acknowledgment ranges than the remainder\r\n      of the packet could carry.\r\n\r\nBut really, this is not a problem in the transport layer, and that also feels wrong now I think about it. I think the answer is a new application-layer `H3_DATAGRAM_ERROR`.",
              "createdAt": "2021-11-01T18:40:49Z",
              "updatedAt": "2021-11-01T18:40:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vW6TH",
          "commit": {
            "abbreviatedOid": "b746e2c"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-01T18:45:27Z",
          "updatedAt": "2021-11-01T18:45:27Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nidentified fields or a capsule payload that terminates before the end of the\r\n```",
              "createdAt": "2021-11-01T18:45:27Z",
              "updatedAt": "2021-11-01T18:45:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vW6WR",
          "commit": {
            "abbreviatedOid": "b746e2c"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-01T18:45:40Z",
          "updatedAt": "2021-11-01T18:45:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I totally agree that borrowing error codes from lower level protocols is weird.  \r\n\r\nH3_DATAGRAM_ERROR works when processing HTTP/3 DATAGRAMs.  But the capsule length errors don't fit with that.  Does Capsule Protocol needs its own error code range too (it can be conveyed over non-H3)?",
              "createdAt": "2021-11-01T18:45:40Z",
              "updatedAt": "2021-11-01T18:45:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vW6ZK",
          "commit": {
            "abbreviatedOid": "b746e2c"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-01T18:45:51Z",
          "updatedAt": "2021-11-01T18:45:51Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "as I said on the issue, this isn't an HTTP/3 frame error. Furthermore, we need to cover error handling for all HTTP versions; in H2 and H3 that's a stream error, in HTTP/1.1 it means tearing down the whole thing (which I think is acceptable because there is no way to recover the data stream) at this point.",
              "createdAt": "2021-11-01T18:45:51Z",
              "updatedAt": "2021-11-01T18:45:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vW6pJ",
          "commit": {
            "abbreviatedOid": "e6ecc9b"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-01T18:47:04Z",
          "updatedAt": "2021-11-01T18:47:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I agree these are two different types of error",
              "createdAt": "2021-11-01T18:47:04Z",
              "updatedAt": "2021-11-01T18:47:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vXITG",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-01T19:55:29Z",
          "updatedAt": "2021-11-01T19:55:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Can we define a new DATAGRAM_ERROR? That'll be more helpful than TBD",
              "createdAt": "2021-11-01T19:55:29Z",
              "updatedAt": "2021-11-01T19:55:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vXIcb",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-01T19:56:11Z",
          "updatedAt": "2021-11-01T19:56:11Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Can we define a new CAPSULE_ERROR? That'll be more helpful than TBD",
              "createdAt": "2021-11-01T19:56:11Z",
              "updatedAt": "2021-11-01T19:56:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vXLTC",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-01T20:10:14Z",
          "updatedAt": "2021-11-01T20:10:14Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I thought about doing that here, but it seemed to violate the thesis.  You want it in this PR?",
              "createdAt": "2021-11-01T20:10:14Z",
              "updatedAt": "2021-11-01T20:10:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vX1nN",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T00:16:10Z",
          "updatedAt": "2021-11-02T00:16:10Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "What do you mean by \"violate the thesis\"? This is a stream error and not a connection error right?",
              "createdAt": "2021-11-02T00:16:10Z",
              "updatedAt": "2021-11-02T00:16:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vX2OZ",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T00:23:29Z",
          "updatedAt": "2021-11-02T00:23:30Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Sorry, I meant \"the thesis of this PR\", which is about how to handle malformed capsules, not creating a new application error code space for capsule protocol.",
              "createdAt": "2021-11-02T00:23:29Z",
              "updatedAt": "2021-11-02T00:23:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vX2Za",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T00:25:35Z",
          "updatedAt": "2021-11-02T00:25:35Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I didn't mean creating a new application error code space, just add a new value to the h3 errors registry",
              "createdAt": "2021-11-02T00:25:35Z",
              "updatedAt": "2021-11-02T00:25:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vX2hw",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T00:27:01Z",
          "updatedAt": "2021-11-02T00:27:01Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I don't think Capsule Protocol errors belong in the H3 space, since Capsule Protocol can be conveyed over other versions of HTTP, right?",
              "createdAt": "2021-11-02T00:27:01Z",
              "updatedAt": "2021-11-02T00:27:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vX26H",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T00:31:27Z",
          "updatedAt": "2021-11-02T00:31:27Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Capsules travel end-to-end, but HTTP aborts are hop-by-hop. Since we don't have a way to abort end-to-end, we're stuck with using an error from the corresponding HTTP version in use. But you're right, you'd need to allocate one for h2 as well, and mention that the stream abort mechanism in h1 is TCP RST.",
              "createdAt": "2021-11-02T00:31:27Z",
              "updatedAt": "2021-11-02T00:31:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vX3JH",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T00:34:04Z",
          "updatedAt": "2021-11-02T00:34:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "> and mention that the stream abort mechanism in h1 is TCP RST.\r\n\r\nIs this text sufficient?\r\n\r\n>  When running over HTTP/1.1, the receiver terminates the underlying connection with an error.\r\n\r\nI tried to use the language from core.",
              "createdAt": "2021-11-02T00:34:04Z",
              "updatedAt": "2021-11-02T00:34:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vX3dO",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T00:37:33Z",
          "updatedAt": "2021-11-02T00:37:34Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "SGTM. I just rather we either not specify the h3/h2 errors, or define them with a specific value as opposed to TBD.",
              "createdAt": "2021-11-02T00:37:33Z",
              "updatedAt": "2021-11-02T00:37:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vbMlH",
          "commit": {
            "abbreviatedOid": "5841067"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T16:34:25Z",
          "updatedAt": "2021-11-02T16:34:25Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "It isn't a problem to use H2/H3 error codes to communicate application (higher-layer) problems. I think it is useful to include the reason (bad capsule) but I could live with `H3_GENERAL_PROTOCOL_ERROR` or the H2 equivalent. \r\n\r\nIf we consider a setup where there is an H3 -> H1.1 intermediary, the server behind the intermediary might detect a bad capsule and do a TCP RST. The intermediary can't know the reason for that and would probably end up having to use H3_GENERAL_PROTOCOL_ERROR. So the client might have to handle such a scenario anyway. ",
              "createdAt": "2021-11-02T16:34:25Z",
              "updatedAt": "2021-11-02T16:34:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vcbxJ",
          "commit": {
            "abbreviatedOid": "a5c740d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks! Approved pending some minor tweaks",
          "createdAt": "2021-11-02T22:50:55Z",
          "updatedAt": "2021-11-02T22:52:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think we'll also want to use H3_DATAGRAM_ERROR to replace any use of H3_GENERAL_PROTOCOL_ERROR in this section",
              "createdAt": "2021-11-02T22:50:55Z",
              "updatedAt": "2021-11-02T22:52:00Z"
            },
            {
              "originalPosition": 22,
              "body": "nit: line wrap",
              "createdAt": "2021-11-02T22:51:31Z",
              "updatedAt": "2021-11-02T22:52:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 113,
      "id": "PR_kwDODOpKfc4uKnmw",
      "title": "Simplify by removing formats and registration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/113",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Remove datagram format registry -- new capsule types can be used instead\r\n- Delegate context ID registration to methods/protocols, which can define new capsule types\r\n- Remove the need for header negotiation to support contexts. Individual methods can define their own headers for negotiation.\r\n- Datagram contexts don't always need to be used, but there's an implicit \"context 0\" which has a format that must be defined by each method. The presence of a context ID in a datagram is encoded in the \"encoded stream ID\".",
      "createdAt": "2021-11-05T19:40:06Z",
      "updatedAt": "2021-11-05T19:53:55Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "92b3712c5b06b2d7f1670d9e24a4b41edf9e3f39",
      "headRepository": "tfpauly/draft-ietf-masque-h3-datagram",
      "headRefName": "patch-1",
      "headRefOid": "95c4aea69bedea42ccc8e52e540152bebee21e71",
      "closedAt": "2021-11-05T19:53:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 114,
      "id": "PR_kwDODOpKfc4uKpV5",
      "title": "Simplify by removing formats and registration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/114",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "- Remove datagram format registry -- new capsule types can be used instead\r\n- Delegate context ID registration to methods/protocols, which can define new capsule types\r\n- Remove the need for header negotiation to support contexts. Individual methods can define their own headers for negotiation.\r\n- Datagram contexts don't always need to be used, but there's an implicit \"context 0\" which has a format that must be defined by each method. The presence of a context ID in a datagram is encoded in the \"encoded stream ID\".\r\n\r\n[Rendered view of this PR](https://ietf-wg-masque.github.io/draft-ietf-masque-h3-datagram/tfp/simplify/draft-ietf-masque-h3-datagram.html).",
      "createdAt": "2021-11-05T19:53:46Z",
      "updatedAt": "2021-11-10T10:17:02Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "92b3712c5b06b2d7f1670d9e24a4b41edf9e3f39",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "tfp/simplify",
      "headRefOid": "2e0184ea8425c7b751091d9dac1f61cb38a9e2a9",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4vo_5K",
          "commit": {
            "abbreviatedOid": "5acf7e2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T19:55:41Z",
          "updatedAt": "2021-11-05T19:57:21Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "```suggestion\r\nthe least-significant bit of the Encoded Stream ID is set, as described above. If the\r\n```",
              "createdAt": "2021-11-05T19:55:41Z",
              "updatedAt": "2021-11-05T19:57:21Z"
            },
            {
              "originalPosition": 133,
              "body": "Should we say something like: `If the Context ID field is not present, this datagram is associated with the default context (which has its Context ID set to 0).`",
              "createdAt": "2021-11-05T19:55:54Z",
              "updatedAt": "2021-11-05T19:57:21Z"
            },
            {
              "originalPosition": 617,
              "body": "In this example, the client wants to send the datagram without the extension to make sure that its first packet gets through to the target. Same for the next example below",
              "createdAt": "2021-11-05T19:56:39Z",
              "updatedAt": "2021-11-05T19:57:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpBOk",
          "commit": {
            "abbreviatedOid": "5acf7e2"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T20:03:05Z",
          "updatedAt": "2021-11-05T20:03:05Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "```suggestion\r\nthat contains a context ID. If the Context ID field is not present, this datagram\r\nis associated with the default context (which has its Context ID set to 0).\r\n```",
              "createdAt": "2021-11-05T20:03:05Z",
              "updatedAt": "2021-11-05T20:03:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpAvj",
          "commit": {
            "abbreviatedOid": "5acf7e2"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T20:00:18Z",
          "updatedAt": "2021-11-05T20:03:56Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n  * {{datagram-capsule}} defines Datagram Capsule types, along with guidance\r\n    for specifying new capsule types.\r\n```",
              "createdAt": "2021-11-05T20:00:18Z",
              "updatedAt": "2021-11-05T20:03:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpCuM",
          "commit": {
            "abbreviatedOid": "52f9a1a"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T20:11:32Z",
          "updatedAt": "2021-11-05T20:11:32Z",
          "comments": [
            {
              "originalPosition": 617,
              "body": "@DavidSchinazi I've updated the examples\u2014now it just has a \"supported extension\" and \"unsupported extension\" case.",
              "createdAt": "2021-11-05T20:11:32Z",
              "updatedAt": "2021-11-05T20:11:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpE9A",
          "commit": {
            "abbreviatedOid": "9a8dd37"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T20:24:58Z",
          "updatedAt": "2021-11-05T20:24:59Z",
          "comments": [
            {
              "originalPosition": 359,
              "body": "maybe qualify \"methods or protocols\" here?",
              "createdAt": "2021-11-05T20:24:59Z",
              "updatedAt": "2021-11-05T20:24:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpFz1",
          "commit": {
            "abbreviatedOid": "9a8dd37"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T20:29:45Z",
          "updatedAt": "2021-11-05T20:29:46Z",
          "comments": [
            {
              "originalPosition": 619,
              "body": "nit: lowercase\r\n\r\n```suggestion\r\n  sec-udp-timestamps = ?1\r\n```",
              "createdAt": "2021-11-05T20:29:46Z",
              "updatedAt": "2021-11-05T20:29:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpG0z",
          "commit": {
            "abbreviatedOid": "9a8dd37"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T20:35:49Z",
          "updatedAt": "2021-11-05T20:35:49Z",
          "comments": [
            {
              "originalPosition": 617,
              "body": "but if this is the support case then wouldn't the server reply with `Encoded Stream ID = 23` and `Payload = Encapsulated UDP Payload With Timestamp`?",
              "createdAt": "2021-11-05T20:35:49Z",
              "updatedAt": "2021-11-05T20:35:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpGS5",
          "commit": {
            "abbreviatedOid": "9a8dd37"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T20:32:40Z",
          "updatedAt": "2021-11-05T20:36:08Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Since we're changing the wire format, we need to bump the value of the SETTING",
              "createdAt": "2021-11-05T20:32:40Z",
              "updatedAt": "2021-11-05T20:36:08Z"
            },
            {
              "originalPosition": 466,
              "body": "Please don't change the value, that breaks backwards compatibility",
              "createdAt": "2021-11-05T20:33:17Z",
              "updatedAt": "2021-11-05T20:36:08Z"
            },
            {
              "originalPosition": 588,
              "body": "```suggestion\r\nREGISTER_UDP_WITH_TIMESTAMP_CONTEXT capsule include a timestamp followed by the\r\n```",
              "createdAt": "2021-11-05T20:34:21Z",
              "updatedAt": "2021-11-05T20:36:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpI8J",
          "commit": {
            "abbreviatedOid": "9a8dd37"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T20:48:44Z",
          "updatedAt": "2021-11-05T20:48:44Z",
          "comments": [
            {
              "originalPosition": 617,
              "body": "It can! It was just getting long. I'll fix.",
              "createdAt": "2021-11-05T20:48:44Z",
              "updatedAt": "2021-11-05T20:48:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpLUA",
          "commit": {
            "abbreviatedOid": "2e0184e"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T21:03:55Z",
          "updatedAt": "2021-11-05T21:03:56Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Done!",
              "createdAt": "2021-11-05T21:03:56Z",
              "updatedAt": "2021-11-05T21:03:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpLVE",
          "commit": {
            "abbreviatedOid": "2e0184e"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T21:04:02Z",
          "updatedAt": "2021-11-05T21:04:02Z",
          "comments": [
            {
              "originalPosition": 466,
              "body": "Whoops, fixed",
              "createdAt": "2021-11-05T21:04:02Z",
              "updatedAt": "2021-11-05T21:04:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpLWM",
          "commit": {
            "abbreviatedOid": "2e0184e"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T21:04:09Z",
          "updatedAt": "2021-11-05T21:04:09Z",
          "comments": [
            {
              "originalPosition": 619,
              "body": "Fixed",
              "createdAt": "2021-11-05T21:04:09Z",
              "updatedAt": "2021-11-05T21:04:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpLXq",
          "commit": {
            "abbreviatedOid": "2e0184e"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T21:04:20Z",
          "updatedAt": "2021-11-05T21:04:21Z",
          "comments": [
            {
              "originalPosition": 359,
              "body": "Qualified with a long form explanation",
              "createdAt": "2021-11-05T21:04:21Z",
              "updatedAt": "2021-11-05T21:04:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpLae",
          "commit": {
            "abbreviatedOid": "2e0184e"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-05T21:04:37Z",
          "updatedAt": "2021-11-05T21:04:37Z",
          "comments": [
            {
              "originalPosition": 617,
              "body": "Fixed",
              "createdAt": "2021-11-05T21:04:37Z",
              "updatedAt": "2021-11-05T21:04:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4v024z",
          "commit": {
            "abbreviatedOid": "2e0184e"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-10T10:14:06Z",
          "updatedAt": "2021-11-10T10:14:06Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Check operator precedence rules.  Also, I simplified this for you.\r\n\r\n```suggestion\r\nvalue of Encoded Stream ID is 2<sup>61</sup>. Receipt of a frame that\r\n```",
              "createdAt": "2021-11-10T10:14:06Z",
              "updatedAt": "2021-11-10T10:14:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4v03HN",
          "commit": {
            "abbreviatedOid": "2e0184e"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Probably OBE, but I don't understand the change from /4 to /2+1.",
          "createdAt": "2021-11-10T10:14:59Z",
          "updatedAt": "2021-11-10T10:17:02Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "so what does a value of 0 mean?  why divisible by four, but only divide by two?  how is this related to the other simplifications?",
              "createdAt": "2021-11-10T10:14:59Z",
              "updatedAt": "2021-11-10T10:17:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 115,
      "id": "PR_kwDODOpKfc4uLBfZ",
      "title": "Remove Datagram Format Types",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/115",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is based on #114 by @tfpauly. It removes datagram format types but still keeps contexts optional for both intermediaries and endpoints.\r\n\r\n[Rendered view of this PR](https://ietf-wg-masque.github.io/draft-ietf-masque-h3-datagram/remove_format_types/draft-ietf-masque-h3-datagram.html).",
      "createdAt": "2021-11-05T23:33:22Z",
      "updatedAt": "2021-11-06T16:50:49Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "92b3712c5b06b2d7f1670d9e24a4b41edf9e3f39",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "remove_format_types",
      "headRefOid": "88a58d334a49dfca50c92c727c51a981ac0c177d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4vpchS",
          "commit": {
            "abbreviatedOid": "bfed10a"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-06T00:15:22Z",
          "updatedAt": "2021-11-06T00:16:53Z",
          "comments": [
            {
              "originalPosition": 311,
              "body": "```suggestion\r\nID with the peer endpoint. Registering a context ID is the action by which an\r\n```",
              "createdAt": "2021-11-06T00:15:23Z",
              "updatedAt": "2021-11-06T00:16:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpcp2",
          "commit": {
            "abbreviatedOid": "bfed10a"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-06T00:18:47Z",
          "updatedAt": "2021-11-06T00:19:36Z",
          "comments": [
            {
              "originalPosition": 553,
              "body": "```suggestion\r\n  sec-use-datagram-contexts = ?1\r\n```",
              "createdAt": "2021-11-06T00:18:47Z",
              "updatedAt": "2021-11-06T00:19:36Z"
            },
            {
              "originalPosition": 527,
              "body": "```suggestion\r\n  sec-use-datagram-contexts = ?1\r\n```",
              "createdAt": "2021-11-06T00:19:06Z",
              "updatedAt": "2021-11-06T00:19:36Z"
            },
            {
              "originalPosition": 527,
              "body": "And other locations",
              "createdAt": "2021-11-06T00:19:33Z",
              "updatedAt": "2021-11-06T00:19:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vpsjf",
          "commit": {
            "abbreviatedOid": "bfed10a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-06T16:50:41Z",
          "updatedAt": "2021-11-06T16:50:49Z",
          "comments": [
            {
              "originalPosition": 553,
              "body": "This isn't specific to this PR, I'll take care of it in a followup",
              "createdAt": "2021-11-06T16:50:41Z",
              "updatedAt": "2021-11-06T16:50:49Z"
            },
            {
              "originalPosition": 527,
              "body": "This isn't specific to this PR, I'll take care of it in a followup",
              "createdAt": "2021-11-06T16:50:46Z",
              "updatedAt": "2021-11-06T16:50:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 119,
      "id": "PR_kwDODOpKfc4uS9y7",
      "title": "Fixed the lack of parenthis resulting in that a non integer max value.",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/119",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-09T16:29:41Z",
      "updatedAt": "2021-11-09T17:13:55Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "92b3712c5b06b2d7f1670d9e24a4b41edf9e3f39",
      "headRepository": "gloinul/draft-ietf-masque-h3-datagram",
      "headRefName": "mw-editorial",
      "headRefOid": "33a00f92edef7e4bea349ed05bb47a7de3f802f2",
      "closedAt": "2021-11-09T17:05:22Z",
      "mergedAt": "2021-11-09T17:05:21Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "5fb619046ab5a304018c8160c72db06e0bfae815"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Why would parentheses be required? Exponent has higher precedence than subtraction.",
          "createdAt": "2021-11-09T16:43:50Z",
          "updatedAt": "2021-11-09T16:43:50Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this proposal resolves the misinterpretation of 2^62 - (1/4)",
          "createdAt": "2021-11-09T16:57:22Z",
          "updatedAt": "2021-11-09T16:57:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4vxv-Q",
          "commit": {
            "abbreviatedOid": "33a00f9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Oh my bad, I had misread.",
          "createdAt": "2021-11-09T17:02:50Z",
          "updatedAt": "2021-11-09T17:02:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 122,
      "id": "PR_kwDODOpKfc4uTdZE",
      "title": "Disallow capsule pipelining",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/122",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #120 ",
      "createdAt": "2021-11-09T19:02:54Z",
      "updatedAt": "2021-12-03T20:01:17Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "main",
      "baseRefOid": "5fb619046ab5a304018c8160c72db06e0bfae815",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "pipeline",
      "headRefOid": "da1d889a6e5290c3122b5116c36bbe6baca4c75f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4vyTbQ",
          "commit": {
            "abbreviatedOid": "52732ad"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-09T19:05:18Z",
          "updatedAt": "2021-11-09T19:05:18Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "well it's not just pipelining, there's no means to send more than 1 request because the connection ceases to be HTTP after the request or response",
              "createdAt": "2021-11-09T19:05:18Z",
              "updatedAt": "2021-11-09T19:05:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4vyWda",
          "commit": {
            "abbreviatedOid": "52732ad"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-09T19:18:56Z",
          "updatedAt": "2021-11-09T19:18:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I was under the impression that \"send more than 1 request\" and \"pipelining\" were the exact same thing. Am I confused?",
              "createdAt": "2021-11-09T19:18:56Z",
              "updatedAt": "2021-11-09T19:18:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4v0qQh",
          "commit": {
            "abbreviatedOid": "52732ad"
          },
          "author": "gloinul",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-10T09:27:10Z",
          "updatedAt": "2021-11-10T09:27:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think the distinction between pipeling and non pipelining for a persistent connection is that you can send the additional HTTP request(s) after each other with pipelining without receiving any or the full response of the previous request. https://www.ietf.org/archive/id/draft-ietf-httpbis-messaging-19.html#name-pipelining\r\n\r\nSo, the restriction is really that it is not possible to subsequent HTTP requests after one that enables HTTP Datagram.",
              "createdAt": "2021-11-10T09:27:10Z",
              "updatedAt": "2021-11-10T09:27:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4v2B9p",
          "commit": {
            "abbreviatedOid": "da1d889"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-10T14:50:14Z",
          "updatedAt": "2021-11-10T14:50:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks, I've rewritten the text to replace pipelining with multiple requests",
              "createdAt": "2021-11-10T14:50:14Z",
              "updatedAt": "2021-11-10T14:50:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4xBgzp",
          "commit": {
            "abbreviatedOid": "da1d889"
          },
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-03T10:20:42Z",
          "updatedAt": "2021-12-03T10:20:43Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I feel like there should be some language in HTTP core that bans pipelining with `Connection: close` and `Connection: upgrade` that we would hopefully be covered by.",
              "createdAt": "2021-12-03T10:20:43Z",
              "updatedAt": "2021-12-03T10:20:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4xDox0",
          "commit": {
            "abbreviatedOid": "da1d889"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-03T20:01:16Z",
          "updatedAt": "2021-12-03T20:01:17Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@vasilvv I wasn't able to find that text, could you point me at it please?",
              "createdAt": "2021-12-03T20:01:16Z",
              "updatedAt": "2021-12-03T20:01:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 124,
      "id": "PR_kwDODOpKfc4ur4DA",
      "title": "First PR for 2021 Design Team",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR attempts to meet the majority of requirements from the design team's discussion on 2021-11-15, while removing all other features.\r\n\r\nNote that this PR is against the design team consensus branch, not main.\r\n\r\n[Rendered view of this PR](https://ietf-wg-masque.github.io/draft-ietf-masque-h3-datagram/design_team_output/draft-ietf-masque-h3-datagram.html).\r\n[Rendered diff with the design team consensus branch](https://www.ietf.org/rfcdiff?url1=https://ietf-wg-masque.github.io/draft-ietf-masque-h3-datagram/draft-ietf-masque-h3-datagram.txt&url2=https://ietf-wg-masque.github.io/draft-ietf-masque-h3-datagram/design_team_output/draft-ietf-masque-h3-datagram.txt).",
      "createdAt": "2021-11-18T00:30:10Z",
      "updatedAt": "2021-12-02T23:38:09Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "2021_design_team_consensus",
      "baseRefOid": "5fb619046ab5a304018c8160c72db06e0bfae815",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "design_team_output",
      "headRefOid": "98e15d9fa9489bdcd04bc78ab2ac45a8c5726bbe",
      "closedAt": "2021-12-02T23:38:05Z",
      "mergedAt": "2021-12-02T23:38:05Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "4dc29216f9d245822a6e4c5947209cbf14c71a39"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "High level comments: \r\n\r\nDo we need to be as generic about transparent and opaque now?  Perhaps we can strictly state how an intermediary can convert between native DATAGRAMs and Datagram Capsules in both directions, and must forward any other capsules unmodified unless otherwise specified in a capsule's definition.\r\n\r\nIf we are baking the Datagram Capsule into The Capsule Protocol (TCP - sorry, couldn't resist) with a code point in this document, then is it safe to say that the intended usage is for conveying datagrams and optional request related information over a request stream?  Eg: can another document specify the use \"Capsule Protocol\" but forbid the transmission of Datagram capsules, or does it become a different protocol at that point?   Note that WebTransport over H3 may do exactly this, since that protocol requires QUIC DATAGRAMs.  Can an application using WebTransport specify the use of Capsule Protocol for a non-request stream?",
          "createdAt": "2021-11-18T01:36:53Z",
          "updatedAt": "2021-11-18T01:37:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "> Eg: can another document specify the use \"Capsule Protocol\" but forbid the transmission of Datagram capsules, or does it become a different protocol at that point? Note that WebTransport over H3 may do exactly this, since that protocol requires QUIC DATAGRAMs. \r\n\r\nIMO the use (or prohibition) of capsule types would be a job of a spec on top of this. The capsule protocol is still in effect even if you choose to allow only some types of capsules on it. The PR states \"Note that use of the Capsule Protocol is not required to use HTTP Datagrams.\" so your WT use case seems to be supported.\r\n\r\n> Can an application using WebTransport specify the use of Capsule Protocol for a non-request stream?\r\n\r\nInteresting, that might be a case where we can state something like \"a future extension to the capsule protocol could describe how it can be applied to other stream types beyond client-initiated bidirectional streams\"",
          "createdAt": "2021-11-18T01:48:15Z",
          "updatedAt": "2021-11-18T01:48:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Do we need to be as generic about transparent and opaque now? Perhaps we can strictly state how an intermediary can convert between native DATAGRAMs and Datagram Capsules in both directions, and must forward any other capsules unmodified unless otherwise specified in a capsule's definition.\r\n\r\nI agree, I've removed the concept of opaque vs transparent.\r\n\r\n> If we are baking the Datagram Capsule into The Capsule Protocol (TCP - sorry, couldn't resist) with a code point in this document, then is it safe to say that the intended usage is for conveying datagrams and optional request related information over a request stream? Eg: can another document specify the use \"Capsule Protocol\" but forbid the transmission of Datagram capsules, or does it become a different protocol at that point? Note that WebTransport over H3 may do exactly this, since that protocol requires QUIC DATAGRAMs.\r\n\r\nI don't think that's right: WebTransport currently requires the QUIC DATAGRAM frame to be supported but it doesn't require datagrams to be sent using it. I think that's a fine place to be. As Lucas points out, WebTransport could decide to ban sending using DATAGRAM capsules while still using the capsule protocol.\r\n\r\n> Can an application using WebTransport specify the use of Capsule Protocol for a non-request stream?\r\n\r\nThe capsule protocol is currently 1:1 tied to a request stream, so as specified I'd say it can't be used on WebTransport streams other than the WebTransport CONNECT stream. I'm not sure there's a use case for that though.",
          "createdAt": "2021-11-18T01:52:41Z",
          "updatedAt": "2021-11-18T01:52:41Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> The capsule protocol is currently 1:1 tied to a request stream\r\n\r\nI think we can make that even more explicit in the Section 4 intro.\r\n\r\n> I'm not sure there's a use case for that though\r\n\r\nThere's a use case for framing on any unframed byte-stream, which WebTransport streams are.  Capsule Protocol minus Datagram Capsule could serve this purpose.  I'm ok saying that's out of scope though.",
          "createdAt": "2021-11-18T02:01:55Z",
          "updatedAt": "2021-11-18T02:01:55Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> > The capsule protocol is currently 1:1 tied to a request stream\r\n> \r\n> I think we can make that even more explicit in the Section 4 intro.\r\n\r\nAgreed, added some text.\r\n\r\n> > I'm not sure there's a use case for that though\r\n> \r\n> There's a use case for framing on any unframed byte-stream, which WebTransport streams are. Capsule Protocol minus Datagram Capsule could serve this purpose. I'm ok saying that's out of scope though.\r\n\r\nI'd say that's out of scope. Applications can decide to use \"TLVs where T and L are varints\" without saying it's the capsule protocol.",
          "createdAt": "2021-11-18T02:06:09Z",
          "updatedAt": "2021-11-18T02:06:09Z"
        },
        {
          "author": "achernya",
          "authorAssociation": "NONE",
          "body": "Can we remove the \"Creating a Demultiplexing Extension\" section? I find it really confusing and hard to follow and it's unclear to me what its purpose is -- is \"demultiplexing\" the h3->h2->h3 problem, or the \"identify different kinds of datagrams (like context ID did before)\" problem?",
          "createdAt": "2021-11-19T20:07:24Z",
          "updatedAt": "2021-11-19T20:07:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4wPaVU",
          "commit": {
            "abbreviatedOid": "98c0402"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks @DavidSchinazi, I believe this reflects the direction from the meeting. Just a few questions/nits",
          "createdAt": "2021-11-18T01:01:32Z",
          "updatedAt": "2021-11-18T01:11:51Z",
          "comments": [
            {
              "originalPosition": 461,
              "body": "what about RELIABLE_DATAGRAM -> DATAGRAM capsule conversion?\r\n\r\nMaybe simpler to just state that they are passed through and MUST NOT be converted to anything else.",
              "createdAt": "2021-11-18T01:01:32Z",
              "updatedAt": "2021-11-18T01:11:51Z"
            },
            {
              "originalPosition": 576,
              "body": "appreciate this is just the first proposal but the format changes and codepoint usage here seems breaking, sp probably requires a bump to the H3_DATAGRAM setting codepoint.",
              "createdAt": "2021-11-18T01:07:05Z",
              "updatedAt": "2021-11-18T01:11:51Z"
            },
            {
              "originalPosition": 688,
              "body": "I note the response doesn't have the equivalent header. I assume that's intended but I'm unclear why based on the header's definition.",
              "createdAt": "2021-11-18T01:10:17Z",
              "updatedAt": "2021-11-18T01:11:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wPcXN",
          "commit": {
            "abbreviatedOid": "d87eaaf"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T01:19:49Z",
          "updatedAt": "2021-11-18T01:21:53Z",
          "comments": [
            {
              "originalPosition": 688,
              "body": "No that was an oversight, fixed.",
              "createdAt": "2021-11-18T01:19:49Z",
              "updatedAt": "2021-11-18T01:21:53Z"
            },
            {
              "originalPosition": 576,
              "body": "Interestingly, these changes don't break backwards compatibility because the format is the same in the absence of the Sec-Use-Datagram-Contexts header. So we don't need to change the setting or codepoints - which is nice because it doesn't break existing WebTransport implementations.",
              "createdAt": "2021-11-18T01:21:05Z",
              "updatedAt": "2021-11-18T01:21:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wPdrv",
          "commit": {
            "abbreviatedOid": "d87eaaf"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T01:31:11Z",
          "updatedAt": "2021-11-18T01:31:11Z",
          "comments": [
            {
              "originalPosition": 576,
              "body": "Right but previously the intermediary could manipulate DATAGRAM capsules with type 0xff37a5, and now the text says they can't do that because the semantics of the RELIABLE_DATAGRAM are different. Is the assumption that no one implemented an intermediary that procesed DATAGRAM before this change?",
              "createdAt": "2021-11-18T01:31:11Z",
              "updatedAt": "2021-11-18T01:31:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wPeGJ",
          "commit": {
            "abbreviatedOid": "d87eaaf"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T01:34:54Z",
          "updatedAt": "2021-11-18T01:34:54Z",
          "comments": [
            {
              "originalPosition": 576,
              "body": "actually, that's a problem with capsule protocol versioning not the H3 SETTING but I think my point stands, unless we declare that the use of the new header means that these are different versions of capsules.",
              "createdAt": "2021-11-18T01:34:54Z",
              "updatedAt": "2021-11-18T01:36:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wPeOy",
          "commit": {
            "abbreviatedOid": "d87eaaf"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T01:36:15Z",
          "updatedAt": "2021-11-18T01:36:16Z",
          "comments": [
            {
              "originalPosition": 576,
              "body": "Ah right, yes the (unstated) assumption was that no one has yet implemented an intermediary so we don't need to maintain backwards compatibility yet.",
              "createdAt": "2021-11-18T01:36:16Z",
              "updatedAt": "2021-11-18T01:36:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wPt0T",
          "commit": {
            "abbreviatedOid": "5f839c6"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Mostly nits here, this is a pretty good set of changes on the whole and the simplifications are definitely welcome.  The reliable datagram thing is the only thing that I think is concretely problematic.\r\n\r\n(I also made comments on surrounding text because I reviewed the full document; feel free to ignore those for this and ask me to open new issues.)",
          "createdAt": "2021-11-18T03:04:13Z",
          "updatedAt": "2021-11-18T03:41:50Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "```suggestion\r\npayload starts with an encoded stream identifier that associates the datagram\r\nwith a request stream.\r\n```\r\n\r\nYou already say \"encoded stream identifier\" and the goal is to associate with request streams.  In WebTransport, we might use those bidirectional streams without making them requests, which will require (or at least allow) some additional checking to see that the identified stream contains a request, but that's something WebTransport can handle.",
              "createdAt": "2021-11-18T03:04:13Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 151,
              "body": "Noticed in reviewing the whole...  The line above says `(2<sup>62</sup>-1) / 4` where `2<sup>60</sup>-1` would do.",
              "createdAt": "2021-11-18T03:05:17Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 204,
              "body": "There is text missing from the introduction here that establishes the conditions on the use of capsule protocol.  That is, it only applies to those protocols that use extended CONNECT and also opt in to the use of the capsule protocol.\r\n\r\nThe nice thing with the draft up until this point is that it doesn't constrain the use of datagrams to those protocols that use extended CONNECT.  This part does.\r\n\r\n(I know that this is perhaps fanciful, but I can imagine uses for regular HTTP requests that are enhanced by the use of DATAGRAM frames.)",
              "createdAt": "2021-11-18T03:11:19Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 212,
              "body": "This bit belongs up front.",
              "createdAt": "2021-11-18T03:12:01Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 241,
              "body": "\ud83d\udc4d\r\n\r\nI might amend this to include the condition that the intermediary understand the semantics of the request enough to know that capsules are in use:\r\n\r\n```suggestion\r\nCapsules MUST be forwarded unmodified by intermediaries, with the exception of\r\nthe DATAGRAM capsule. An intermediary that understands the request semantics \r\nsufficient to know that capsules are in use MAY parse, add, or remove DATAGRAM\r\ncapsules; see {{datagram-capsule}}. Definitions of new Capsule Types MAY specify\r\ncustom intermediary processing.\r\n```\r\n\r\nWhat I don't want to see is intermediaries guessing that a particular unknown `:protocol` is using capsules when they do not.  Splicing in DATAGRAM frames/capsules in that context might go badly wrong.",
              "createdAt": "2021-11-18T03:12:24Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 218,
              "body": "I think that the text on the two intermediary processing modes can be removed.",
              "createdAt": "2021-11-18T03:16:34Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 244,
              "body": "This doesn't belong in intermediary processing.  Especially when it might be interpreted as applying to intermediaries.",
              "createdAt": "2021-11-18T03:17:15Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 215,
              "body": "> A server MUST NOT send any Transfer-Encoding or Content-Length header fields in a 2xx (Successful) response. If a client receives a Content-Length or Transfer-Encoding header fields in a successful response, it MUST treat that response as malformed.\r\n\r\nIf this is just about the response you need to say that:\r\n\r\n1. the capsule protocol is not in use for a response unless it includes a 2xx status code\r\n2. the capsule protocol MUST NOT be used with messages that contain Content-Length or Transfer-Encoding\r\n\r\nYou also say:\r\n\r\n> A request message does not have content.\r\n\r\nThere are cases where Content-Length can be zero, but that is limited, not universal.  It's only CONNECT that gets that special handling.  For a new method, the capsule protocol will need to be used for the request body, which means that the request will have content.\r\n\r\n> A successful response message does not have content.\r\n\r\nAgain, this is not going to be the case for anything other than CONNECT.\r\n\r\n> Responses are not cacheable.\r\n\r\nGenerally true, but not necessarily universally true.  I think that this is more of a recommendation rather than a requirement.  It doesn't make sense to cache a response that uses the capsule protocol, but who are we to say that?\r\n",
              "createdAt": "2021-11-18T03:23:40Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 460,
              "body": "\"MAY send DATAGRAM capsules that they did not receive\" is problematic.  I don't think that we want intermediaries injecting their own special wisdom into the flow, even if that might be possible, it's not what we want to specifically allow.\r\n\r\nWhat you are trying to say here is in the \"in other words\" clause: that an intermediary may translate QUIC DATAGRAM frames into HTTP DATAGRAM capsules and vice versa.",
              "createdAt": "2021-11-18T03:27:22Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 471,
              "body": "```suggestion\r\nNote that while DATAGRAM capsules that are sent on a stream are reliably delivered in order, intermediaries can\r\nreencode DATAGRAM capsules into QUIC DATAGRAM frames when forwarding messages, which could result in loss or reordering.\r\n```",
              "createdAt": "2021-11-18T03:28:36Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 493,
              "body": "I'm fairly sure that we didn't agree to this bit.\r\n\r\nOn the contrary, I think that several of us opposed it.  Can we cut it and take it up separately?",
              "createdAt": "2021-11-18T03:29:46Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 519,
              "body": "What if this appears on a response that doesn't have a 2xx status?  What about 1xx?",
              "createdAt": "2021-11-18T03:30:58Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 507,
              "body": "```suggestion\r\nCapsule Protocol MAY use the Sec-Capsule-Protocol header field to simplify\r\n```\r\n\r\n...and throughout.",
              "createdAt": "2021-11-18T03:31:11Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 524,
              "body": "This bit where you can't define the field as a Boolean directly is weird.  @mnot, why not?\r\n\r\nAlso, I think that you need to define what to do with multiple values and parameters.",
              "createdAt": "2021-11-18T03:37:49Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            },
            {
              "originalPosition": 953,
              "body": "It would be good to have an example that uses capsules but does not include this header field.",
              "createdAt": "2021-11-18T03:38:32Z",
              "updatedAt": "2021-11-18T03:41:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wPzDG",
          "commit": {
            "abbreviatedOid": "5f839c6"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T03:59:49Z",
          "updatedAt": "2021-11-18T03:59:49Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "I'm with Martin that I do not want to see this RELIABLE_DATAGRAM defined, especially not in this PR.\r\n\r\nEspecially given that capsules can't be modified by intermediaries, etc, I don't see the value in defining this here. If protocols want to define another capsule they use to transmit data over their stream of capsules, great\u2014go ahead and define it there!",
              "createdAt": "2021-11-18T03:59:49Z",
              "updatedAt": "2021-11-18T03:59:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wPzHq",
          "commit": {
            "abbreviatedOid": "5f839c6"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T04:00:36Z",
          "updatedAt": "2021-11-18T04:00:36Z",
          "comments": [
            {
              "originalPosition": 524,
              "body": "I think this is just the standard suggested text for structured fields \ud83e\udd37 ",
              "createdAt": "2021-11-18T04:00:36Z",
              "updatedAt": "2021-11-18T04:00:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wPzNN",
          "commit": {
            "abbreviatedOid": "5f839c6"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T04:01:35Z",
          "updatedAt": "2021-11-18T04:01:35Z",
          "comments": [
            {
              "originalPosition": 953,
              "body": "Agreed",
              "createdAt": "2021-11-18T04:01:35Z",
              "updatedAt": "2021-11-18T04:01:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wSUFc",
          "commit": {
            "abbreviatedOid": "5f839c6"
          },
          "author": "bemasc",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T15:46:42Z",
          "updatedAt": "2021-11-18T15:56:58Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "```suggestion\r\nspecify optional custom intermediary processing.\r\n```\r\n\r\nIf you have capsule types that cannot safely be passed verbatim by an intermediary, I don't think you're using The Capsule Protocol.",
              "createdAt": "2021-11-18T15:46:43Z",
              "updatedAt": "2021-11-18T15:56:58Z"
            },
            {
              "originalPosition": 504,
              "body": "Why does this have a Sec- prefix?  Why shouldn't Javascript be allowed to set this header on requests it generates?  It seems safe to me.",
              "createdAt": "2021-11-18T15:54:18Z",
              "updatedAt": "2021-11-18T15:56:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS1W-",
          "commit": {
            "abbreviatedOid": "29bca84"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:32:47Z",
          "updatedAt": "2021-11-18T17:32:47Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Agreed, made the change.",
              "createdAt": "2021-11-18T17:32:47Z",
              "updatedAt": "2021-11-18T17:32:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS1ml",
          "commit": {
            "abbreviatedOid": "29bca84"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:33:42Z",
          "updatedAt": "2021-11-18T17:33:42Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Agreed. I refactored the capsule section to contain more information up front.",
              "createdAt": "2021-11-18T17:33:42Z",
              "updatedAt": "2021-11-18T17:33:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS1nx",
          "commit": {
            "abbreviatedOid": "29bca84"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:33:47Z",
          "updatedAt": "2021-11-18T17:33:47Z",
          "comments": [
            {
              "originalPosition": 212,
              "body": "Agreed. I refactored the capsule section to contain more information up front.",
              "createdAt": "2021-11-18T17:33:47Z",
              "updatedAt": "2021-11-18T17:33:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS1wf",
          "commit": {
            "abbreviatedOid": "29bca84"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:34:16Z",
          "updatedAt": "2021-11-18T17:34:16Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "Agreed, removed the vague intermediary processing text.",
              "createdAt": "2021-11-18T17:34:16Z",
              "updatedAt": "2021-11-18T17:34:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS13J",
          "commit": {
            "abbreviatedOid": "29bca84"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:34:39Z",
          "updatedAt": "2021-11-18T17:34:39Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "Agreed, moved the requirement on endpoints to the main capsule section",
              "createdAt": "2021-11-18T17:34:39Z",
              "updatedAt": "2021-11-18T17:34:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS17h",
          "commit": {
            "abbreviatedOid": "29bca84"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:34:53Z",
          "updatedAt": "2021-11-18T17:34:54Z",
          "comments": [
            {
              "originalPosition": 215,
              "body": "Agreed, made the changes",
              "createdAt": "2021-11-18T17:34:54Z",
              "updatedAt": "2021-11-18T17:34:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS2Dp",
          "commit": {
            "abbreviatedOid": "29bca84"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:35:24Z",
          "updatedAt": "2021-11-18T17:35:24Z",
          "comments": [
            {
              "originalPosition": 519,
              "body": "Clarified that Sec-Capsule-Protocol is only allowed on 2xx",
              "createdAt": "2021-11-18T17:35:24Z",
              "updatedAt": "2021-11-18T17:35:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS2aW",
          "commit": {
            "abbreviatedOid": "fae5bbb"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:36:44Z",
          "updatedAt": "2021-11-18T17:36:44Z",
          "comments": [
            {
              "originalPosition": 524,
              "body": "Yes, this is standard boilerplate.\r\n\r\nI added text about multiple values and parameters.",
              "createdAt": "2021-11-18T17:36:44Z",
              "updatedAt": "2021-11-18T17:36:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS2fX",
          "commit": {
            "abbreviatedOid": "fae5bbb"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:37:01Z",
          "updatedAt": "2021-11-18T17:37:01Z",
          "comments": [
            {
              "originalPosition": 953,
              "body": "I removed the header from the WebTransport example.",
              "createdAt": "2021-11-18T17:37:01Z",
              "updatedAt": "2021-11-18T17:37:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS2i_",
          "commit": {
            "abbreviatedOid": "fae5bbb"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:37:13Z",
          "updatedAt": "2021-11-18T17:37:14Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "Agreed, added optional.",
              "createdAt": "2021-11-18T17:37:13Z",
              "updatedAt": "2021-11-18T17:37:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS26d",
          "commit": {
            "abbreviatedOid": "fae5bbb"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:38:37Z",
          "updatedAt": "2021-11-18T17:38:37Z",
          "comments": [
            {
              "originalPosition": 504,
              "body": "That sounds dangerous, if we allow JavaScript to send this we're adding a burden on every new capsule type to consider the implications of that. I'd rather disallow it to limit risk and avoid potential issues. If someone has a use-case that requires this we could reconsider that choice.",
              "createdAt": "2021-11-18T17:38:37Z",
              "updatedAt": "2021-11-18T17:38:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS3AS",
          "commit": {
            "abbreviatedOid": "fae5bbb"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:38:56Z",
          "updatedAt": "2021-11-18T17:38:56Z",
          "comments": [
            {
              "originalPosition": 460,
              "body": "Agreed, rephrased the text",
              "createdAt": "2021-11-18T17:38:56Z",
              "updatedAt": "2021-11-18T17:38:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wS5A6",
          "commit": {
            "abbreviatedOid": "fae5bbb"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:46:11Z",
          "updatedAt": "2021-11-18T17:46:12Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "I'd like us to discuss this in the context of this design team. The reason for that is that it has significant implications on future extensibility. I feel strongly that this spec needs enough of a toehold so that I can write a separate \"datagram contexts\" extension that has the \"zero-latency extensibility\" feature. The minimal toehold that I wrote initially was adding an UNEXTENDED_DATAGRAM capsule that has the same semantics as the DATAGRAM capsule but that intermediaries can't touch. Looking back I realized that this ended up being very similar to the RELIABLE_DATAGRAM that Ben asked for so I renamed it. I wrote up the way the extensibility toehold works in the \"Creating a Demultiplexing Extension\" appendix. I'm definitely open to any other toehold that allow future extensibility, let me know if you have ideas.",
              "createdAt": "2021-11-18T17:46:11Z",
              "updatedAt": "2021-11-18T17:47:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wTiUj",
          "commit": {
            "abbreviatedOid": "fae5bbb"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T20:35:26Z",
          "updatedAt": "2021-11-18T20:35:27Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "I see some generic utility of RELIABLE_DATAGRAM.  It's, well, reliable, and is not bound by MTU restrictions.  The only difference between RELIABLE_DATAGRAM and an unknown Capsule type is that an endpoint has to treat it the same as receiving a DATAGRAM Capsule, instead of dropping it.\r\n\r\nI'm missing how having it enables zero-latency extensibility.",
              "createdAt": "2021-11-18T20:35:26Z",
              "updatedAt": "2021-11-18T20:35:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wT1Hd",
          "commit": {
            "abbreviatedOid": "fae5bbb"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I agree that this is simpler, but I still am unpersuaded that we need to specify the behavior of intermediaries as this does.",
          "createdAt": "2021-11-18T22:06:28Z",
          "updatedAt": "2021-11-18T22:12:35Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "This paragraph still concerns me. I'm happy to acknowledge that intermediaries exist, but I dont think we should be specifying their behavior. What happens if we just delete it?",
              "createdAt": "2021-11-18T22:06:28Z",
              "updatedAt": "2021-11-18T22:12:35Z"
            },
            {
              "originalPosition": 493,
              "body": "I am also skeptical of this. \r\n\r\nI would ask if this question really needs to be resolved by this design team. Can't we discuss it in the WG?",
              "createdAt": "2021-11-18T22:10:17Z",
              "updatedAt": "2021-11-18T22:12:35Z"
            },
            {
              "originalPosition": 580,
              "body": "This is more material specifying intermediaries.",
              "createdAt": "2021-11-18T22:10:45Z",
              "updatedAt": "2021-11-18T22:12:35Z"
            },
            {
              "originalPosition": 587,
              "body": "What are the semantics of this boolean? I don't see them defined.",
              "createdAt": "2021-11-18T22:11:59Z",
              "updatedAt": "2021-11-18T22:12:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wT4SU",
          "commit": {
            "abbreviatedOid": "fae5bbb"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T22:24:07Z",
          "updatedAt": "2021-11-18T22:29:14Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "If we don't specify intermediary handling, intermediary implementors will implement what they feel like, such as dropping unknown capsules. If we do that we can't use capsules for end to end messages like we do in WebTransport and CONNECT-IP.",
              "createdAt": "2021-11-18T22:24:07Z",
              "updatedAt": "2021-11-18T22:29:14Z"
            },
            {
              "originalPosition": 493,
              "body": "For me the extensibility properties are a fundamental part of the design, so the output of the design team needs to discuss this.",
              "createdAt": "2021-11-18T22:25:53Z",
              "updatedAt": "2021-11-18T22:29:14Z"
            },
            {
              "originalPosition": 580,
              "body": "That is correct.",
              "createdAt": "2021-11-18T22:26:06Z",
              "updatedAt": "2021-11-18T22:29:14Z"
            },
            {
              "originalPosition": 587,
              "body": "Good point, I've added text to clarify the semantics.",
              "createdAt": "2021-11-18T22:29:02Z",
              "updatedAt": "2021-11-18T22:29:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wT56m",
          "commit": {
            "abbreviatedOid": "46e68e7"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T22:33:25Z",
          "updatedAt": "2021-11-18T22:33:26Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "> If we don't specify intermediary handling, intermediary implementors will implement what they feel like, such as dropping unknown capsules. \r\n\r\nAnd the solution is for service operators not to use such intermediaries.\r\n\r\n\r\n> If we do that we can't use capsules for end to end messages like we do in WebTransport and CONNECT-IP.\r\n\r\nNo, you can't do them in situations where you don't control the intermediaries.\r\n\r\nThis whole discussion of the position vis-a-vis intermediaries was a key point of disagreement on the call, so as long as that's unresolved, this PR isn't done.\r\n\r\n",
              "createdAt": "2021-11-18T22:33:26Z",
              "updatedAt": "2021-11-18T22:33:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wT-2i",
          "commit": {
            "abbreviatedOid": "46e68e7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T23:04:13Z",
          "updatedAt": "2021-11-18T23:04:14Z",
          "comments": [
            {
              "originalPosition": 504,
              "body": "I know that we just shove \"Sec-\" on everything nowadays, but I think we need to meet a higher bar than \"sounds dangerous\".  Do you have a concrete example?\r\n\r\nLet's say that I did a POST using fetch() with this new field attached.  I do that over h2 and a CDN upgrades to h3 toward the origin, splitting out apparent \"datagrams\" into frames on that leg.  The server might still accept the request, but discard the datagrams.  That means that the CDN and origin server see a different payload.  Maybe that's something that can be exploited.\r\n\r\nBut then, what is special about that being dependent on JavaScript?  I don't think that it works as an attack. Fetch will preflight the request and will not add the header unless it is specifically allowed by the server in a preflight, see [CORS-unsafe request-header names](https://fetch.spec.whatwg.org/#cors-unsafe-request-header-names).",
              "createdAt": "2021-11-18T23:04:13Z",
              "updatedAt": "2021-11-18T23:04:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wT_0l",
          "commit": {
            "abbreviatedOid": "46e68e7"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T23:10:53Z",
          "updatedAt": "2021-11-18T23:10:53Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "I'm not suggesting that this PR is done, resolving questions like this is why we're having this conversation :)\r\n\r\nI see two options here:\r\n1. the current text\r\n2. remove mentions of intermediaries and require service operators terminate every protocol at the intermediary\r\n\r\nI think (2) is more complex to deploy, and the cost of (1) is a few lines of spec that implementors of non-intermediaries can ignore, so I'm personally leaning towards (1).",
              "createdAt": "2021-11-18T23:10:53Z",
              "updatedAt": "2021-11-18T23:10:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wUAmr",
          "commit": {
            "abbreviatedOid": "46e68e7"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T23:16:29Z",
          "updatedAt": "2021-11-18T23:16:30Z",
          "comments": [
            {
              "originalPosition": 504,
              "body": "That's fair. You understand CORS better than I do. After thinking about this some more I have no strong opinion here so I'm happy to go with the consensus of the design team and/or WG on whether we should start with \"Sec-\" or not.",
              "createdAt": "2021-11-18T23:16:30Z",
              "updatedAt": "2021-11-18T23:16:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wTscn",
          "commit": {
            "abbreviatedOid": "fae5bbb"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T21:23:38Z",
          "updatedAt": "2021-11-19T14:29:42Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "I would suggest tightening this permission.  We already have language around converting between QUIC DATAGRAM frames and DATAGRAM capsules -- is there a need to allow datagram insertion in other scenarios?  (Dropping is fine, because they're unreliable anyway.)",
              "createdAt": "2021-11-18T21:23:38Z",
              "updatedAt": "2021-11-19T14:29:42Z"
            },
            {
              "originalPosition": 479,
              "body": "```suggestion\r\nDatagram on a stream using the Capsule Protocol. This is particularly useful when using a version\r\n```",
              "createdAt": "2021-11-18T21:24:49Z",
              "updatedAt": "2021-11-19T14:29:42Z"
            },
            {
              "originalPosition": 508,
              "body": "```suggestion\r\nDatagrams sent using the DATAGRAM capsule have the same semantics as\r\n```",
              "createdAt": "2021-11-18T21:25:18Z",
              "updatedAt": "2021-11-19T14:29:42Z"
            },
            {
              "originalPosition": 493,
              "body": "This seems to violate the expectations of calling something a \"Datagram.\"  If we keep this, I'd suggest a different name, such as MESSAGE.  Effectively, this is unordered but reliable.  (Note that while re-encoding as a QUIC DATAGRAM would be inappropriate, re-encoding as an HTTP/3 unidirectional stream would provide similar reliable-but-unordered semantics.)\r\n\r\nThat said, I agree with Martin that it doesn't belong in this PR.  Let's work on one piece at a time -- this isn't needed to solve the core problems, and could easily be brought forward as a separate proposal.",
              "createdAt": "2021-11-18T21:30:05Z",
              "updatedAt": "2021-11-19T14:29:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wXY37",
          "commit": {
            "abbreviatedOid": "46e68e7"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T16:42:03Z",
          "updatedAt": "2021-11-19T16:49:22Z",
          "comments": [
            {
              "originalPosition": 541,
              "body": "```suggestion\r\nloss; this can misrepresent the true path properties, defeating methods such as\r\n```",
              "createdAt": "2021-11-19T16:42:03Z",
              "updatedAt": "2021-11-19T16:49:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wXl4A",
          "commit": {
            "abbreviatedOid": "beea764"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T17:35:56Z",
          "updatedAt": "2021-11-19T17:35:57Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "Agreed, tightened the text.",
              "createdAt": "2021-11-19T17:35:57Z",
              "updatedAt": "2021-11-19T17:35:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wXmPU",
          "commit": {
            "abbreviatedOid": "8d5de8b"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T17:37:34Z",
          "updatedAt": "2021-11-19T17:37:35Z",
          "comments": [
            {
              "originalPosition": 504,
              "body": "I've removed the Sec- prefix.",
              "createdAt": "2021-11-19T17:37:35Z",
              "updatedAt": "2021-11-19T17:37:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wXpwU",
          "commit": {
            "abbreviatedOid": "8d5de8b"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T17:53:50Z",
          "updatedAt": "2021-11-19T17:53:50Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "> this is unordered but reliable\r\n\r\nHow is it unordered if it can't be converted to a QUIC DATAGRAM?\r\n\r\n> That said, I agree with Martin that it doesn't belong in this PR. Let's work on one piece at a time\r\n\r\n+1 \r\n\r\nThere's a lot here we have agreement on, so if RELIABLE_DATAGRAM is controversial let's break it out.  \r\n\r\nI'm still missing how it enables or is required for 0-RTT extensions (which are a nice-to-have).  The appendix was vague.  @DavidSchinazi can you write down what you are thinking.",
              "createdAt": "2021-11-19T17:53:50Z",
              "updatedAt": "2021-11-19T17:53:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wXwM9",
          "commit": {
            "abbreviatedOid": "8d5de8b"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T18:24:55Z",
          "updatedAt": "2021-11-19T18:24:55Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "The current draft (version -05) contains the datagram context extensibility system. I'm OK with us removing that from this draft (which is what this PR does), on the condition that I can still implement that as an extension to this draft. In particular, I need that extension to work without costing a round trip (what I've been calling \"zero-latency extensibility\"). Let me go into more detail as to why RELIABLE_DATAGRAM is important to that.\r\n\r\nThe datagram context extension works as follows: it is negotiated by adding a header to both request and response, and when both endpoints support it, it adds a context ID varint at the start of the HTTP Datagram Payload field.\r\n\r\nNow, in order to achieve zero-latency extensibility, the client needs to be able to send datagrams before receiving the server headers in such a way that the server can correctly parse them (if you add the context ID and the server doesn't support the extension, you don't want the server to parse the context ID as part of the payload).\r\n\r\nSo here's my idea for how to accomplish that. The extension says the following:\r\n- clients that support the extension are not allowed to send QUIC DATAGRAM frames nor DATAGRAM capsule before they've received the server headers\r\n- the extension defines a new RELIABLE_DATAGRAM_EXT capsule that can be sent before and after receiving server headers\r\n```\r\nExtended Reliable Datagram Capsule {\r\n  Type (i) = RELIABLE_DATAGRAM_EXT,\r\n  Length (i),\r\n  Context ID (i),\r\n  HTTP Datagram Payload (..),\r\n}\r\n```\r\n- the extension does not change the semantics of the RELIABLE_DATAGRAM capsule, that still does not contain a Context ID\r\n```\r\nReliable Datagram Capsule {\r\n  Type (i) = RELIABLE_DATAGRAM,\r\n  Length (i),\r\n  HTTP Datagram Payload (..),\r\n}\r\n```\r\n- when both endpoints support the extension (after receiving headers) the extension changes the semantics of both the QUIC DATAGRAM frame and DATAGRAM capsule to include a Context ID at the start:\r\n```\r\nDatagram Capsule {\r\n  Type (i) = DATAGRAM,\r\n  Length (i),\r\n  Context ID (i),\r\n  HTTP Datagram Payload (..),\r\n}\r\nHTTP/3 Datagram { // contents of QUIC DATAGRAM frame\r\n  Quarter Stream ID (i),\r\n  Context ID (i),\r\n  HTTP Datagram Payload (..),\r\n}\r\n```\r\n- if the client wishes to use zero-latency extensibility, it can send RELIABLE_DATAGRAM and RELIABLE_DATAGRAM_EXT before receiving the server headers. Both of these will be parsed correctly by servers, whether or not the server supports the extension.\r\n\r\nAll of this relies on the fact that there is one bit that differentiates the DATAGRAM capsule from the RELIABLE_DATAGRAM capsule (the bit is in the capsule type), so that the extension can give the two capsules different semantics in a way that is backwards compatible.\r\n\r\nWhat I like about this design is that the added complexity to the HTTP Datagram spec is as minimal as possible: it just requires two case statements instead of one in the switch statement that parses capsule types.\r\n\r\nI'm OK removing the RELIABLE_DATAGRAM capsule from this PR, as long as we have some other mechanism that I can use to write my extension.",
              "createdAt": "2021-11-19T18:24:55Z",
              "updatedAt": "2021-11-19T18:24:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wX4hK",
          "commit": {
            "abbreviatedOid": "8d5de8b"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T19:05:59Z",
          "updatedAt": "2021-11-19T19:05:59Z",
          "comments": [
            {
              "originalPosition": 519,
              "body": "```suggestion\r\nAn intermediary can reencode HTTP Datagrams as it forwards them. In other words, an\r\n```",
              "createdAt": "2021-11-19T19:05:59Z",
              "updatedAt": "2021-11-19T19:05:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYHgT",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "achernya",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:06:08Z",
          "updatedAt": "2021-11-19T20:06:08Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "I find this entire conversation a bit hard to follow, so forgive me if I've missed anything.\r\n\r\nThere's a claim that RELIABLE_DATAGRAM is controversial, and also a poor name. I haven't seen a good argument to remove it, merely the assertion that people do not want it. There are however a few use cases that have been described in its favor, so I personally would like to see it included (even if it has some other name), as per the discussion we've had at IETF and on list around the different MTU issues, as well as the H3->H2->H3 translation issues that it helps resolve.\r\n\r\nA different issue that I'd like to raise (although I can live with this) is that I'm not really a fan of the extension-that-changes-the-semantics-of-DATAGRAM scheme that is being proposed here. I understand that is a natural consequence of the Datagram Capsule -> QUIC DATAGRAM encoding, but I'd personally really like to see the type varint make it into the QUIC DATAGRAM so that we can always unambiguously parse the datagrams, regardless of how we received them (capsule or otherwise). I acknowledge that this may not be the way others want this, and can live with the current (proposed) text.\r\n\r\n",
              "createdAt": "2021-11-19T20:06:08Z",
              "updatedAt": "2021-11-19T20:06:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYJtQ",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:14:43Z",
          "updatedAt": "2021-11-19T20:14:43Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "> There's a claim that RELIABLE_DATAGRAM is controversial, and also a poor name. I haven't seen a good argument to remove it, merely the assertion that people do not want it. \r\n\r\nThis is the wrong standard. Things need consensus to be *included*, not removed.\r\n\r\nIn any case, a comment on this piece of the document is the wrong place to debate that, so the right thing to do is not have it in this PR and then discuss it separately.",
              "createdAt": "2021-11-19T20:14:43Z",
              "updatedAt": "2021-11-19T20:14:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYNCC",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "achernya",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:30:24Z",
          "updatedAt": "2021-11-19T20:30:24Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "I disagree with your position that it is reasonable to omit things just because someone provides an unsubstantiated objection. Kindly please provide a technical argument for its removal, or we will not be able to build consensus in either direction.",
              "createdAt": "2021-11-19T20:30:24Z",
              "updatedAt": "2021-11-19T20:30:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYNeg",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:33:02Z",
          "updatedAt": "2021-11-19T20:33:03Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "Maybe I don't understand what 0-RTT extensibility means.  Does it mean:\r\n\r\n1. A client that supports an extension can try to use the extension before receiving confirmation that the server supports it\r\n2. If the server supports the extension it will be processed correctly\r\n3. If the server does not support the extension, the stream will not be torn down, but the extended datagrams could be dropped\r\n---\r\nIf that's correct, can you build this without RELIABLE_DATAGRAM by:\r\n\r\n1. Extension defines new Capsule type DATAGRAM_EXT\r\n2. Client sends indication that it supports DATAGRAM_EXT in the CONNECT headers\r\n3. Client sends DATAGRAM_EXT Capsules\r\n3a.  Server supports extension, processes DATAGRAM_EXT Capsules\r\n4a. Server confirms extension support\r\n5a. Client receives acknowledgement that the extension is supported, switches to DATAGRAM and DATAGRAM Capsules\r\n3b. Server silently drops DATAGRAM_EXT Capsules\r\n4b. Server sends CONNECT response\r\n5b. Client sees the server does not support the extension, uses standard DATAGRAM and DATAGRAM Capsules\r\n\r\nI see that RELIABLE_DATAGRAM makes it possible for a server that supports the extension to assert than any DATAGRAM or DATAGRAM Capsule is only the extended flavor.  But how would an extended server handle a non-extended client in that case?  It seems like the extended server has to have a switch to know if the DATAGRAMs are extended or not, so I don't see any value in RELIABLE_DATAGRAM in this use case.  \r\n\r\nPlease help me understand if I'm missing something.",
              "createdAt": "2021-11-19T20:33:02Z",
              "updatedAt": "2021-11-19T20:33:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYOSS",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:37:41Z",
          "updatedAt": "2021-11-19T20:37:42Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "The way this process is supposed to work is that *this* PR is supposed to include the points on which we had consensus, and that means when people object to things which clearly don't, they are removed and deferred for later discussion. If that's not going to happen, then we can just abandon this PR and go back to real time discussion.\r\n\r\n\r\n",
              "createdAt": "2021-11-19T20:37:41Z",
              "updatedAt": "2021-11-19T20:37:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYOoI",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:39:46Z",
          "updatedAt": "2021-11-19T20:39:46Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "> A different issue that I'd like to raise (although I can live with this) is that I'm not really a fan of the extension-that-changes-the-semantics-of-DATAGRAM scheme that is being proposed here.\r\n\r\nI am inclined to agree, but I see the solution as moving the demux higher in the protocol stack (eg: to CONNECT-UDP or CONNECT-IP) rather than down (into QUIC or H3 Datagram).  CONNECT-IP can say all DATAGRAMs on a CONNECT-IP stream have a specific format after the stream ID that includes \"Context ID\", \"Format Type\", etc, and this doesn't need to be negotiated at all.  I'd slightly prefer if those protocols used less generic concepts in doing so, but can live with it either way.",
              "createdAt": "2021-11-19T20:39:46Z",
              "updatedAt": "2021-11-19T20:39:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYPgf",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "achernya",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:44:57Z",
          "updatedAt": "2021-11-19T20:44:57Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "ekr: You appear to have a particularly rigid definition of \"the way this is supposed to work\", and it does not match mine, and I rather suspect many other people's. I am not particularly interested in having a procedural discussion here, but rather working towards consensus on the document. To that end, I would like to see technical reasoning for everything that goes _in_ or gets taken _out_. I do not consider emotional appeals such as \"I don't want this\" to be valid.",
              "createdAt": "2021-11-19T20:44:57Z",
              "updatedAt": "2021-11-19T20:44:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYRF3",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "achernya",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:54:23Z",
          "updatedAt": "2021-11-19T20:54:23Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "afrind: The one downside with your suggestion is it means the context sensitivity still exists, but is a property of the protocol rather than an extension. I think that makes logical sense, but doesn't fully solve the issue I was describing. It's probably the case that we don't necessarily have to solve it, as I mentioned before, I can live with the semantic change here.",
              "createdAt": "2021-11-19T20:54:23Z",
              "updatedAt": "2021-11-19T20:54:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYUE3",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T21:11:58Z",
          "updatedAt": "2021-11-19T21:11:59Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "@afrind regarding your proposal in https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124#discussion_r753515209 the issue there is that it doesn't allow the client to send an unextended datagram in its first flight. For CONNECT-UDP that's really useful: the client wants to send its first UDP payload with the first flight and have the server still correctly parse that even if it doesn't support the extension.\r\n\r\n@ekr and @achernya in terms of process here: it's clear that there isn't consensus to land this PR with RELIABLE_DATAGRAM, and there isn't consensus to land it without RELIABLE_DATAGRAM. We hadn't really discussed RELIABLE_DATAGRAM at our last in-person design team so I wasn't sure what people's thoughts on it were. I should have called this out more explicitly, apologies. Clearly it's something that warrants in-person discussion time. My plan is to keep the topic of RELIABLE_DATAGRAM as an open issue that we will resolve at our next in-person design team meeting. This PR won't get merged until this is resolved.",
              "createdAt": "2021-11-19T21:11:58Z",
              "updatedAt": "2021-11-19T21:12:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYjan",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T23:00:40Z",
          "updatedAt": "2021-11-19T23:00:40Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "> the issue there is that it doesn't allow the client to send an unextended datagram in its first flight.\r\n\r\nI assume you mean 'unextended DATAGRAM Capsule'.  In that case, I think I understand, which is that a DATAGRAM Capsule can be converted to a QUIC DATAGRAM by an intermediary, and there's ambiguity at a server that supports the extension after it confirms support: when did the client receive confirmation and start sending extended QUIC DATAGRAMs?\r\n\r\nThe client can still send DATAGRAM Capsules in this case, and move to QUIC DATAGRAM after it knows whether the server supports the extension or not.  Is there a real use case for sending both extended and non-extended DATAGRAMs in 0-RTT, where we're willing to sacrifice HoL blocking resilience and possible flow control constraints for the extended ones, but not willing to do so for the non-extended ones?  Or maybe the use-cases are small but we think the cost of RELIABLE_DATAGRAM is low and maybe has other utility?\r\n\r\nThis brings me back here:\r\n\r\n> I'm not really a fan of the extension-that-changes-the-semantics-of-DATAGRAM scheme that is being proposed here.\r\n\r\nI think we've shown that it's pretty hard to negotiate changes to QUIC DATAGRAM formats on the fly.  Let's not do that.  The cost of easy extensibility is an additional byte (or two) of header information inside the datagram payload of protocols that need it.  If CONNECT-UDP needs to have a such a header I can live with that.\r\n",
              "createdAt": "2021-11-19T23:00:40Z",
              "updatedAt": "2021-11-19T23:00:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wYkse",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T23:13:31Z",
          "updatedAt": "2021-11-19T23:13:32Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "QUIC DATAGRAM frames and DATAGRAM capsules need to have the exact same semantics, because intermediaries convert blindly between them so you can't know how they were originally sent. That's why my proposal forbids sending either when you support the extension and haven't yet received the peer's headers.\r\n\r\nMy personal opinion is that\r\n- the cost of having RELIABLE_DATAGRAM for an implementation that doesn't care is very low\r\n- RELIABLE_DATAGRAM has value in and of itself\r\n- moving the complexity of contexts to their own extension allows defining different ways to do this down the road, whereas if we say that CONNECT-UDP starts with a varint we've committed to this context design forever\r\n\r\nLet's discuss this in person on 11/29",
              "createdAt": "2021-11-19T23:13:31Z",
              "updatedAt": "2021-11-19T23:13:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wZhs6",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-22T00:58:55Z",
          "updatedAt": "2021-11-22T00:58:56Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "Congratulations, you have just collectively managed to do what we've learned through hard experience is a bad idea: a substantive technical discussion in a comment attached to a line of code on a pull request.\r\n\r\nAll I was asking for was for this to be taken to an issue.  Can we do that?",
              "createdAt": "2021-11-22T00:58:55Z",
              "updatedAt": "2021-11-22T00:58:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wdgnv",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "LGTM minus figuring out what we want to do with RELIABLE_DATAGRAMS.",
          "createdAt": "2021-11-22T21:36:50Z",
          "updatedAt": "2021-11-22T22:09:52Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I would say \"defines a mechanism to convey\", since you're allowed to use other mechanisms if you wish to.",
              "createdAt": "2021-11-22T21:36:51Z",
              "updatedAt": "2021-11-22T22:09:52Z"
            },
            {
              "originalPosition": 137,
              "body": "I would be more specific and say that the datagrams have to be a part of request/response stream.",
              "createdAt": "2021-11-22T21:39:08Z",
              "updatedAt": "2021-11-22T22:09:52Z"
            },
            {
              "originalPosition": 583,
              "body": "I am inclined to make this `Sec-`, because I don't see a scenario in which JavaScript would need to send it, and in general I believe that new request headers should be defined as `Sec-` unless they're both safe and useful for JavaScript applications.",
              "createdAt": "2021-11-22T22:09:21Z",
              "updatedAt": "2021-11-22T22:09:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wd5_l",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-23T00:42:03Z",
          "updatedAt": "2021-11-23T00:42:03Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "Sure! I've filed #125 to discuss this.",
              "createdAt": "2021-11-23T00:42:03Z",
              "updatedAt": "2021-11-23T00:42:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4whXa9",
          "commit": {
            "abbreviatedOid": "28fafe9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-23T18:43:34Z",
          "updatedAt": "2021-11-23T18:44:39Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Agreed, done.",
              "createdAt": "2021-11-23T18:43:34Z",
              "updatedAt": "2021-11-23T18:44:39Z"
            },
            {
              "originalPosition": 137,
              "body": "Agreed, done.",
              "createdAt": "2021-11-23T18:43:39Z",
              "updatedAt": "2021-11-23T18:44:39Z"
            },
            {
              "originalPosition": 583,
              "body": "It sounds like we have folks who prefer with `Sec-` and folks who prefer without. Let's discuss in person.",
              "createdAt": "2021-11-23T18:44:33Z",
              "updatedAt": "2021-11-23T18:44:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wyIC8",
          "commit": {
            "abbreviatedOid": "bd68bbf"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T00:37:03Z",
          "updatedAt": "2021-11-30T00:37:04Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "I've removed RELIABLE_DATAGRAM from this PR. We still have #111 to discuss RELIABLE_DATAGRAM and #125 to discuss zero-latency extensibility, so I'm now marking this comment thread as resolved.",
              "createdAt": "2021-11-30T00:37:04Z",
              "updatedAt": "2021-11-30T00:37:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wyIMo",
          "commit": {
            "abbreviatedOid": "bd68bbf"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T00:38:30Z",
          "updatedAt": "2021-11-30T00:38:30Z",
          "comments": [
            {
              "originalPosition": 583,
              "body": "In today's design team meeting, we reached rough consensus to not use the `Sec-` prefix. We still have [an issue](https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/68) to track adding text to Security Considerations, so I'm marking this comment thread as resolved.",
              "createdAt": "2021-11-30T00:38:30Z",
              "updatedAt": "2021-11-30T00:38:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4wyIVW",
          "commit": {
            "abbreviatedOid": "bd68bbf"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T00:39:43Z",
          "updatedAt": "2021-11-30T00:39:44Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "In today's design team meeting, we reached rough consensus to keep the current approach to intermediaries in this PR. We still have [an issue](https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/69) to track some changes that we still need to make, so I'm marking this comment thread as resolved.",
              "createdAt": "2021-11-30T00:39:43Z",
              "updatedAt": "2021-11-30T00:39:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4w1m_9",
          "commit": {
            "abbreviatedOid": "8cc91a2"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-30T17:41:11Z",
          "updatedAt": "2021-11-30T17:41:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODOpKfc4w2Mbs",
          "commit": {
            "abbreviatedOid": "8cc91a2"
          },
          "author": "achernya",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-30T20:17:30Z",
          "updatedAt": "2021-11-30T20:17:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODOpKfc4w7s7N",
          "commit": {
            "abbreviatedOid": "8cc91a2"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Design-wise: LGTM\r\n\r\nI made a bunch of editorial suggestions. These are non-blocking and we can consider them in follow-on work if nobody wants to change this PR up too much.",
          "createdAt": "2021-12-02T01:10:38Z",
          "updatedAt": "2021-12-02T01:54:19Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "request stream, or simply request?\r\n\r\n```suggestion\r\nAll HTTP Datagrams are associated with an HTTP request.\r\n```",
              "createdAt": "2021-12-02T01:10:38Z",
              "updatedAt": "2021-12-02T01:54:19Z"
            },
            {
              "originalPosition": 51,
              "body": "Strictly editorial: a better way to structure this section would be to describe what we defin multiplexing is. Then the follow on paragraphs state how each version can (or cannot) satisfy that. That would mean simplifying paragraph 2 of this section by extracting the \"need the ability\" piece so that the text focuses on how not why.\r\n\r\nSuch an editorial change could be tracked as follow on work, since this PR is focuesd on design changes.",
              "createdAt": "2021-12-02T01:17:14Z",
              "updatedAt": "2021-12-02T01:54:19Z"
            },
            {
              "originalPosition": 218,
              "body": "ambiguity alert: do we striclty mean HTTP versions? Presumably HTTP/3 connections that do not support QUIC DATAGRAM (or chose not to use it even if supported) are also in scope.\r\n\r\nConsider moving the last sentence here to para 3, so that mention of Capsule Protocol plus HTTP Datagrams is grouped.",
              "createdAt": "2021-12-02T01:23:24Z",
              "updatedAt": "2021-12-02T01:54:19Z"
            },
            {
              "originalPosition": 205,
              "body": "Editorial: Not strictly related to this PR but consider renaming this section to `Capsule Protocol` and the subsection to something else (possibly `Using the Capsule Protocol\")",
              "createdAt": "2021-12-02T01:27:20Z",
              "updatedAt": "2021-12-02T01:54:19Z"
            },
            {
              "originalPosition": 228,
              "body": "Editorial: you might be able to strengthen the definition of data stream a bit by extracting the semantic from version concerns. For example, something like\r\n\r\n\"This specification defines the \"data stream\" of an HTTP request as the\r\nbidirectional stream of bytes that follow the header section in both directions. \r\nThe concept of a data stream is particularly relevant for methods such as \r\nCONNECT. In the client-to-server direction, the data stream always exists.\r\nIn the server-to-client direction, the data stream only exists if when there\r\nis a 2xx (Successful) response. In HTTP/1.x, the data stream consists of all\r\nbytes on the connection that follow the blank line concluding header section.\r\nIn HTTP/2 and HTTP/3, the data stream of a given HTTP request consists\r\nof all bytes sent in DATA frames with the corresponding stream ID. \"",
              "createdAt": "2021-12-02T01:44:10Z",
              "updatedAt": "2021-12-02T01:54:19Z"
            },
            {
              "originalPosition": 297,
              "body": "editorial: move `;see {{datagram-capsule}}` to the first ref here",
              "createdAt": "2021-12-02T01:45:56Z",
              "updatedAt": "2021-12-02T01:54:19Z"
            },
            {
              "originalPosition": 378,
              "body": "Editorial: Consider moving this paragraph closer to the definition of data stream, so that you can lose the first sentence.",
              "createdAt": "2021-12-02T01:47:40Z",
              "updatedAt": "2021-12-02T01:54:19Z"
            },
            {
              "originalPosition": 483,
              "body": "see earlier comment about whether this is strictly \"version of HTTP\" or not.",
              "createdAt": "2021-12-02T01:48:37Z",
              "updatedAt": "2021-12-02T01:54:19Z"
            },
            {
              "originalPosition": 554,
              "body": "Editorial: consider moving this whole section to be part of the definition of Capsule protocol definition section",
              "createdAt": "2021-12-02T01:52:30Z",
              "updatedAt": "2021-12-02T01:54:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4w2Is9",
          "commit": {
            "abbreviatedOid": "8cc91a2"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Good direction; some open issues to resolve, but I don't think they block the main direction of the work.",
          "createdAt": "2021-11-30T20:00:52Z",
          "updatedAt": "2021-12-02T21:14:39Z",
          "comments": [
            {
              "originalPosition": 569,
              "body": "```suggestion\r\na Boolean. Its ABNF is:\r\n```",
              "createdAt": "2021-11-30T20:00:52Z",
              "updatedAt": "2021-12-02T21:14:39Z"
            },
            {
              "originalPosition": 630,
              "body": "Should status codes that don't return a body (204, 205) also be prohibited, since there won't be a data stream?  What about status codes that specify their response format (206)?  Is the absence (or value) of Content-Type mandated?",
              "createdAt": "2021-12-02T21:13:46Z",
              "updatedAt": "2021-12-02T21:14:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4xAACJ",
          "commit": {
            "abbreviatedOid": "8cc91a2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-02T22:27:44Z",
          "updatedAt": "2021-12-02T22:40:23Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "This sounds good, but I agree - let's tackle this as editors once the outcome of the design team is merged.",
              "createdAt": "2021-12-02T22:27:45Z",
              "updatedAt": "2021-12-02T22:40:23Z"
            },
            {
              "originalPosition": 205,
              "body": "Let's tackle that post design team",
              "createdAt": "2021-12-02T22:29:19Z",
              "updatedAt": "2021-12-02T22:40:23Z"
            },
            {
              "originalPosition": 218,
              "body": "Fixed",
              "createdAt": "2021-12-02T22:31:19Z",
              "updatedAt": "2021-12-02T22:40:23Z"
            },
            {
              "originalPosition": 228,
              "body": "Let's tackle that in a follow-up since the design team isn't touching the concept of the data stream",
              "createdAt": "2021-12-02T22:32:14Z",
              "updatedAt": "2021-12-02T22:40:23Z"
            },
            {
              "originalPosition": 297,
              "body": "Done",
              "createdAt": "2021-12-02T22:32:52Z",
              "updatedAt": "2021-12-02T22:40:23Z"
            },
            {
              "originalPosition": 378,
              "body": "The purpose of this is to put requirements on the capsule protocol, so it wouldn't look right if moved to before the capsule protocol isn't introduced.",
              "createdAt": "2021-12-02T22:34:02Z",
              "updatedAt": "2021-12-02T22:40:23Z"
            },
            {
              "originalPosition": 483,
              "body": "Fixed",
              "createdAt": "2021-12-02T22:34:11Z",
              "updatedAt": "2021-12-02T22:40:23Z"
            },
            {
              "originalPosition": 554,
              "body": "Done",
              "createdAt": "2021-12-02T22:35:13Z",
              "updatedAt": "2021-12-02T22:40:23Z"
            },
            {
              "originalPosition": 630,
              "body": "Let's take that to issues (I filed #130 and #131), I think we can handle this outside the design team",
              "createdAt": "2021-12-02T22:37:08Z",
              "updatedAt": "2021-12-02T22:40:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 132,
      "id": "PR_kwDODOpKfc4vVekp",
      "title": "Clarify meaning of understanding capsule request semantics",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/132",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #127.\r\n\r\ncc @martinthomson ",
      "createdAt": "2021-12-02T23:53:50Z",
      "updatedAt": "2021-12-03T04:37:35Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "baseRefName": "2021_design_team_consensus",
      "baseRefOid": "4dc29216f9d245822a6e4c5947209cbf14c71a39",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-h3-datagram",
      "headRefName": "fix127",
      "headRefOid": "6ddc3b2a3904965842d5b14cc6f427462391c86f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODOpKfc4xAdxR",
          "commit": {
            "abbreviatedOid": "39f20e5"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-03T02:42:27Z",
          "updatedAt": "2021-12-03T02:47:00Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nrecognizing the HTTP Upgrade token or the Capsule-Protocol header from {{hdr}})\r\n```",
              "createdAt": "2021-12-03T02:42:27Z",
              "updatedAt": "2021-12-03T02:47:00Z"
            },
            {
              "originalPosition": 9,
              "body": "I might prefer two discrete sentences:\r\n\r\n> An intermediary can identify the use of the capsule protocol either through the presence of the Capsule-Protocol header field ({{hdr}}) or by understanding the chosen HTTP Upgrade token. An intermediary that identifies the use of the capsule protocol MAY convert between DATAGRAM capsules and QUIC DATAGRAM frames when forwarding.",
              "createdAt": "2021-12-03T02:46:44Z",
              "updatedAt": "2021-12-03T02:47:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODOpKfc4xAno9",
          "commit": {
            "abbreviatedOid": "6ddc3b2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-03T04:37:35Z",
          "updatedAt": "2021-12-03T04:37:35Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Sounds good to me, done",
              "createdAt": "2021-12-03T04:37:35Z",
              "updatedAt": "2021-12-03T04:37:35Z"
            }
          ]
        }
      ]
    }
  ]
}